---
title: "Таблицы"
subtitle: "Визуализация и анализ географических данных на языке R"
author: "Тимофей Самсонов"
date: "`r Sys.Date()`"
output:
  xaringan::moon_reader:
    css: [default, "style.css"]
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
---

```{r setup, echo = FALSE, purl = FALSE, cache = FALSE, include=FALSE}
library(datasets)
knitr::opts_knit$set(global.par = TRUE, root.dir = "../")
knitr::opts_chunk$set(warning=FALSE, collapse=TRUE)
```

## Tidyverse

Пакет       | Назначение
------------|-----------
__tibble__  | Усовершенствованный вариант фрейма данных
__dplyr__   | Грамматика манипуляций над табличными данными
__tidyr__   | Приведение таблиц в аккуратный вид, удобный для обработки
__readr__   | Чтение табличных данных из текстовых файлов
__readxl__  | Чтение табличных данных из файлов Microsoft Excel
__haven__   | Чтение табличных данных из файлов SPSS, Stata и SAS
__purrr__   | Функциональное программирование
__stringr__ | Работа со строками
__forcats__ | Автоматизация работы с факторами
__ggplot2__ | Построение графиков на основе правил грамматики 

Вы можете подключать эти пакеты по одному, или все вместе, используя команду `library(tidyverse)`. 

---

## Вызов функций без подключения пакета

`package::function()`, где `package` — название пакета, а `function` - название функции. 

> Подобный синтаксис бывает особенно удобным, когда _в разных пакетах имеются функции с одинаковым именем_.

---

## Тибблы

```{r}
library(tibble)
tibble(
  a = 1:3, 
  b = 1, 
  c = -1:1
)
dfr = data.frame(a = 1:3, b = 1,  c = -1:1)
as_tibble(dfr)
```

---

## Тибблы и фреймы данных

Тибблы можно создавать вручную не только по столбцам, но и по строкам, используя функцию `tribble()`:
```{r}
tribble(
  ~a, ~b, ~c,
   1,  1, -1,
   2,  1,  0,
   3,  1,  1
)
```


---

## Встроенные данные

```{r, eval=FALSE}
data(package = 'dplyr')
```
```{r, echo = FALSE}
knitr::include_graphics('../images/data_dplyr.png')
```

---

## Встроенные данные

Выгрузка данных из пакета:
```{r}
data(starwars, package = 'dplyr')
starwars
```

---

## Текстовые файлы

__CSV (Comma-separated value)__ — общее название для формата представления таблиц в виде текстовых файлов, организованных по следующему принципу:

1. Каждая строка в файле соответствует строке в таблице.

2. Ячейки отделяются друг от друга символом-разделителем.

3. Если ячейка пустая, то между соседними разделителями не должно быть никаких символов.

---

## Файлы с разделителем

Численность населения в Федеральных округах Российской Федерации за 2005 и 2010-2013 гг. (по данным Росстата):
```
N,Region,Year05,Year10,Year11,Year12,Year13
1,Центральный,4341,3761,3613,3651,3570
2,Северо-Западный,3192,3088,2866,2877,2796
3,Южный федеральный,1409,1446,1436,1394,1321
4,Северо-Кавказский,496,390,397,395,374
5,Приволжский,3162,2883,2857,2854,2849
6,Уральский,1681,1860,1834,1665,1624
7,Сибирский,2575,2218,2142,2077,1941
8,Дальневосточный,871,870,821,765,713
```

---

## Файлы с разделителем

Функции для чтения из пакета `readr`:

- `read_csv()` — запятая;

- `read_csv2()` — точка с запятой;

- `read_tsv()` — табуляция и пробел;

- `read_delim()` — произвольный разделитель;

---

## Файлы с разделителем

```{r}
library(readr)
(okruga = read_csv('data/okruga.csv'))
```

---

## Файлы с фиксированной шириной столбца

```
1   43.500000       28.000000       111.05298       178.41447    
2   43.500000       28.500000       187.38620       301.05331    
3   44.000000       28.500000       168.82031       271.22421    
4   44.500000       28.500000       157.22586       252.59746    
5   44.500000       29.000000       189.46452       304.39597    
6   45.000000       29.000000       170.40709       273.77536    
7   45.000000       29.500000       198.92389       319.58777    
8   45.500000       29.500000       188.64406       303.07242    
9   46.000000       30.000000       180.10541       289.35379    
10  46.000000       30.500000       207.91818       334.03564
```

---

## Файлы с фиксированной шириной столбца

Функции для чтения в __readr__:

- `read_fwf()` читает файлы с фиксированной шириной столбца, позволяя задавать ширины столбцов

- `read_table()` читает наиболее распространенный вариант файла с фиксированной шириной столбца, в котором колонки разделены пробелами

---

# Файлы с фиксированной шириной столбца

```{r}
(wenergy = read_table('data/wind_energy.txt', col_names = c('id', 'lat', 'lon', 'energy50', 'energy110')))
```

---

## Таблицы Microsoft Excel

Чтение с помощью __readxl__:
```{r}
library(readxl)
(reforest = read_excel('data/reforest.xlsx', 
                       col_types = c('text', rep('numeric', 8))))
```

---

## Просмотр


- `print(reforest)` — выводит фрейм в консоль целиком (можно написать просто `tab` в консоли).

- `head(reforest, n)` — отбирает первые $n$ строк фрейма 

- `tail(reforest, n)` — отбирает последние $n$ строк фрейма

> По умолчанию для функций `head()` и `tail()` $n=6$.

---

# Просмотр

```{r, collapse=TRUE}
head(reforest)
tail(reforest)
```

---

## Функция View()

`RStudio` предоставляет графический интерфейс для просмотра таблиц, в котором таблицу можно сортировать и фильтровать:
```{r, eval = FALSE, collapse=TRUE}
View(tab)
```

> __Внимание:__ не следует оставлять вызовы функции `View()` в тексте законченной программы. 

> Используйте `View()` для вывода окончательного результата в конце программы или при отладке программы.

---

## Названия

Названия строк и столбцов можно получить с помощью функций `colnames()` и `rownames()`:
```{r}
# Чтение названий столбцов и строк
colnames(okruga)
rownames(okruga)

# Замена названий столбцов и строк
colnames(okruga) <- c("N", "Region", "Year05", "Year10", "Year11", "Year12", "Year13")
print(okruga)
```

Названия строк редко заменяются, поскольку с точки зрения реляционной алгебры большого смысла они не имеют.

---

## Обращение к столбцам

Тип возвращаемого значения зависит от синтаксиса:

- `$name` возвращает вектор;
- `[, name]` возвращает вектор;
- `[, c(name1, name2, ...)]` возвращает фрейм данных;
- `[name]` возвращает фрейм данных.

```{r, eval=FALSE, collapse=TRUE}
# Один столбец - результат зависит от запятой
okruga$Year05      # столбец в виде вектора
okruga[, "Year05"] # столбец в виде вектора
okruga[, 2]        # столбец в виде вектора

okruga["Year05"] # столбец в виде фрейма данных/тиббла
okruga[2]        # столбец в виде фрейма данных/тиббла

# Несколько столбцов - всегда фрейм данных/тиббл
okruga[, c(1, 4)]
okruga[, c("Region", "Year11")]
okruga[c("Region", "Year11")]
okruga[c(1, 4)]
```

---

# Обращение к строкам

```{r, eval=FALSE}
okruga[5, ] # Одна строка
okruga[2:4, ] # Несколько строк
okruga[okruga$Year10 > 2000, ] # Несколько строк через TRUE/FALSE
```

> В отличие от работы со столбцами, выбор строк всегда возвращает таблицу (фрейм или тиббл).

---

## Грамматика манипуляций dplyr

Функция       | Назначение
--------------|-----------------
`select()`    | Выбор переменных
`filter()`    | Выбор строк (фильтрация)
`arrange()`   | Упорядочение строк
`mutate()`    | Добавление и изменение переменных (мутирование)
`summarise()` | Агрегирование значений переменных
`group_by()`  | Группировка строк (для последующего агрегирования)

> Названия столбцов в функциях __dplyr__ указываются без кавычек, что позволяет сделать код проще и читаемее

---

# Грамматика манипуляций

Рассмотрим применение этих функций на примере работы с таблицей по восстановлению лесного фонда в регионах России. 

Для начала переименуем столбцы с годами, чтобы их названия начинались с буквы `y`:
```{r}
old_names = colnames(reforest)
colnames(reforest) = c(old_names[1], paste('y', old_names[2:9], sep = ''))
library(dplyr)
```

---

## Выбор переменных

`select()`
```{r}
(rdf = select(reforest, Region, y2010, y2015))
```

---

## Выбор переменных

`select()`

Можно исключать (`-`) столбцы и указывать диапазоны (`:`) названий, если они идут друг за другом.

```{r}
(rdf = select(reforest, -y2005, -y2011:-y2014, -y2016))
```

---

## Выбор строк (фильтрация)

`filter()`
```{r}
flt = !stringr::str_detect(rdf$Region, 'Федерация|федеральный округ') # готовим фильтр для строк
(regdf = filter(rdf, flt)) # применяем фильтр
```

---

## Выбор строк (фильтрация)

`filter()`

```{r}
filter(regdf, y2015 > 50)
```

---

## Сортировка

`arrange()`
```{r}
arrange(regdf, y2015) # по возрастанию
```

---

## Сортировка

`desc()`: сортировка по убыванию
```{r}
arrange(regdf, desc(y2015)) # по убыванию
```

---

## Добавление или изменение переменных (мутирование)

`mutate()`: изменяет или создает новые столбцы
```{r}
(regdf = mutate(regdf, delta = y2015 - y2010))
```

---

## Добавление или изменение переменных (трансмутирование)

`transmute()` сохраняет только столбцы, указанные в параметрах
```{r}
transmute(regdf, Region = Region, delta = y2015 - y2010) # сохраняем только Region и delta
```

---

## Агрегирование

`summarise()`
```{r}
summarise(regdf, 
          sumforest = sum(y2015, na.rm = TRUE),
          minforest = min(y2015, na.rm = TRUE),
          maxforest = max(y2015, na.rm = TRUE))
```

---

## Агрегирующие функции

В пакете __dplyr__ также имеются полезные агрегирующие функции:

- `n()` вычисляет количество элементов.

- `n_distinct()` вычисляет количество уникальных элементов.

- `first(x)`, `last(x)` и `nth(x, n)` извлекают, первый, последний и n-ный элемент. 

---

## Группировка

Исходные данные:
```{r, echo=FALSE}
flt2 = stringr::str_detect(rdf$Region, 'федеральный округ') # ищем округа
rdf2 = mutate(rdf, okrug = if_else(flt2, Region, NULL)) # перенесем названия округов в новый столбец
rdf2 = tidyr::fill(rdf2, okrug) # заполним все пустые строчки предыдущим значением
(regdf = filter(rdf2, flt)) # оставим только регионы
```

---

## Группировка

`group_by()` + `row_number()`: регион с максимальной величиной показателя в каждом округе:
```{r}
regdf_gr = group_by(regdf, okrug)
regdf_arr = arrange(regdf_gr, desc(y2015))
(regdf_res = filter(regdf_arr, row_number() == 1))
```

---

## Группировка

`group_by()` + `summarise()`: суммарный объем лесовосстановительных работ по округам:
```{r}
regdf_gr = group_by(regdf, okrug)
summarise(regdf_gr, total = sum(y2015, na.rm = TRUE))
```

---

## Конвейер манипуляций

 __Пайп-оператор `%>%`__ предназначен для компактной и наглядной записи _последовательностей_ обработки данных. Работает он следующим образом:

 - `x %>% f` эквивалентно `f(x)`
 
 - `x %>% f(y)` эквивалентно `f(x, y)`
 
 - `x %>% f %>% g %>% h` эквивалентно `h(g(f(x)))`

> Пайп-оператор можно быстро набрать в RStudio, нажав клавиатурное сочетание <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>M</kbd> (<kbd>Cmd</kbd> + <kbd>Shift</kbd> + <kbd>M</kbd> на помпьютерах Mac)

---

## Конвейер манипуляций

С помощью пайп-оператора код по нахождению региона-лидера можно записать так:
```{r, echo = FALSE}
regdf = rdf %>% 
  mutate(okrug = if_else(flt2, Region, NULL)) %>% 
  tidyr::fill(okrug) %>% 
  filter(flt)
```
```{r, collapse=TRUE}
leaders = regdf %>% 
  group_by(okrug) %>% 
  arrange(desc(y2015)) %>% 
  filter(row_number() == 1)

head(leaders)
```

---

## Сравнение

.pull-left[
Традиционно:
```{r, collapse=TRUE}
leaders = filter(
            arrange(
              group_by(
                regdf, 
                okrug
              ),
              desc(y2015)
            ),
            row_number() == 1
          )
```
]

.pull-right[
С помощью конвейера:
```{r, collapse=TRUE}
leaders = regdf %>% 
  group_by(okrug) %>% 
  arrange(desc(y2015)) %>% 
  filter(row_number() == 1)
```
]

---

## Преобразование структуры

Функции пакета __tidyr__

- `pivot_longer()`: широкие таблицы в длинные.

- `pivot_wider()`: длинные таблицы в широкие.

> В tidyr более ранних чем 1.0.0 версий для этих целей использовались функции `gather()` и `spread()`

Вспомогательные:

- `separate()`: разделить столбец.

- `unite()`: соединить несколько столбцов.

---

## Преобразование структуры

`pivot_longer()`: широкая форма в длинную форму
```{r}
library(tidyr)
(reforest_tidy = reforest %>% 
    pivot_longer(cols = y2005:y2016,
                 names_to = 'year', 
                 values_to = 'value')
)
```

---

## Преобразование структуры

`separate()` + `select()` + `mutate()`: разделить столбец `year`
```{r}
(reforest_tidy = reforest_tidy %>% 
  separate(year, c('y', 'year'), 1) %>% 
  select(-y) %>% 
  mutate(year = as.integer(year)))
```

---

## Преобразование структуры

`filter()`
```{r}
reforest_tidy %>% 
  filter(year > 2011 & year < 2016 & value == 0)
  
```

---

## Преобразование структуры

`pivot_wider()`: длинная форма в широкую форму
```{r}
(reforest = reforest_tidy %>% 
   pivot_wider(names_from = year, 
               values_from = value)
 )
```

---

## Соединение (мутирующее)

- `inner_join(x, y, by = )` возвращает все строки из `x`, для которых имеются соответствующие строки в `y`, а также все столбцы из `x` и `y`.

- `left_join(x, y, by = )` возвращает все строки из `x`, а также все столбцы из `x` и `y`. Строки в `x`, для которых не найдены соответствия в `y`, будут иметь значения `NA` в присоединенных столбцах

- `right_join(x, y, by = )` возвращает все строки из `y`, а также все столбцы из `x` и `y`. Строки в `y`, для которых не найдены соответствия в `x`, будут иметь значения `NA` в присоединенных столбцах

- `full_join(x, y, by = )` возвращает все строки и колонки из `x` и `y`. В строках, для которых не найдено соответствие ячейки присоединяемых столбцов будут заполнены значениями `NA`

---

## Соединение (фильтрующее)

- `semi_join(x, y, by = )` возвращает все строки из `x`, для которых имеются соответствующие строки в `y`, а также все столбцы из `x`

- `anti_join(x, y, by = )` возвращает все строки из `x`, для которых _не_ найдены соответствующие строки в `y`, а также все столбцы из `x`

---

## Соединение

Таблица по лесозаготовкам:
```{r}
(timber = read_excel('data/timber.xlsx', 
                    col_types = c('text', rep('numeric', 8))) %>% 
  filter(!stringr::str_detect(Регион, 'Федерация|федеральный округ')))
```

---

## Соединение

Приводим в аккуратный вид:
```{r}
(timber_tidy = timber %>% 
  gather(year, harvest, `2010`:`2016`) %>% 
  transmute(Region = Регион,
            year = as.numeric(year),
            harvest = harvest))
```

---

## Соединение

`inner_join()`: соединяем лесозаготовки и лесовосстановление по региону и году
```{r}
(compare = reforest_tidy %>% 
  inner_join(timber_tidy, 
             by = c("Region" = "Region", 
                    "year" = "year"))
)
```

---

## Соединение

Вычисляем соотношение:
```{r}
(compare = compare %>% 
   mutate(ratio = 1000 * value / harvest) %>% 
   select(Region, year, ratio, value, harvest) %>% 
   arrange(year, desc(ratio)))
```

---

## Экспорт в файл

`write_csv()`: файлы с разделителем
```{r}
write_csv(compare, "data/output/timber_compare.csv")
```

`write_csv()`: файлы Excel
```{r}
library(writexl)
write_xlsx(compare, "data/output/timber_compare.xlsx")
```

---

## Рекомендации по подготовке таблиц для чтения в R

- В первой строке таблицы должны располагаться названия столбцов.

- Во второй строке таблицы должны начинаться данные. Не допускайте многострочных заголовков.

- В названиях столбцов недопустимы объединенные ячейки, покрывающие несколько столбцов. Это может привести к неверному подсчету количества столбцов и, как следствие, некорректному чтению таблицы в целом.

---

## Рекомендации по подготовке таблиц для чтения в R

- Названия столбцов должны состоять из латинских букв и цифр, начинаться с буквы и не содержать пробелов. Плохое название столбца: `Валовый внутренний продукт за 2015 г.`. Хорошее название столбца: `GDP2015`.

- Некоторые ошибки данных в таблицах (такие как неверные десятичные разделители), проще найти и исправить в табличном/текстовом редакторе, нежели после загрузки в __R__.