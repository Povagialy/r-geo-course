<!DOCTYPE html>
<html>
  <head>
    <title>Структуры данных и циклы</title>
    <meta charset="utf-8">
    <meta name="author" content="Тимофей Самсонов" />
    <meta name="date" content="2018-09-11" />
    <link href="02-DataStructures_slides_files/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="02-DataStructures_slides_files/remark-css-0.0.1/metropolis.css" rel="stylesheet" />
    <link href="02-DataStructures_slides_files/remark-css-0.0.1/metropolis-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Структуры данных и циклы
## Визуализация и анализ географических данных на языке R
### Тимофей Самсонов
### 2018-09-11

---


# Структуры данных и циклы



## __Структура данных__ --- это программная единица, позволяющая хранить и обрабатывать множество однотипных и/или логически связанных данных.

---

# Векторы

Вектор представляет собой упорядоченную последовательность объектов одного типа. Вектор может состоять _только_ из чисел, _только_ из строк, _только_ из дат или _только_ из логических значений и т.д. 

## Создание

Существует множество способов создания векторов. Среди них наиболее употребительны:

1. Явное перечисление элементов
2. Создание пустого вектора ("болванки"), состоящего из заданного числа элементов
3. Генерация последовательности значений
4. Генерация случайного множества значений

---

# Векторы

Для создания вектора путем __перечисления__ элементов используется функция `c()`:

```r
# вектор из строк — цвета некоторых веток Московского метро
colors = c("Красная", "Зеленая", "Синяя", "Коричневая", "Оранжевая")
colors
## [1] "Красная"    "Зеленая"    "Синяя"      "Коричневая" "Оранжевая"
```


```r
# вектор из чисел — длина веток в километрах (в той же последовательности)
lengths = c(28, 40, 45, 19, 38)
lengths
## [1] 28 40 45 19 38
```


```r
# вектор из булевых переменных — наличие  открытых наземных участков (в той же последовательности)
opens = c(FALSE, TRUE, TRUE, FALSE, FALSE)
opens
## [1] FALSE  TRUE  TRUE FALSE FALSE
```

---

# Векторы

## Создание пустого вектора


```r
# Вектор из 5 элементов, который предполагается заполнить целыми числами
intvalues = vector(mode = "integer", length = 5)
intvalues # по умолчанию заполнен нулями
## [1] 0 0 0 0 0

# Вектор из 10 элементов, который предполагается заполнить символьными данными (строками)
charvalues = vector("character", 10)
charvalues # по умолчанию заполнен пустыми строками
##  [1] "" "" "" "" "" "" "" "" "" ""
```

---

# Векторы

## Генерация последовательности

Наконец, третий распространенный способ создания векторов --- это __генерация последовательности__. Чтобы сформировать вектор из натуральных чисел от `M` до `N`, можно воспользоваться специальной конструкцией: `M:N`:

```r
index = 1:5 # эквивалентно c(1,2,3,4,5)
index
## [1] 1 2 3 4 5
```

Существует и более общий способ создания последовательности --- функция `seq()`, которая позволяет генерировать вектора значений нужной длины и/или с нужным шагом:

```r
seq(from = 1, by = 2, length.out = 10) # 10 нечетных чисел, начиная с единицы
##  [1]  1  3  5  7  9 11 13 15 17 19
seq(from = 2, to = 20, by = 3) # от 2 до 20 с шагом 3 (сколько поместится)
## [1]  2  5  8 11 14 17 20
seq(length.out = 10, to = 2, by = -2) # убывающая последовательность из 10 четных чисел с последним элементом, равным 2
##  [1] 20 18 16 14 12 10  8  6  4  2
```

---

# Векторы

## Генерация последовательности дат

Аналогичным образом можно создавать _последовательности дат_:

```r
seq(from = as.Date('2016/09/01'), by = 1, length.out = 7) # Даты первой недели учебного 2016/2017 года
## [1] "2016-09-01" "2016-09-02" "2016-09-03" "2016-09-04" "2016-09-05"
## [6] "2016-09-06" "2016-09-07"

seq(from = Sys.Date(), by = 7, length.out = 5) # Пять дат через неделю, начиная с сегодняшнего дня
## [1] "2018-09-11" "2018-09-18" "2018-09-25" "2018-10-02" "2018-10-09"
```

## Генерация случайной последовательности

Наиболее часто испольщуются функции `runif()` (равномерное распределение) и `rnorm()` (нормальное распределение):

```r
runif(5, 0, 100) # 5 чисел равномерного распределения в диапазоне от 0 до 100
## [1] 65.82276 84.07328 64.64281 47.13194 29.34322
rnorm(5, 10, 5) # 5 чисел нормального распределения со средним = 10 и СКО = 5
## [1] 19.070804  3.631249 17.562301  2.397909 12.044795
```

---

# Индексирование

К отдельным __элементам вектора__ можно обращаться по их индексам:

```r
colors[1] # первый элемент вектора
## [1] "Красная"
colors[3] # третий элемент
## [1] "Синяя"
```

__Количество элементов (длину) вектора__ можно узнать с помощью функции `length()`:

```r
length(colors)
## [1] 5
```

Последний элемент вектора можно извлечь, если мы знаем его длину:

```r
n = length(colors)
colors[n]
## [1] "Оранжевая"
```

---

# Индексирование

## Извлечение подвекторов

Последовательности удобно использовать для извлечения подвекторов. Предположим, нужно извлечь первые 4 элемента. Для этого запишем:

```r
lengths[1:4]
## [1] 28 40 45 19
```

Индексирующий вектор можно создать заранее. Это удобно, если номера могут меняться в программе:

```r
m = 1
n = 4
index = m:n
lengths[index]
## [1] 28 40 45 19
```

---

# Индексирование

## Произвольные последовательности

Обратите внимание на то что по сути один вектор используется для извлечения элементов из другого вектора. Это означает, что мы можем использовать не только простые последовательности натуральных чисел, но и векторы из прозвольных индексов. Например:

```r
index = c(1, 3, 4) # хотим извлечь 1, 3 и 4 элемент списка
lengths[index]
## [1] 28 45 19

index = c(5, 1, 4, 2) # индексы могут располагаться в произвольном порядке
lengths[index]
## [1] 38 28 19 40
```

---

# Преобразование

К числовым векторам можно применять множество функций. Прежде всего, нужно знать функции вычисления базовых параметров статистического ряда --- минимум, максимум, среднее, медиана, дисперсия, размах вариации, среднеквадратическое отклонение, сумма:

```r
min(lengths) # минимум
## [1] 19
max(lengths) # максимум
## [1] 45
range(lengths) # размах вариации = максимум - минимум
## [1] 19 45
mean(lengths) # среднее арифметическое
## [1] 34
median(lengths) # медиана
## [1] 38
var(lengths) # дисперсия (по английски - вариация, variation)
## [1] 108.5
sd(lengths) # среднеквадратическое отклонение (standard deviation)
## [1] 10.41633
sum(lengths) # сумма
## [1] 170
```

---

# Преобразование

Любая математическая функция, применимая к числу, будет применима и к вектору:

```r
lengths * 1000 # преобразуем длины линий в метры
## [1] 28000 40000 45000 19000 38000
sqrt(lengths) # квадратный корень из длины каждого элемента
## [1] 5.291503 6.324555 6.708204 4.358899 6.164414

stations = c(20, 21, 22, 12, 24) # количество станций

dens = stations / lengths # плотность станций по веткам метро = кол-во станций / длина 
dens
## [1] 0.7142857 0.5250000 0.4888889 0.6315789 0.6315789
```

---

# Сортировка и поиск

К важнейшим преобразованиям векторов относится их __сортировка__:

```r
sort(lengths) # сортировка по возрастанию значений
## [1] 19 28 38 40 45
lengths # сравним с исходным
## [1] 28 40 45 19 38

sort(lengths, decreasing = TRUE) # сортировка по убыванию значений. Нужно задать параметр decreasing
## [1] 45 40 38 28 19
```

Для __поиска__ индекса элемента используется функция `match()`:

```r
(l = max(lengths)) # находим максимальное значение
## [1] 45
(idx = match(l, lengths)) # находим индекс элемента, равного l, в списке lengths
## [1] 3
(color = colors[idx]) # извлекаем цвет ветки метро
## [1] "Синяя"
```

---

# Проверка условий

Проверка условия для вектора приводит к получению вектора логических значений:

```r
lengths &gt; 20
## [1]  TRUE  TRUE  TRUE FALSE  TRUE
```

Для векторов существует специальная форма векторизованного условного оператора -- функция `ifelse()`. Например, мы можем охарактеризовать каждую линию метро как длинную или короткую, установив порог в 20 км:

```r
lengths
## [1] 28 40 45 19 38
(line_type = ifelse(lengths &gt; 20, 'Длинная', 'Короткая'))
## [1] "Длинная"  "Длинная"  "Длинная"  "Короткая" "Длинная"
```

---

# Описательные статистики

Можно получить краткую статистическую сводку по вектору (и любой другой структуре данных) с использованием функции `summary()`. Для качественных переменных выдаются частоты вхождения каждого случая, для количественных — набор основных описательных статистик:

```r
summary(lengths)
##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##      19      28      38      34      40      45
summary(opens)
##    Mode   FALSE    TRUE 
## logical       3       2
```

---

# Матрицы

__Матрица__ — это обобщение понятия вектора на 2 измерения. Матрица, как правило, создается с помощью функции `matrix()`, которая принимает 3 обязательных аргумента: вектор исходных значений, количество строк и количество столбцов:

```r
v = 1:12  # создадим вектор из натуральных чисел от 1 до 12
m = matrix(v, nrow = 3, ncol = 4)
m
##      [,1] [,2] [,3] [,4]
## [1,]    1    4    7   10
## [2,]    2    5    8   11
## [3,]    3    6    9   12
```

По умолчанию матрица заполняется данными вектора по столбцам. Если вы хотите заполнить ее по строкам, необходимо указать параметр `byrow = TRUE`:

```r
m = matrix(v, nrow = 3, ncol = 4, byrow = TRUE)
m
##      [,1] [,2] [,3] [,4]
## [1,]    1    2    3    4
## [2,]    5    6    7    8
## [3,]    9   10   11   12
```

---

# Матрицы

## Индексирование

Доступ к элементам матрицы осуществляется аналогично вектору:

```r
m[2,4]  # 2 строка, 4 толбец
## [1] 8
m[3,1]  # 3 строка, 1 столбец
## [1] 9
```

Чтобы извлечь одну строку или столбецб необходимо пропустить номер второго измерения. Результат является вектором:

```r
m[2,]  # 2 строка
## [1] 5 6 7 8
m[,3]  # 3 cтолбец
## [1]  3  7 11
```

---

# Матрицы

## Преобразование

К матрицам можно применять операции, аналогичные операциям над векторами:

```r
log(m)  # натуральный логарифм ото всех элементов
##          [,1]      [,2]     [,3]     [,4]
## [1,] 0.000000 0.6931472 1.098612 1.386294
## [2,] 1.609438 1.7917595 1.945910 2.079442
## [3,] 2.197225 2.3025851 2.397895 2.484907
sum(m)  # сумма всех элементов матрицы
## [1] 78
```

B и получать по ним описательные статистики:

```r
summary(m)
##        V1          V2           V3           V4    
##  Min.   :1   Min.   : 2   Min.   : 3   Min.   : 4  
##  1st Qu.:3   1st Qu.: 4   1st Qu.: 5   1st Qu.: 6  
##  Median :5   Median : 6   Median : 7   Median : 8  
##  Mean   :5   Mean   : 6   Mean   : 7   Mean   : 8  
##  3rd Qu.:7   3rd Qu.: 8   3rd Qu.: 9   3rd Qu.:10  
##  Max.   :9   Max.   :10   Max.   :11   Max.   :12
```

---

# Матрицы

## Сортировка

Сортировка матрицы приведет к тому что будет возвращен обычный вектор:

```r
sort(m)
##  [1]  1  2  3  4  5  6  7  8  9 10 11 12
```

---

# Матрицы

## Специальные операции

К матрицам применимы операции транспонирования и вычисления определителя:

```r
t(m)  # транспонированная матрица
##      [,1] [,2] [,3]
## [1,]    1    5    9
## [2,]    2    6   10
## [3,]    3    7   11
## [4,]    4    8   12
m2 = matrix(-3:3,nrow = 3, ncol = 3)
det(m2) # определитель матрицы
## [1] -21
```

Матрицы также можно перемножать с помощью специального оператора `%*%`:

```r
m2 %*% m
##      [,1] [,2] [,3] [,4]
## [1,]   24   24   24   24
## [2,]  -24  -28  -32  -36
## [3,]   -9  -10  -11  -12
```

---

# Матрицы

## Поиск элемента

Для поиска индексов требуемого элемента необходимо использовать функцию `which()`. Если мы хотим найти в матрице m позицию числа `\(8\)`, то вызов функции будет выглядеть так:

```r
indexes = which(m == 8, arr.ind = TRUE)
row = indexes[1,1]
col = indexes[1,2]
m[row,col]
## [1] 8
```

---

# Матрицы

## Сборка из векторов

Для этого можно использовать функции `cbind()` и `rbind()`:

```r
lengths = c(28, 40, 45, 19, 38)
stations = c(20, 21, 22, 12, 24)
cbind(lengths, stations)  # соединим вектора в качестве столбцов
##      lengths stations
## [1,]      28       20
## [2,]      40       21
## [3,]      45       22
## [4,]      19       12
## [5,]      38       24
rbind(lengths, stations)  # соединим вектора в качестве строк
##          [,1] [,2] [,3] [,4] [,5]
## lengths    28   40   45   19   38
## stations   20   21   22   12   24
```

---

# Матрицы

## Сборка из векторов

Cтроки и столбцы матрицы можно использовать как векторы при выполнении арифметических операций:

```r
mm = cbind(lengths, stations)
mm[,2]/mm[,1]  # количество станций на 1 км пути
## [1] 0.7142857 0.5250000 0.4888889 0.6315789 0.6315789
```

Результат можно присоединить к уже созданной матрице:

```r
dens = mm[,2]/mm[,1]
mm = cbind(mm, dens)
mm
##      lengths stations      dens
## [1,]      28       20 0.7142857
## [2,]      40       21 0.5250000
## [3,]      45       22 0.4888889
## [4,]      19       12 0.6315789
## [5,]      38       24 0.6315789
```

---

# Массивы

__Массивы (arrays)__ --- это многомерные структуры данных, с колчеством измерений 3 и более. Трехмерный массив представляет собой куб однородных данных. Для создания массива используется функция `array()`:

```r
z = array(1:36, c(3,4,2)) # вектор значений для заполнения массива, а также длина каждого измерения
print(z)
## , , 1
## 
##      [,1] [,2] [,3] [,4]
## [1,]    1    4    7   10
## [2,]    2    5    8   11
## [3,]    3    6    9   12
## 
## , , 2
## 
##      [,1] [,2] [,3] [,4]
## [1,]   13   16   19   22
## [2,]   14   17   20   23
## [3,]   15   18   21   24
```

---

# Фреймы данных

__Фреймы данных__ — это обобщение понятия матрицы на данные смешанных типов. Фреймы данных - наиболее распространенный формат представления табличных данных.

Для создания фреймов данных используется функция `data.frame()`:

```r
(df = data.frame(colors,lengths,stations)) # как мы видим, уже никаких кавычек вокруг чисел
##       colors lengths stations
## 1    Красная      28       20
## 2    Зеленая      40       21
## 3      Синяя      45       22
## 4 Коричневая      19       12
## 5  Оранжевая      38       24
```

К фреймам также можно пристыковывать новые столбцы:

```r
(df = cbind(df, dens))
##       colors lengths stations      dens
## 1    Красная      28       20 0.7142857
## 2    Зеленая      40       21 0.5250000
## 3      Синяя      45       22 0.4888889
## 4 Коричневая      19       12 0.6315789
## 5  Оранжевая      38       24 0.6315789
```

---

# Фреймы данных

## Извлечение элементов

Как и прежде, к столбцам и строкам можно обращаться по индексам:

```r
df[2,2]
## [1] 40
df[,3]
## [1] 20 21 22 12 24
df[4,]
##       colors lengths stations      dens
## 4 Коричневая      19       12 0.6315789
```

Вы можете обращаться к отдельным столбцам фрейма данных по их названию, используя оператор `$` (доллар):

```r
df$lengths
## [1] 28 40 45 19 38
df$stations
## [1] 20 21 22 12 24
```

---

# Фреймы данных

## Работа со столбцами

Так же как и ранее, можно выполнять различные операции над столбцами:

```r
max(df$stations)
## [1] 24
df$lengths / df$stations
## [1] 1.400000 1.904762 2.045455 1.583333 1.583333
```

Названия столбцов можно получить с помощью функции `colnames()`

```r
colnames(df)
## [1] "colors"   "lengths"  "stations" "dens"
```

---

# Фреймы данных

## Присоединение строк

Чтобы присоединить строку, сначала можно создать фрейм данных из одной строки и перенести в него названия столбцов:

```r
row = data.frame("Фиолетовая", 40.5, 22, 22/45)
colnames(row) = colnames(df)
```

После того как столбцы приведены в соответствие, можно присоединить новую строку:

```r
(df = rbind(df,row))
##       colors lengths stations      dens
## 1    Красная    28.0       20 0.7142857
## 2    Зеленая    40.0       21 0.5250000
## 3      Синяя    45.0       22 0.4888889
## 4 Коричневая    19.0       12 0.6315789
## 5  Оранжевая    38.0       24 0.6315789
## 6 Фиолетовая    40.5       22 0.4888889
```

---

# Фреймы данных

## Сортировка

Чтобы _отсортировать_ фрейм данных по значению определенного поля, необходимо узнать порядок элементов в этом поле с помощью функции `order()` и проиндексировать им первое измерение фрейма:

```r
df[order(df$lengths), ]
##       colors lengths stations      dens
## 4 Коричневая    19.0       12 0.6315789
## 1    Красная    28.0       20 0.7142857
## 5  Оранжевая    38.0       24 0.6315789
## 2    Зеленая    40.0       21 0.5250000
## 6 Фиолетовая    40.5       22 0.4888889
## 3      Синяя    45.0       22 0.4888889
```

---

# Фреймы данных

## Фильтрация

Чтобы _отфильтровать_ фрейм данных по значению определенного поля, необходимо передать условие в первое измерение фрейма:

```r
df[df$lengths &gt; 25, ]
##       colors lengths stations      dens
## 1    Красная    28.0       20 0.7142857
## 2    Зеленая    40.0       21 0.5250000
## 3      Синяя    45.0       22 0.4888889
## 5  Оранжевая    38.0       24 0.6315789
## 6 Фиолетовая    40.5       22 0.4888889
```

---

# Фреймы данных

## Описательные статистики

К фреймам данных, так же как и к однородным структурам, можно применять функцию `summary()` для получения описательных статистик. При этом отчет формируется по каждому столбцу:

```r
summary(df)
##         colors     lengths         stations          dens       
##  Зеленая   :1   Min.   :19.00   Min.   :12.00   Min.   :0.4889  
##  Коричневая:1   1st Qu.:30.50   1st Qu.:20.25   1st Qu.:0.4979  
##  Красная   :1   Median :39.00   Median :21.50   Median :0.5783  
##  Оранжевая :1   Mean   :35.08   Mean   :20.17   Mean   :0.5800  
##  Синяя     :1   3rd Qu.:40.38   3rd Qu.:22.00   3rd Qu.:0.6316  
##  Фиолетовая:1   Max.   :45.00   Max.   :24.00   Max.   :0.7143
```

---

# Списки

__Список__ — это наиболее общий тип контейнера в R. Список отличается от вектора тем, что он может содержать набор объектов произвольного типа.

```r
d = "Этот фрейм данных содержит данные по 6 линиям Московского метро"
s = summary(df)  # summary() выдает обобщающую статистику вектору, матрице или фрейму данных
```

Сооружаем список из трех элементов:

```r
metrolist = list(d, df, s)
metrolist
## [[1]]
## [1] "Этот фрейм данных содержит данные по 6 линиям Московского метро"
## 
## [[2]]
##       colors lengths stations      dens
## 1    Красная    28.0       20 0.7142857
## 2    Зеленая    40.0       21 0.5250000
## 3      Синяя    45.0       22 0.4888889
## 4 Коричневая    19.0       12 0.6315789
## 5  Оранжевая    38.0       24 0.6315789
## 6 Фиолетовая    40.5       22 0.4888889
## 
## [[3]]
##         colors     lengths         stations          dens       
##  Зеленая   :1   Min.   :19.00   Min.   :12.00   Min.   :0.4889  
##  Коричневая:1   1st Qu.:30.50   1st Qu.:20.25   1st Qu.:0.4979  
##  Красная   :1   Median :39.00   Median :21.50   Median :0.5783  
##  Оранжевая :1   Mean   :35.08   Mean   :20.17   Mean   :0.5800  
##  Синяя     :1   3rd Qu.:40.38   3rd Qu.:22.00   3rd Qu.:0.6316  
##  Фиолетовая:1   Max.   :45.00   Max.   :24.00   Max.   :0.7143
```

---

# Списки

Можно дать элементам списка осмысленные названия при создании:

```r
metrolist = list(desc = d, table = df, summary = s)
metrolist
## $desc
## [1] "Этот фрейм данных содержит данные по 6 линиям Московского метро"
## 
## $table
##       colors lengths stations      dens
## 1    Красная    28.0       20 0.7142857
## 2    Зеленая    40.0       21 0.5250000
## 3      Синяя    45.0       22 0.4888889
## 4 Коричневая    19.0       12 0.6315789
## 5  Оранжевая    38.0       24 0.6315789
## 6 Фиолетовая    40.5       22 0.4888889
## 
## $summary
##         colors     lengths         stations          dens       
##  Зеленая   :1   Min.   :19.00   Min.   :12.00   Min.   :0.4889  
##  Коричневая:1   1st Qu.:30.50   1st Qu.:20.25   1st Qu.:0.4979  
##  Красная   :1   Median :39.00   Median :21.50   Median :0.5783  
##  Оранжевая :1   Mean   :35.08   Mean   :20.17   Mean   :0.5800  
##  Синяя     :1   3rd Qu.:40.38   3rd Qu.:22.00   3rd Qu.:0.6316  
##  Фиолетовая:1   Max.   :45.00   Max.   :24.00   Max.   :0.7143
```

---

# Списки

## Извлечение элементов

Можно обратиться к элементу списка по его названию:

```r
metrolist$summary
##         colors     lengths         stations          dens       
##  Зеленая   :1   Min.   :19.00   Min.   :12.00   Min.   :0.4889  
##  Коричневая:1   1st Qu.:30.50   1st Qu.:20.25   1st Qu.:0.4979  
##  Красная   :1   Median :39.00   Median :21.50   Median :0.5783  
##  Оранжевая :1   Mean   :35.08   Mean   :20.17   Mean   :0.5800  
##  Синяя     :1   3rd Qu.:40.38   3rd Qu.:22.00   3rd Qu.:0.6316  
##  Фиолетовая:1   Max.   :45.00   Max.   :24.00   Max.   :0.7143
```

К элементу списка можно также обратиться по его порядковому номеру или названию, заключив их в _двойные_ квадратные скобки:

```r
metrolist[[1]]
## [1] "Этот фрейм данных содержит данные по 6 линиям Московского метро"
metrolist[["desc"]]
## [1] "Этот фрейм данных содержит данные по 6 линиям Московского метро"
```

---

# Списки

## Описательные статистики

Вызов функции `summary()` в приложении к списку выведет статистику по типам и количеству элементов списка:

```r
summary(metrolist)
##         Length Class      Mode     
## desc     1     -none-     character
## table    4     data.frame list     
## summary 24     table      character
```

---

# Факторы

Понятие __фактора__ в терминологии __R__ используется для обозначения категориальной (качественной) переменной. Например, каждая линия Московского метро имеет свой номер. Создадим небольшей фрейм данных с электродепо по интересующим нас веткам метро и рассчитаем по ним описательные статистики:

```r
depots = data.frame(
  depot = c('Северное', 'Черкизово', 'Сокол', 'Замоскворецкое', 
            'Братеево', 'Измайлово', 'Фили', 'Митино', 
            'Красная Пресня', 'Калужское', 'Свиблово'),
  year_opened = c(1935, 1990, 1938, 1969, 
                  2014, 1950, 1962, 2016,
                  1954, 1962, 1978),
  line_number = c(1, 1, 2, 2, 2, 3, 3, 3, 5, 6, 6)
)
```

---

# Факторы


```r
summary(depots)
##             depot    year_opened    line_number   
##  Братеево      :1   Min.   :1935   Min.   :1.000  
##  Замоскворецкое:1   1st Qu.:1952   1st Qu.:2.000  
##  Измайлово     :1   Median :1962   Median :3.000  
##  Калужское     :1   Mean   :1970   Mean   :3.091  
##  Красная Пресня:1   3rd Qu.:1984   3rd Qu.:4.000  
##  Митино        :1   Max.   :2016   Max.   :6.000  
##  (Other)       :5
```

Как видно, __R__ посчитал нам средний номер линии метро - 3.091. Чтобы этого не происходило, укажем в явном виде с помощью функции `factor()`, что номер линии метров является номинальной переменной:

```r
depots$line_number = as.factor(depots$line_number)
print(depots$line_number)
##  [1] 1 1 2 2 2 3 3 3 5 6 6
## Levels: 1 2 3 5 6
```

---

# Факторы

Попробуем теперь посчитать описательные статистики по переменной и таблице в целом:

```r
mean(depots$line_number)
## [1] NA
summary(depots)
##             depot    year_opened   line_number
##  Братеево      :1   Min.   :1935   1:2        
##  Замоскворецкое:1   1st Qu.:1952   2:3        
##  Измайлово     :1   Median :1962   3:3        
##  Калужское     :1   Mean   :1970   5:1        
##  Красная Пресня:1   3rd Qu.:1984   6:2        
##  Митино        :1   Max.   :2016              
##  (Other)       :5
```

Теперь мы видим, что вместо стандартных статистик __R__ для переменной *line_number* выдает таблицу частот, из которой ясно, что на первой линии два депо, на второй линии три депо и так далее.

---

# Описание структуры данных

Для описания структуры данных можно использовать две широко используемые диагностические функции: `class()` выведет тип структуры, а `str()` выведет детальную выписку по компонентам этой структуры:

```r
class(depots) # тип объекта
## [1] "data.frame"
str(depots) # структура объекта
## 'data.frame':	11 obs. of  3 variables:
##  $ depot      : Factor w/ 11 levels "Братеево","Замоскворецкое",..: 8 11 9 2 1 3 10 6 5 4 ...
##  $ year_opened: num  1935 1990 1938 1969 2014 ...
##  $ line_number: Factor w/ 5 levels "1","2","3","5",..: 1 1 2 2 2 3 3 3 4 5 ...
```

---

# Циклы

__Цикл__ --- это разновидность управляющей конструкции, предназначенная для организации многократного исполнения набора инструкций. В __R__ циклы наиболее часто используются для пакетной обработки данных, ввода и вывода.

Первый вид циклов — это конструкция __for__ с синтаксисом `for (x in X) statement`:

- переменная `x` должна пробежать по всем элементам последовательности `X`. В качестве последовательности может выступать любой вектор или список.
- каждый раз, когда `x` будет присвоено значение очередного элемента из `X`, будет выполнено выражение `statement`, которое называют _телом цикла_. Соответственно, цикл выполнится столько раз, сколько элементов содержится в последовательности `X`. 

&gt; Выполнение тела цикла на каждом проходе называют _итерацией_.

---

# Циклы

## for

Например, с помощью цикла можно вывести на экран числа от 1 до 10, по одному с каждой строки:

```r
## ЦИКЛЫ
for (i in 1:10) print(i)
## [1] 1
## [1] 2
## [1] 3
## [1] 4
## [1] 5
## [1] 6
## [1] 7
## [1] 8
## [1] 9
## [1] 10
```

---

# Циклы

## for

Если тело цикла содержит более одной инструкции R, оно должно быть заключено в фигурные скобки:

```r
for (i in 1:10) {
  a = factorial(i) # факториал i
  b = exp(i) # e в степени i
  print(a/b) # факториал растет быстрее экспоненты
}
## [1] 0.3678794
## [1] 0.2706706
## [1] 0.2987224
## [1] 0.4395753
## [1] 0.8085536
## [1] 1.784702
## [1] 4.595885
## [1] 13.52585
## [1] 44.78295
## [1] 164.7473
```

---

# Циклы

## while

Другой вариант цикла организуется с помощью конструкции `while`, имеющей синтаксис `while (condition) statement`:

```r
i = 0
while(i &lt; 5) {
  i = i+1
  print(i)
}
## [1] 1
## [1] 2
## [1] 3
## [1] 4
## [1] 5
```
Обратите внимание на то, что мы внутри цикла обновляем значение переменной i.

&gt; Увеличение значения переменной цикла называется _инкрементом_, а уменьшение --- _декрементом_.

---

# Циклы

Пример --- вычисление медианного значения для каждого столбца таблицы линий метро:

```r
n = ncol(df)
medians = vector('numeric', n)

for (i in 1:n) {
  if(is.numeric(df[, i])){
    medians[i] = median(df[, i])
  } else {
    medians[i] = NA
  }
}
colnames(df) # Переменные
## [1] "colors"   "lengths"  "stations" "dens"
medians # Медианные значения
## [1]         NA 39.0000000 21.5000000  0.5782895
```

---

# Циклы

## Прерывание

- `break` прерывает цикл
- `next` прерывает текущую итерацию цикла

Например, мы можем выводить информацию об электродепо, имеющихся на линии метро с введенным пользователем номером, до тех пор, пока он не введет символ `q`. Чтобы цикл был бесконечным, используем специальную форму `while (TRUE)`:

```r
while (TRUE) {
  cat('Введите номер ветки метро:')
  input = readline()
  if (input == 'q')
    break
  else {
    n = as.numeric(input)
    if (!is.na(n))
      depots[depots$line_number == n, ]
  }
}
```

---

# Циклы

Оператор `next` используется реже, он взаимозаменяем с конструкцией `if-else`:


```r
while (...) {
  if (condition1)
    next
  ... # сюда попадем, только если condition1 == FALSE
  
  if (condition2)
    next
  ... # сюда попадем, только если condition2 == FALSE
}
```

или:

```r
while (...) {
  if (!condition1) {
    ... # сюда попадем, только если condition1 == FALSE
    
    if (!condition2) {
      ... # сюда попадем, только если condition2 == FALSE
    }
  }
}
```
    </textarea>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create();
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function() {
  var d = document, s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})();</script>

<script>
(function() {
  var i, text, code, codes = document.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
})();
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
