<!DOCTYPE html>
<html>
  <head>
    <title>Таблицы</title>
    <meta charset="utf-8">
    <meta name="author" content="Тимофей Самсонов" />
    <meta name="date" content="2018-09-18" />
    <link href="03-Tables_slides_files/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="03-Tables_slides_files/remark-css-0.0.1/metropolis.css" rel="stylesheet" />
    <link href="03-Tables_slides_files/remark-css-0.0.1/metropolis-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Таблицы
## Визуализация и анализ географических данных на языке R
### Тимофей Самсонов
### 2018-09-18

---




# Предварительные требования

Для работы по теме текущей лекции вам понадобятся пакеты из __tidyverse__, а также __writexl__. Установите их, используя следующую команду:

```r
install.packages('tidyverse')
install.packages('writexl')
```

&gt; Внимание: установка пакетов выполняется один раз из консоли. Вызов функции `install.packages()` не должен присутствовать в ваших скриптах

---

# Tidyverse

Пакет       | Назначение
------------|-----------
__tibble__  | Усовершенствованный вариант фрейма данных
__dplyr__   | Грамматика манипуляций над табличными данными
__tidyr__   | Приведение таблиц в аккуратный вид, удобный для обработки
__readr__   | Чтение табличных данных из текстовых файлов
__readxl__  | Чтение табличных данных из файлов Microsoft Excel
__haven__   | Чтение табличных данных из файлов SPSS, Stata и SAS
__purrr__   | Функциональное программирование
__stringr__ | Работа со строками
__forcats__ | Автоматизация работы с факторами
__ggplot2__ | Построение графиков на основе правил грамматики 

Вы можете подключать эти пакеты по одному, или сделать их все доступными в текущей сессии __R__, используя команду `library(tidyverse)`. 

---

# Вызов функций без подключения пакета

__Вы можете вызвать функцию из любого пакета, не подключая его целиком в текущую сессию R.__ 

В этом случае вызов функции будет выглядеть как `package::function()`, где `package` -- название пакета, а `function` - название функции. 

&gt; Подобный синтаксис бывает особенно удобным, когда _в разных пакетах имеются функции с одинаковым именем_, и при вызове R использует не ту, которая нужна (по умолчанию будет использована функция из пакета, который был подключен _позже_).

---

# Тибблы и фреймы данных

В современных пакетах типа __tidyverse__ используется разновидность фрейма данных, которая называется __тиббл__ (`tibble`). Создать тиббл можно напрямую, либо путем конвертации фрейма данных:

```r
library(tibble)
tibble(
  a = 1:3, 
  b = 1, 
  c = -1:1
)
## # A tibble: 3 x 3
##       a     b     c
##   &lt;int&gt; &lt;dbl&gt; &lt;int&gt;
## 1     1     1    -1
## 2     2     1     0
## 3     3     1     1
dfr = data.frame(a = 1:3, b = 1,  c = -1:1)
as_tibble(dfr)
## # A tibble: 3 x 3
##       a     b     c
##   &lt;int&gt; &lt;dbl&gt; &lt;int&gt;
## 1     1     1    -1
## 2     2     1     0
## 3     3     1     1
```

---

# Тибблы и фреймы данных

Тибблы можно создавать вручную не только по столбцам, но и по строкам, используя функцию `tribble()` (переводится как _transposed tibble_ --- транспонированный тиббл), указав имена столбцов с помощью тильды (`~`):

```r
tribble(
  ~a, ~b, ~c,
   1,  1, -1,
   2,  1,  0,
   3,  1,  1
)
## # A tibble: 3 x 3
##       a     b     c
##   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1     1     1    -1
## 2     2     1     0
## 3     3     1     1
```

&gt; В данной и последующих лекциях понятия мы будем использовать понятия таблица, фрейм данных и тиббл как взаимозаменяемые.

---

# Чтение

## Встроенные данные

Пакеты R часто содержат тестовые наборы данных. Эти данные, как правило, предназначены для ознакомления с возможностями пакета. 

Чтобы узнать, какие данные есть в пакете, вы можете вызвать функцию `data(package = 'packagename')`, где `packagename` --- это имя интересующего вас пакета. 

Например, посмотрим, какие данные есть в пакете `dplyr`, который мы далее будем использовать для манипуляций с таблицами:

```r
data(package = 'dplyr')
```
![_Данные, доступные в пакете dplyr_](images/data_dplyr.png)

---

# Встроенные данные

Для загрузки набора данных передайте его название в качестве первого параметра функции `data()`. Ну-ка, что там с персонажами из _Star Wars_:

```r
data(starwars, package = 'dplyr')
starwars
## # A tibble: 87 x 13
##    name  height  mass hair_color skin_color eye_color birth_year gender
##    &lt;chr&gt;  &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; 
##  1 Luke…    172    77 blond      fair       blue            19   male  
##  2 C-3PO    167    75 &lt;NA&gt;       gold       yellow         112   &lt;NA&gt;  
##  3 R2-D2     96    32 &lt;NA&gt;       white, bl… red             33   &lt;NA&gt;  
##  4 Dart…    202   136 none       white      yellow          41.9 male  
##  5 Leia…    150    49 brown      light      brown           19   female
##  6 Owen…    178   120 brown, gr… light      blue            52   male  
##  7 Beru…    165    75 brown      light      blue            47   female
##  8 R5-D4     97    32 &lt;NA&gt;       white, red red             NA   &lt;NA&gt;  
##  9 Bigg…    183    84 black      light      brown           24   male  
## 10 Obi-…    182    77 auburn, w… fair       blue-gray       57   male  
## # ... with 77 more rows, and 5 more variables: homeworld &lt;chr&gt;,
## #   species &lt;chr&gt;, films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt;
```

---

# Файлы с разделителем

__CSV (Comma-separated value)__ --- общее название для формата представления таблиц в виде текстовых файлов, организованных по следующему принципу:

1. Каждая строка в файле соответствует строке в таблице.
2. Ячейки отделяются друг от друга символом-разделителем.
3. Если ячейка пустая, то между соседними разделителями не должно быть никаких символов.

Стандартным разделителем ячеек является запятая (`,`), а десятичным разделителем --- точка (`.`). Однако это не является строгим правилом. Например, в ряде локалей (например, русской) запятая используется в качестве десятичного разделителя, поэтому колонки часто разделяют точкой с запятой (`;`).

Формат CSV никак не оговаривает наличие заголовочной строки с названиями столбцов в начале файла — она может как отсутствовать, так и присутствовать. Поэтому при чтении таблиц из файлов необходимо информировать программу о наличии заголовка путем указания соответствующего параметра.

---

# Файлы с разделителем

Например, вот так выглядит текстовая таблица в формате CSV с данными по численности населения в Федеральных округах Российской Федерации за 2005 и 2010-2013 гг. (по данным Росстата):
```
N,Region,Year05,Year10,Year11,Year12,Year13
1,Центральный,4341,3761,3613,3651,3570
2,Северо-Западный,3192,3088,2866,2877,2796
3,Южный федеральный,1409,1446,1436,1394,1321
4,Северо-Кавказский,496,390,397,395,374
5,Приволжский,3162,2883,2857,2854,2849
6,Уральский,1681,1860,1834,1665,1624
7,Сибирский,2575,2218,2142,2077,1941
8,Дальневосточный,871,870,821,765,713
```

---

# Файлы с разделителем

Таблицы в формате __CSV__ можно прочесть как с помощью стандартных средств языка R, так и с помощью пакета `readr`, который входит в набор пакетов _tidyverse_.

Для чтения таблиц с разделителем в readr имеется несколько функций:

- `read_csv()` читает файлы с разделителем запятой
- `read_csv2()` читайт файлы с разделителем точкой-с-запятой (может быть особенно актуально для русских файлов)
- `read_tsv()` читает файлы с разделителем табуляцией или пробелом
- `read_delim()` читает файлы с произвольным разделителем (указывается в качестве параметра)

---

# Файлы с разделителем


```r
library(readr)
(okruga = read_csv('data/okruga.csv'))
## Parsed with column specification:
## cols(
##   `№` = col_integer(),
##   Регион = col_character(),
##   `2005` = col_integer(),
##   `2010` = col_integer(),
##   `2011` = col_integer(),
##   `2012` = col_integer(),
##   `2013` = col_integer()
## )
## # A tibble: 8 x 7
##     `№` Регион            `2005` `2010` `2011` `2012` `2013`
##   &lt;int&gt; &lt;chr&gt;              &lt;int&gt;  &lt;int&gt;  &lt;int&gt;  &lt;int&gt;  &lt;int&gt;
## 1     1 Центральный         4341   3761   3613   3651   3570
## 2     2 Северо-Западный     3192   3088   2866   2877   2796
## 3     3 Южный федеральный   1409   1446   1436   1394   1321
## 4     4 Северо-Кавказский    496    390    397    395    374
## 5     5 Приволжский         3162   2883   2857   2854   2849
## 6     6 Уральский           1681   1860   1834   1665   1624
## 7     7 Сибирский           2575   2218   2142   2077   1941
## 8     8 Дальневосточный      871    870    821    765    713
```

---

# Файлы с фиксированной шириной столбца

```
           1   43.500000       28.000000       111.05298       178.41447    
           2   43.500000       28.500000       187.38620       301.05331    
           3   44.000000       28.500000       168.82031       271.22421    
           4   44.500000       28.500000       157.22586       252.59746    
           5   44.500000       29.000000       189.46452       304.39597    
           6   45.000000       29.000000       170.40709       273.77536    
           7   45.000000       29.500000       198.92389       319.58777    
           8   45.500000       29.500000       188.64406       303.07242    
           9   46.000000       30.000000       180.10541       289.35379    
          10   46.000000       30.500000       207.91818       334.03564
```

Для чтения таких файлов в __readr__ есть функции:

- `read_fwf()` читает файлы с фиксированной шириной столбца, позволяя задавать ширины столбцов (через `fwf_widths()`) или начальные позиции каждого столбца (через `fwf_positions()`)
- `read_table()` читает наиболее распространенный вариант файла с фиксированной шириной столбца, в котором колонки разделены пробелами. Позиции столбцов определяются автоматически, что очень удобно.

---

# Файлы с фиксированной шириной столбца


```r
(wenergy = read_table('data/wind_energy.txt', col_names = c('id', 'lat', 'lon', 'energy50', 'energy110')))
## Parsed with column specification:
## cols(
##   id = col_integer(),
##   lat = col_double(),
##   lon = col_double(),
##   energy50 = col_double(),
##   energy110 = col_double()
## )
## # A tibble: 92 x 5
##       id   lat   lon energy50 energy110
##    &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;
##  1     1  43.5  28       111.      178.
##  2     2  43.5  28.5     187.      301.
##  3     3  44    28.5     169.      271.
##  4     4  44.5  28.5     157.      253.
##  5     5  44.5  29       189.      304.
##  6     6  45    29       170.      274.
##  7     7  45    29.5     199.      320.
##  8     8  45.5  29.5     189.      303.
##  9     9  46    30       180.      289.
## 10    10  46    30.5     208.      334.
## # ... with 82 more rows
```

---

# Таблицы Microsoft Excel

Можно рекомендовать пользоваться пакетом __readxl__, поскольку он не имеет внешних зависимостей, а его функции концептуально идентичны функциям пакета __readr__. 

Прочтем данные о лесовосстановлении (в тысяч га), полученные из регионального ежегодника Росстата за 2017 год:

```r
library(readxl)
(reforest = read_excel('data/reforest.xlsx', 
                       col_types = c('text', rep('numeric', 8))))
## # A tibble: 89 x 9
##    Region          `2005` `2010` `2011` `2012` `2013` `2014` `2015` `2016`
##    &lt;chr&gt;            &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;
##  1 Российская Фед…  812.   812.   860    842.   872.   863    803.   840. 
##  2 Центральный фе…   52.6   62.7   60.9   60.3   70.9   71.2   72.6   77  
##  3 Белгородская о…    0.4    0.1    0.3    0.3    0.4    0.4    0.2    0.2
##  4 Брянская облас…    2.9    2.8    3      3.2    3.5    3.3    3.1    3  
##  5 Владимирская о…    4.4    5.3    5.7    6      7.1    5.9    6      4.9
##  6 Воронежская об…    1.1    1.1    1.8    3      2.7    2.7    2.6    2.3
##  7 Ивановская обл…    2.1    1.6    2.2    3.1    4      4.8    4.6    4.2
##  8 Калужская обла…    2.2    2.3    2.3    2.5    2.4    3.1    3.2    3.2
##  9 Костромская об…   10     25.2   11     11.8   15.3   13.6   15.1   16.4
## 10 Курская область    0.5    0.3    0.4    0.6    0.6    0.6    0.5    0.4
## # ... with 79 more rows
```

---

# Параметры

Функции пакетов `readr` и `readxl` имеют идентичный набор параметров, позволяющих управлять процедурой чтения данных (многоточие используется вместо перечисления параметров):

- `skip = n` позволяет пропустить первые n строк таблицы (например, если в них содержатся какие-то комментарии)
- `col_names = FALSE` позволяет не интерпретировать первую строку как заголовочную (вместо этого она будет читаться как строка с данными)
- `col_names = c(...)` позволяет задать имена столбцов (удобно, если в файле они длинные)
- `col_types = cols(...)` позволяет задать типы столбцов (необходимо, если функция неправильно определяет их сама)
- `na = '-'` позволяет указать символ, который используется для указания пропущенных значений (в данном случае указан прочерк-дефис)
- `locale = locale(...)` управляет локалью (в том числе позволяет указать кодировку файла)

&gt; По умолчанию файлы читаются в той кодировке, которая соответствует операционной системе, на которой запущен R.

---

# Просмотр

Для просмотра фрейма данных в консоли __RStudio__ вы можете использовать несколько опций. Пусть наш фрейм данных называется `reforest`. Тогда:

1. `print(reforest)` --- выводит фрейм в консоль целиком (можно написать просто `tab` в консоли).
2. `head(reforest, n)` --- отбирает первые `\(n\)` строк фрейма 
3. `tail(reforest, n)` --- отбирает последние `\(n\)` строк фрейма

По умолчанию для функций `head()` и `tail()` `\(n=6\)`. Обычно этот параметр опускают, поскольку нужно просмотреть только первые несколько строк и шести вполне достаточно. Если вы напечатаете в консоли `head(reforest)` или `tail(reforest)`, то для выбранных строк будет вызвана функция `print()`, аналогично выводу всего фрейма.

---

# Просмотр


```r
head(reforest)
## # A tibble: 6 x 9
##   Region           `2005` `2010` `2011` `2012` `2013` `2014` `2015` `2016`
##   &lt;chr&gt;             &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;
## 1 Российская Феде…  812.   812.   860    842.   872.   863    803.   840. 
## 2 Центральный фед…   52.6   62.7   60.9   60.3   70.9   71.2   72.6   77  
## 3 Белгородская об…    0.4    0.1    0.3    0.3    0.4    0.4    0.2    0.2
## 4 Брянская область    2.9    2.8    3      3.2    3.5    3.3    3.1    3  
## 5 Владимирская об…    4.4    5.3    5.7    6      7.1    5.9    6      4.9
## 6 Воронежская обл…    1.1    1.1    1.8    3      2.7    2.7    2.6    2.3
tail(reforest)
## # A tibble: 6 x 9
##   Region           `2005` `2010` `2011` `2012` `2013` `2014` `2015` `2016`
##   &lt;chr&gt;             &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;
## 1 Хабаровский край  107.    70.2   68.7   67.2   58.4   50.5   59.6   60.3
## 2 Амурская область   33.3   29.8   32.2   33.6   35.5   37.7   28.5   27.7
## 3 Магаданская обл…    2.7    2.6    2.6    2.8    3      2.5    0.4   NA  
## 4 Сахалинская обл…   13.1   12.7   12.5    4.6    4.7    4.9    4.7    4.1
## 5 Еврейская автон…    2.9   NA      2.6    2.5    2.3   NA     NA      2.4
## 6 Чукотский автон…    0.3   NA     NA     NA     NA     NA     NA     NA
```

---

# Функция __View()__

`RStudio` предоставляет графический интерфейс для просмотра таблиц, в котором таблицу можно сортировать и фильтровать:

```r
View(tab)
```

Поскольку функции `head()` и `tail()` возвращают строки с хвоста или начала фрейма данных, их можно и подать на вход функции `View()`:


```r
View(head(reforest, 3))
```

&gt; __Как правило, не следует оставлять вызовы функции `View()` в тексте законченной программы.__ Используйте `View()` для вывода окончательного результата в конце программы или при отладке программы.

---

# Названия

Столбцы и строки таблицы имеют названия, которые можно читать и записывать с помощью функций `colnames()` и `rownames()`:

```r
# Чтение названий столбцов и строк
colnames(okruga)
## [1] "№"      "Регион" "2005"   "2010"   "2011"   "2012"   "2013"
rownames(okruga)
## [1] "1" "2" "3" "4" "5" "6" "7" "8"

# Замена названий столбцов и строк
colnames(okruga) &lt;- c("N", "Region", "Year05", "Year10", "Year11", "Year12", "Year13")
print(okruga)
## # A tibble: 8 x 7
##       N Region            Year05 Year10 Year11 Year12 Year13
##   &lt;int&gt; &lt;chr&gt;              &lt;int&gt;  &lt;int&gt;  &lt;int&gt;  &lt;int&gt;  &lt;int&gt;
## 1     1 Центральный         4341   3761   3613   3651   3570
## 2     2 Северо-Западный     3192   3088   2866   2877   2796
## 3     3 Южный федеральный   1409   1446   1436   1394   1321
## 4     4 Северо-Кавказский    496    390    397    395    374
## 5     5 Приволжский         3162   2883   2857   2854   2849
## 6     6 Уральский           1681   1860   1834   1665   1624
## 7     7 Сибирский           2575   2218   2142   2077   1941
## 8     8 Дальневосточный      871    870    821    765    713
```

Названия строк редко заменяются, поскольку с точки зрения реляционной алгебры большого смысла они не имеют.

---

# Обращение к столбцам

Тип возвращаемого значения зависит от синтаксиса:

- обращение через `$` возвращает вектор;
- обращение в скобках с запятой к одному столбцу возвращает вектор;
- обращение в скобках с запятой к нескольким столбцам возвращает фрейм данных;
- обращение в скобках без запятой возвращает фрейм данных.

Несколько примеров:

```r
# Один столбец - результат зависит от запятой
okruga$Year05      # столбец в виде вектора
okruga[, "Year05"] # столбец в виде вектора
okruga[, 2]        # столбец в виде вектора

okruga["Year05"] # столбец в виде фрейма данных/тиббла
okruga[2]        # столбец в виде фрейма данных/тиббла

# Несколько столбцов - всегда фрейм данных/тиббл
okruga[, c(1, 4)]
okruga[, c("Region", "Year11")]
okruga[c("Region", "Year11")]
okruga[c(1, 4)]
```

---

# Обращение к строкам

Обращаться к строкам можно по их номерам. В этом случае в качестве индекса можно передать номер (номера) интересующих строк, либо вектор логических значений, в котором интересующие строки помечены как TRUE, а остальные — FALSE (в этом случае длина вектора должна равняться количеству строк в таблице):

```r
okruga[5, ] # Одна строка
okruga[2:4, ] # Несколько строк
okruga[okruga$Year10 &gt; 2000, ] # Несколько строк через TRUE/FALSE
```
&gt; В отличие от работы со столбцами, выбор строк всегда возвращает таблицу (фрейм или тиббл).

---

# Обращение к ячейкам

Чтобы выбрать конкретные ячейки в таблице, необходимо задать оба измерения:

```r
okruga[2:3, c("Year11", "Year12")]
## # A tibble: 2 x 2
##   Year11 Year12
##    &lt;int&gt;  &lt;int&gt;
## 1   2866   2877
## 2   1436   1394
```

Обратите внимание на то, что при этом возвращаются все комбинации строк и столбцов. То есть, нельзя выбрать ячейки `2,"Year11"` и `3,"Year2"` --- вместе с ними также будут выбраны ячейки `3,"Year11"` и `2,"Year2"`.

---

# Грамматика манипуляций

К основным манипуляциям относятся _выбор переменных, фильтрация строк, сортировка, вычисление новых столбцов, агрегирующие статистики и группировка_. 

Эти средства предоставляет пакет [__dplyr__](https://dplyr.tidyverse.org) (произносится как _deep liar_ — 'диплáйер'), входящий в набор инструментов [tidyverse](https://www.tidyverse.org):

Функция       | Назначение
--------------|-----------------
`select()`    | Выбор переменных
`filter()`    | Выбор строк (фильтрация)
`arrange()`   | Упорядочение строк
`mutate()`    | Добавление и изменение переменных (мутирование)
`summarise()` | Агрегирование значений переменных
`group_by()`  | Группировка строк (для последующего агрегирования)

&gt; Названия столбцов в функциях __dplyr__ указываются без кавычек, что позволяет сделать код проще и читаемее

---

# Грамматика манипуляций

Рассмотрим применение этих функций на примере работы с таблицей по восстановлению лесного фонда в регионах России. 

Для начала переименуем столбцы с годами, чтобы их названия начинались с буквы `y`:

```r
old_names = colnames(reforest)
colnames(reforest) = c(old_names[1], paste('y', old_names[2:9], sep = ''))
library(dplyr)
## 
## Attaching package: 'dplyr'
## The following objects are masked from 'package:stats':
## 
##     filter, lag
## The following objects are masked from 'package:base':
## 
##     intersect, setdiff, setequal, union
```

---

# Выбор переменных

Начнем с __выбора__ нужных переменных, используя `select()`. Оставим только название региона и данные за 2010 и 2015 гг:

```r
(rdf = select(reforest, Region, y2010, y2015))
## # A tibble: 89 x 3
##    Region                        y2010 y2015
##    &lt;chr&gt;                         &lt;dbl&gt; &lt;dbl&gt;
##  1 Российская Федерация          812.  803. 
##  2 Центральный федеральный округ  62.7  72.6
##  3 Белгородская область            0.1   0.2
##  4 Брянская область                2.8   3.1
##  5 Владимирская область            5.3   6  
##  6 Воронежская область             1.1   2.6
##  7 Ивановская область              1.6   4.6
##  8 Калужская область               2.3   3.2
##  9 Костромская область            25.2  15.1
## 10 Курская область                 0.3   0.5
## # ... with 79 more rows
```

---

# Выбор переменных

Ту же самую задачу можно решить от противного — указать со знаком `-` те столбцы, которые надо убрать:

```r
(rdf = select(reforest, -y2005, -y2011:-y2014, -y2016))
## # A tibble: 89 x 3
##    Region                        y2010 y2015
##    &lt;chr&gt;                         &lt;dbl&gt; &lt;dbl&gt;
##  1 Российская Федерация          812.  803. 
##  2 Центральный федеральный округ  62.7  72.6
##  3 Белгородская область            0.1   0.2
##  4 Брянская область                2.8   3.1
##  5 Владимирская область            5.3   6  
##  6 Воронежская область             1.1   2.6
##  7 Ивановская область              1.6   4.6
##  8 Калужская область               2.3   3.2
##  9 Костромская область            25.2  15.1
## 10 Курская область                 0.3   0.5
## # ... with 79 more rows
```
Обратите внимание на то, что можно указывать еще и диапазоны названий столбцов, если они идут друг за другом.

---

# Выбор строк (фильтрация)

Чтобы осуществить __фильтрацию__, необходимо задать условие, накладываемое на строки. 

Выполним фильтрацию таблицы, убрав строки, в которых содержатся слова `Федерация` и `федеральный округ`. Для этого используем функцию `str_detect()` из пакета __stringr__, который также входит в _tidyverse_:

```r
flt = !stringr::str_detect(rdf$Region, 'Федерация|федеральный округ') # готовим фильтр для строк
(regdf = filter(rdf, flt)) # применяем фильтр
## # A tibble: 80 x 3
##    Region               y2010 y2015
##    &lt;chr&gt;                &lt;dbl&gt; &lt;dbl&gt;
##  1 Белгородская область   0.1   0.2
##  2 Брянская область       2.8   3.1
##  3 Владимирская область   5.3   6  
##  4 Воронежская область    1.1   2.6
##  5 Ивановская область     1.6   4.6
##  6 Калужская область      2.3   3.2
##  7 Костромская область   25.2  15.1
##  8 Курская область        0.3   0.5
##  9 Липецкая область       0.4   1.1
## 10 Московская область     2.7   8.9
## # ... with 70 more rows
```

---

# Выбор строк (фильтрация)

Условие можно прописать непосредственно при вызове `filter()`. 

Например, выберем регионы, в которых объем лесовосстановительных работ в 2015 году был более 50 тыс. га:

```r
filter(regdf, y2015 &gt; 50)
## # A tibble: 4 x 3
##   Region                y2010 y2015
##   &lt;chr&gt;                 &lt;dbl&gt; &lt;dbl&gt;
## 1 Архангельская область  39.4  57.6
## 2 Красноярский край      49    50.4
## 3 Иркутская область      80.4 117. 
## 4 Хабаровский край       70.2  59.6
```

---

# Сортировка

Для __сортировки__ таблицы используется `arrange()`:

```r
arrange(regdf, y2015) # по возрастанию
## # A tibble: 80 x 3
##    Region                              y2010 y2015
##    &lt;chr&gt;                               &lt;dbl&gt; &lt;dbl&gt;
##  1 Орловская область                     0     0.1
##  2 Астраханская область                  0.1   0.1
##  3 Кабардино-Балкарская Республика       0.1   0.1
##  4 Карачаево-Черкесская Республика       0.2   0.1
##  5 Республика Северная Осетия – Алания  NA     0.1
##  6 Ставропольский край                   0.4   0.1
##  7 Белгородская область                  0.1   0.2
##  8 Тульская область                      0.1   0.2
##  9 Магаданская область                   2.6   0.4
## 10 Курская область                       0.3   0.5
## # ... with 70 more rows
```

---

# Сортировка

Для __сортировки__ по убыванию надо отправить соответствующую переменную в функцию `desc()`:

```r
arrange(regdf, desc(y2015)) # по убыванию
## # A tibble: 80 x 3
##    Region                y2010 y2015
##    &lt;chr&gt;                 &lt;dbl&gt; &lt;dbl&gt;
##  1 Иркутская область      80.4 117. 
##  2 Хабаровский край       70.2  59.6
##  3 Архангельская область  39.4  57.6
##  4 Красноярский край      49    50.4
##  5 Вологодская область    32.3  49  
##  6 Республика Коми        33.3  36.7
##  7 Пермский край          22.9  32.5
##  8 Кировская область      26    31.1
##  9 Амурская область       29.8  28.5
## 10 Томская область         9.3  25.6
## # ... with 70 more rows
```

---

# Добавление или изменение переменных (мутирование)

__Добавление__ новых переменных (столбцов) и изменение существующих осуществляется посредством `mutate()`. 

Например, определим, как изменился объем лесовосстановительных работ в 2015 году по сравнению с 2010 годом:

```r
(regdf = mutate(regdf, delta = y2015 - y2010))
## # A tibble: 80 x 4
##    Region               y2010 y2015  delta
##    &lt;chr&gt;                &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;
##  1 Белгородская область   0.1   0.2   0.1 
##  2 Брянская область       2.8   3.1   0.3 
##  3 Владимирская область   5.3   6     0.7 
##  4 Воронежская область    1.1   2.6   1.5 
##  5 Ивановская область     1.6   4.6   3.00
##  6 Калужская область      2.3   3.2   0.9 
##  7 Костромская область   25.2  15.1 -10.1 
##  8 Курская область        0.3   0.5   0.2 
##  9 Липецкая область       0.4   1.1   0.7 
## 10 Московская область     2.7   8.9   6.2 
## # ... with 70 more rows
```

---

# Добавление или изменение переменных (трансмутирование)

`transmute()` сохраняет только столбцы, указанные в параметрах. Если вы хотите просто сохранить какой-то из столбцов, то укажите его через оператор равенства:

```r
transmute(regdf, Region = Region, delta = y2015 - y2010) # сохраняем только Region и delta
## # A tibble: 80 x 2
##    Region                delta
##    &lt;chr&gt;                 &lt;dbl&gt;
##  1 Белгородская область   0.1 
##  2 Брянская область       0.3 
##  3 Владимирская область   0.7 
##  4 Воронежская область    1.5 
##  5 Ивановская область     3.00
##  6 Калужская область      0.9 
##  7 Костромская область  -10.1 
##  8 Курская область        0.2 
##  9 Липецкая область       0.7 
## 10 Московская область     6.2 
## # ... with 70 more rows
```

---

# Агрегирование

Вы можете выполнять __агрегирование__ данных и вычислять суммы, средние значения и т.д. используя `summarise()`.

Посчитаем суммарный, минимальный и максимальный объем лесовосстановительных работ по всей стране:

```r
summarise(regdf, 
          sumforest = sum(y2015, na.rm = TRUE),
          minforest = min(y2015, na.rm = TRUE),
          maxforest = max(y2015, na.rm = TRUE))
## # A tibble: 1 x 3
##   sumforest minforest maxforest
##       &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
## 1      801.       0.1      117.
```

---

# Агрегирующие функции

Как правило, `summarise()` используется в паре с агрегирующими функциями, которые берут вектор значений и возвращают одно значение. К таким функциям относятся стандартные операции типа `min()`, `max()`, `mean()`, `sum()` и т.д.

В пакете __dplyr__ также имеются полезные агрегирующие функции:

- `n()` вычисляет количество элементов.
- `n_distinct()` вычисляет количество уникальных элементов.
- `first(x)`, `last(x)` и `nth(x, n)` извлекают, соответственно, первый, последний и n-ный элемент (они бывают особенно удобны, если вы сортируете строки по какому-то критерию). 

---

# Группировка

Достаточно часто данные надо агрегировать не по всей таблице, а __по группам__ измерений. 

В этом случае сначала делается группировка, затем агрегирование данных в каждой группе. 

Предположим, что нам нужно найти регион с наибольшим объемом лесовосставновительных работ в каждом Федеральном округе. Для этого нам потребуется:

1. Дополнить каждую строку региона информацией о принадлежности к федеральному округу
1. Сгруппировать субъекты по федеральным округам
1. Отсортировать каждую группу по убыванию значения поля
1. Взять первую строку в каждой группе
1. Объединить строки в одну таблицу

---

# Группировка

Создадим столбец с информацией о принадлежности субъектов к федеральным округам для последующей группировки. 

```r
flt2 = stringr::str_detect(rdf$Region, 'федеральный округ') # ищем округа
(rdf2 = mutate(rdf, okrug = if_else(flt2, Region, NULL))) # перенесем названия округов в новый столбец
## # A tibble: 89 x 4
##    Region                        y2010 y2015 okrug                        
##    &lt;chr&gt;                         &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;                        
##  1 Российская Федерация          812.  803.  &lt;NA&gt;                         
##  2 Центральный федеральный округ  62.7  72.6 Центральный федеральный округ
##  3 Белгородская область            0.1   0.2 &lt;NA&gt;                         
##  4 Брянская область                2.8   3.1 &lt;NA&gt;                         
##  5 Владимирская область            5.3   6   &lt;NA&gt;                         
##  6 Воронежская область             1.1   2.6 &lt;NA&gt;                         
##  7 Ивановская область              1.6   4.6 &lt;NA&gt;                         
##  8 Калужская область               2.3   3.2 &lt;NA&gt;                         
##  9 Костромская область            25.2  15.1 &lt;NA&gt;                         
## 10 Курская область                 0.3   0.5 &lt;NA&gt;                         
## # ... with 79 more rows
```

---

# Группировка

Теперь нам поможет функция `fill()` из пакета __tidyr__:

```r
(rdf2 = tidyr::fill(rdf2, okrug)) # заполним все пустые строчки предыдущим значением
## # A tibble: 89 x 4
##    Region                        y2010 y2015 okrug                        
##    &lt;chr&gt;                         &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;                        
##  1 Российская Федерация          812.  803.  &lt;NA&gt;                         
##  2 Центральный федеральный округ  62.7  72.6 Центральный федеральный округ
##  3 Белгородская область            0.1   0.2 Центральный федеральный округ
##  4 Брянская область                2.8   3.1 Центральный федеральный округ
##  5 Владимирская область            5.3   6   Центральный федеральный округ
##  6 Воронежская область             1.1   2.6 Центральный федеральный округ
##  7 Ивановская область              1.6   4.6 Центральный федеральный округ
##  8 Калужская область               2.3   3.2 Центральный федеральный округ
##  9 Костромская область            25.2  15.1 Центральный федеральный округ
## 10 Курская область                 0.3   0.5 Центральный федеральный округ
## # ... with 79 more rows
```

---

# Группировка

Оставим только регионы:

```r
(regdf = filter(rdf2, flt)) # оставим только регионы
## # A tibble: 80 x 4
##    Region               y2010 y2015 okrug                        
##    &lt;chr&gt;                &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;                        
##  1 Белгородская область   0.1   0.2 Центральный федеральный округ
##  2 Брянская область       2.8   3.1 Центральный федеральный округ
##  3 Владимирская область   5.3   6   Центральный федеральный округ
##  4 Воронежская область    1.1   2.6 Центральный федеральный округ
##  5 Ивановская область     1.6   4.6 Центральный федеральный округ
##  6 Калужская область      2.3   3.2 Центральный федеральный округ
##  7 Костромская область   25.2  15.1 Центральный федеральный округ
##  8 Курская область        0.3   0.5 Центральный федеральный округ
##  9 Липецкая область       0.4   1.1 Центральный федеральный округ
## 10 Московская область     2.7   8.9 Центральный федеральный округ
## # ... with 70 more rows
```

---

# Группировка

Теперь мы можем определить регион с максимальным объемом лесовосстановительных работ в каждом Федеральном округе, используя вспомогательную функцию `row_number()` которая возвращает номер для каждой строки таблицы:

```r
regdf_gr = group_by(regdf, okrug)
regdf_arr = arrange(regdf_gr, desc(y2015))
(regdf_res = filter(regdf_arr, row_number() == 1))
## # A tibble: 8 x 4
## # Groups:   okrug [8]
##   Region                y2010 y2015 okrug                              
##   &lt;chr&gt;                 &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;                              
## 1 Иркутская область      80.4 117.  Сибирский федеральный округ        
## 2 Хабаровский край       70.2  59.6 Дальневосточный федеральный округ  
## 3 Архангельская область  39.4  57.6 Северо-Западный федеральный округ  
## 4 Пермский край          22.9  32.5 Приволжский федеральный округ      
## 5 Свердловская область   25.6  24.4 Уральский федеральный округ        
## 6 Костромская область    25.2  15.1 Центральный федеральный округ      
## 7 Волгоградская область   1.8   0.9 Южный федеральный округ            
## 8 Чеченская Республика    0.9   0.7 Северо-Кавказский федеральный округ
```

---

# Группировка

`group_by()` часто используется в паре с `summarise()`. Например мы можем получить суммарный объем лесовосстановительных работ по каждому федеральному округу:

```r
regdf_gr = group_by(regdf, okrug)
summarise(regdf_gr, total = sum(y2015, na.rm = TRUE))
## # A tibble: 8 x 2
##   okrug                               total
##   &lt;chr&gt;                               &lt;dbl&gt;
## 1 Дальневосточный федеральный округ   108. 
## 2 Приволжский федеральный округ       110. 
## 3 Северо-Западный федеральный округ   194. 
## 4 Северо-Кавказский федеральный округ   1.1
## 5 Сибирский федеральный округ         259. 
## 6 Уральский федеральный округ          52.9
## 7 Центральный федеральный округ        72.7
## 8 Южный федеральный округ               3.3
```

---

# Конвейер манипуляций

 __Пайп-оператор `%&gt;%`__ предназначен для компактной и наглядной записи _последовательностей_ обработки данных. Работает он следующим образом:

 - `x %&gt;% f` эквивалентно `f(x)`
 - `x %&gt;% f(y)` эквивалентно `f(x, y)`
 - `x %&gt;% f %&gt;% g %&gt;% h` эквивалентно `h(g(f(x)))`

Организация конвейера манипуляций с использованием пайп-оператора позволяет:

- упорядочить операции по обработке данных слева направо (в противоположность направлению изнутри наружу);
- избежать вложенных вызовов функций (матрёшки);
- минимизировать количество переменных для храненния промежуточных результатов;
- упростить добавление новых операций по обработке данных в любое место последовательности.

&gt; __Пайп-оператор `%&gt;%` можно быстро набрать в RStudio__, нажав клавиатурное сочетание &lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;Shift&lt;/kbd&gt; + &lt;kbd&gt;M&lt;/kbd&gt; (&lt;kbd&gt;Cmd&lt;/kbd&gt; + &lt;kbd&gt;Shift&lt;/kbd&gt; + &lt;kbd&gt;M&lt;/kbd&gt; на помпьютерах Mac)

---

# Конвейер манипуляций

С помощью пайп-оператора код по нахождению региона-лидера можно записать так:

```r
regdf = rdf %&gt;% 
  mutate(okrug = if_else(flt2, Region, NULL)) %&gt;% 
  tidyr::fill(okrug) %&gt;% 
  filter(flt)

leaders = regdf %&gt;% 
  group_by(okrug) %&gt;% 
  arrange(desc(y2015)) %&gt;% 
  filter(row_number() == 1)

print(leaders)
## # A tibble: 8 x 4
## # Groups:   okrug [8]
##   Region                y2010 y2015 okrug                              
##   &lt;chr&gt;                 &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;                              
## 1 Иркутская область      80.4 117.  Сибирский федеральный округ        
## 2 Хабаровский край       70.2  59.6 Дальневосточный федеральный округ  
## 3 Архангельская область  39.4  57.6 Северо-Западный федеральный округ  
## 4 Пермский край          22.9  32.5 Приволжский федеральный округ      
## 5 Свердловская область   25.6  24.4 Уральский федеральный округ        
## 6 Костромская область    25.2  15.1 Центральный федеральный округ      
## 7 Волгоградская область   1.8   0.9 Южный федеральный округ            
## 8 Чеченская Республика    0.9   0.7 Северо-Кавказский федеральный округ
```

---

# Традиционная запись


```r
regdf = filter(
           tidyr::fill(
             mutate(
               rdf,
               okrug = if_else(flt2, Region, NULL)
             ),
             okrug
           ),
           flt
         )

result = filter(
           arrange(
             group_by(
               regdf, 
               okrug
             ),
             desc(y2015)
           ),
           row_number() == 1
         )
```

---

# Преобразование структуры

Аккуратные данные ([__tidy data__](https://www.jstatsoft.org/article/view/v059i10)) отвечают следующим требованиям:

1. Каждый столбец представляет переменную
2. Каждая строка представляет измерение
3. Каждая ячейка представляет значение

Приведение таблицы к аккуратному виду можно сделать, используя функции из пакета [__tidyr__](https://tidyr.tidyverse.org). Основных функций в этом пакете всего две:

- `gather()` берет несколько колонок и преобразует их к виду «ключ---значение»: широкие таблицы становятся длинными.
- `spread()` берет две колонки, соответствующие ключу и значению, и распределяет их на множество колонок: длинные таблицы становятся широкими.

Помимо этого, есть еще 2 полезных функции, которые позволяют «распиливать» или «склеивать» колонки:

- `separate()` разделяет колонку на несколько колонок, используя заданный символ-разделитель или позицию.
- `unite()` скливает несколько колонок, используя заданный символ-разделитель.

---

# Преобразование структуры

Рассмотрим на примере таблицы _reforest_ по лесовосстановленю в регионах России приведение к аккуратному виду:

```r
library(tidyr)
(reforest_tidy = reforest %&gt;% gather(year, value, y2005:y2016))
## # A tibble: 712 x 3
##    Region                        year  value
##    &lt;chr&gt;                         &lt;chr&gt; &lt;dbl&gt;
##  1 Российская Федерация          y2005 812. 
##  2 Центральный федеральный округ y2005  52.6
##  3 Белгородская область          y2005   0.4
##  4 Брянская область              y2005   2.9
##  5 Владимирская область          y2005   4.4
##  6 Воронежская область           y2005   1.1
##  7 Ивановская область            y2005   2.1
##  8 Калужская область             y2005   2.2
##  9 Костромская область           y2005  10  
## 10 Курская область               y2005   0.5
## # ... with 702 more rows
```

---

# Преобразование структуры

Осталось избавиться от буквы `y` перед каждым годом — для этого можно использовать `separate()`, `select()` и `mutate()` :

```r
(reforest_tidy = reforest_tidy %&gt;% 
  separate(year, c('y', 'year'), 1) %&gt;% 
  select(-y) %&gt;% 
  mutate(year = as.integer(year)))
## # A tibble: 712 x 3
##    Region                         year value
##    &lt;chr&gt;                         &lt;int&gt; &lt;dbl&gt;
##  1 Российская Федерация           2005 812. 
##  2 Центральный федеральный округ  2005  52.6
##  3 Белгородская область           2005   0.4
##  4 Брянская область               2005   2.9
##  5 Владимирская область           2005   4.4
##  6 Воронежская область            2005   1.1
##  7 Ивановская область             2005   2.1
##  8 Калужская область              2005   2.2
##  9 Костромская область            2005  10  
## 10 Курская область                2005   0.5
## # ... with 702 more rows
```

---

# Преобразование структуры

Теперь можно выполнять любые запросы, комбинирующие год измерения и величину показателя:

```r
reforest_tidy %&gt;% filter(year &gt; 2011 &amp; year &lt; 2016 &amp; value == 0)
## # A tibble: 2 x 3
##   Region             year value
##   &lt;chr&gt;             &lt;int&gt; &lt;dbl&gt;
## 1 Орловская область  2013     0
## 2 Республика Адыгея  2014     0
```

---

# Преобразование структуры

В некоторых случая бывает удобно распределить переменную по нескольким колонкам. В частности, это может быть удобно, если нам надо вычислить разности между годами. Для этого используем `spread()`:

```r
(reforest = reforest_tidy %&gt;% spread(year, value))
## # A tibble: 89 x 9
##    Region          `2005` `2010` `2011` `2012` `2013` `2014` `2015` `2016`
##    &lt;chr&gt;            &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;
##  1 Алтайский край    12     10.9   13.5   13.8   13.2   14.3   13.7   12  
##  2 Амурская облас…   33.3   29.8   32.2   33.6   35.5   37.7   28.5   27.7
##  3 Архангельская …   42.6   39.4   48.5   48.8   52.7   60.7   57.6   63.5
##  4 Астраханская о…    0.1    0.1    0      0.1    0.1    0.1    0.1    0  
##  5 Белгородская о…    0.4    0.1    0.3    0.3    0.4    0.4    0.2    0.2
##  6 Брянская облас…    2.9    2.8    3      3.2    3.5    3.3    3.1    3  
##  7 Владимирская о…    4.4    5.3    5.7    6      7.1    5.9    6      4.9
##  8 Волгоградская …    1.6    1.8    2      1.3    1.1    1.2    0.9    0.9
##  9 Вологодская об…   25.6   32.3   44.2   43.3   43.6   44.8   49     52  
## 10 Воронежская об…    1.1    1.1    1.8    3      2.7    2.7    2.6    2.3
## # ... with 79 more rows
```

---

# Преобразование структуры

Теперь вычислим разности по сравнению с предыдущим годом:

```r
diffs = reforest %&gt;% select(`2011`:`2016`) -
        reforest %&gt;% select(`2010`:`2015`)

diffs %&gt;% 
  mutate(Region = reforest$Region) %&gt;% 
  select(Region, `2011`:`2016`) %&gt;% 
  head() # Посмотрим шапку таблицы
##                  Region 2011 2012 2013 2014 2015 2016
## 1        Алтайский край  2.6  0.3 -0.6  1.1 -0.6 -1.7
## 2      Амурская область  2.4  1.4  1.9  2.2 -9.2 -0.8
## 3 Архангельская область  9.1  0.3  3.9  8.0 -3.1  5.9
## 4  Астраханская область -0.1  0.1  0.0  0.0  0.0 -0.1
## 5  Белгородская область  0.2  0.0  0.1  0.0 -0.2  0.0
## 6      Брянская область  0.2  0.2  0.3 -0.2 -0.2 -0.1
```

---

# Соединение

В процессе __соединения__ в обеих таблицах находятся строки, соответствующие одному и тому же измерению (например, региону). 

Чтобы найти соответствие, в обеих таблицах должен быть по крайней мере один столбец, идентифицирующий каждую строку. В первой таблице он называется __первичным ключом__ _(primary key)_, во второй таблице --- __внешним ключом__ _(foreign key)_.

---

# Соединение в __dplyr__

_Мутирующее соединение:_

- `inner_join(x, y, by = )` возвращает все строки из `x`, для которых имеются соответствующие строки в `y`, а также все столбцы из `x` и `y`.
- `left_join(x, y, by = )` возвращает все строки из `x`, а также все столбцы из `x` и `y`. Строки в `x`, для которых не найдены соответствия в `y`, будут иметь значения `NA` в присоединенных столбцах
- `right_join(x, y, by = )` возвращает все строки из `y`, а также все столбцы из `x` и `y`. Строки в `y`, для которых не найдены соответствия в `x`, будут иметь значения `NA` в присоединенных столбцах
- `full_join(x, y, by = )` возвращает все строки и колонки из `x` и `y`. В строках, для которых не найдено соответствие ячейки присоединяемых столбцов будут заполнены значениями `NA`

_Фильтрующее соединение:_

- `semi_join(x, y, by = )` возвращает все строки из `x`, для которых имеются соответствующие строки в `y`, а также все столбцы из `x`
- `anti_join(x, y, by = )` возвращает все строки из `x`, для которых _не_ найдены соответствующие строки в `y`, а также все столбцы из `x`

---

# Соединение

Рассмотрим соединение таблиц на примере данных по лесовосстановлению и заготовкам древесины. Подгрузим таблицу по лесозаготовкам:

```r
(timber = read_excel('data/timber.xlsx', 
                    col_types = c('text', rep('numeric', 8))) %&gt;% 
  filter(!stringr::str_detect(Регион, 'Федерация|федеральный округ')))
## # A tibble: 75 x 9
##    Регион           `2010` `2011` `2012` `2013` `2014` `2015` `2016` Место
##    &lt;chr&gt;             &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;
##  1 Белгородская об…   30.4   39.6   27.7   37.4   34.1   45.6   30.4    60
##  2 Брянская область  614.   616.   824.   850.   793.   739.   750.     27
##  3 Владимирская об… 1078   1335   1236   1142   1165   1272   1252      20
##  4 Воронежская обл…   73.6   69.5   68.6   47.9   81.1   86.6   53.5    58
##  5 Ивановская обла…  130.   140.   200.   199.   231.   326.   421.     38
##  6 Калужская облас…  274.   244.   192.   198.   183    145.   204      44
##  7 Костромская обл… 3000   3332   2797   2692   2564   2186   2515      14
##  8 Курская область    22.8   55.4   49.7   50.1   65.9   74.6   80.7    55
##  9 Липецкая область  163.   139     49.7   42.6   50.1   73.1   87.8    53
## 10 Московская обла…  126.   265.   299.   108.    15.6   NA     NA      74
## # ... with 65 more rows
```

---

# Соединение

Приведем ее к аккуратному виду, который соответствует виду таблицы по лесовосстановлению:

```r
(timber_tidy = timber %&gt;% 
  gather(year, harvest, `2010`:`2016`) %&gt;% 
  transmute(Region = Регион,
            year = as.numeric(year),
            harvest = harvest))
## # A tibble: 525 x 3
##    Region                year harvest
##    &lt;chr&gt;                &lt;dbl&gt;   &lt;dbl&gt;
##  1 Белгородская область  2010    30.4
##  2 Брянская область      2010   614. 
##  3 Владимирская область  2010  1078  
##  4 Воронежская область   2010    73.6
##  5 Ивановская область    2010   130. 
##  6 Калужская область     2010   274. 
##  7 Костромская область   2010  3000  
##  8 Курская область       2010    22.8
##  9 Липецкая область      2010   163. 
## 10 Московская область    2010   126. 
## # ... with 515 more rows
```

---

# Соединение

Теперь нам осталось присоединить данные по лесозаготовкам к таблице по лесовосстановлению, используя имя региона (`Region`) и год (`year`) в качестве ключевых полей:

```r
(compare = reforest_tidy %&gt;% 
  inner_join(timber_tidy, by = c("Region" = "Region", "year" = "year")))
## # A tibble: 511 x 4
##    Region                year value harvest
##    &lt;chr&gt;                &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;
##  1 Белгородская область  2010   0.1    30.4
##  2 Брянская область      2010   2.8   614. 
##  3 Владимирская область  2010   5.3  1078  
##  4 Воронежская область   2010   1.1    73.6
##  5 Ивановская область    2010   1.6   130. 
##  6 Калужская область     2010   2.3   274. 
##  7 Костромская область   2010  25.2  3000  
##  8 Курская область       2010   0.3    22.8
##  9 Липецкая область      2010   0.4   163. 
## 10 Московская область    2010   2.7   126. 
## # ... with 501 more rows
```

---

# Соединение

Наконец, вычислим искомое отношение и упорядочим регионы:

```r
(compare = compare %&gt;% 
   mutate(ratio = 1000 * value / harvest) %&gt;% 
   select(Region, year, ratio, value, harvest) %&gt;% 
   arrange(year, desc(ratio)))
## # A tibble: 511 x 5
##    Region                    year ratio value harvest
##    &lt;chr&gt;                    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;
##  1 Ставропольский край       2010 182.    0.4     2.2
##  2 Ростовская область        2010 149.    1.5    10.1
##  3 Магаданская область       2010 118.    2.6    22  
##  4 Сахалинская область       2010  63.8  12.7   199. 
##  5 Республика Саха (Якутия)  2010  63.3  58     917. 
##  6 Республика Тыва           2010  61.8   4.4    71.2
##  7 Мурманская область        2010  52.2   3      57.5
##  8 Волгоградская область     2010  48.4   1.8    37.2
##  9 Камчатский  край          2010  38.9   5.2   134. 
## 10 Амурская область          2010  38.5  29.8   773. 
## # ... with 501 more rows
```

---

# Запись

Запись файлов _в текстовом формате_ можно осуществить посредством функций из пакета __readr__, таких как `write_delim()`, `write_csv()` и `write_tsv()`. Базовый синтаксис их предельно прост:

```r
write_csv(compare, "data/output/timber_compare.csv")
```

Для записи таблиц _Microsoft Excel_ можно использовать возможности пакета [__writexl__](https://cran.r-project.org/web/packages/writexl/index.html):

```r
library(writexl)
write_xlsx(compare, "data/output/timber_compare.xlsx")
```

Каждая из этих функций содержит ряд дополнительных параметров, позволяющих управлять внешним видом выгружаемых таблиц. Более подробно с ними вы можете ознакомиться, вызвав справку для соответствующей функции.

---

# Рекомендации по подготовке таблиц для чтения в R

1. В первой строке таблицы должны располагаться названия столбцов.
1. Во второй строке таблицы должны начинаться данные. Не допускайте многострочных заголовков.
1. В названиях столбцов недопустимы объединенные ячейки, покрывающие несколько столбцов. Это может привести к неверному подсчету количества столбцов и, как следствие, некорректному чтению таблицы в целом.
1. Названия столбцов должны состоять из латинских букв и цифр, начинаться с буквы и не содержать пробелов. Сложносочиненные названия выделяйте прописными буквами. Плохое название столбца: `Валовый внутренний продукт за 2015 г.`. Хорошее название столбца: `GDP2015`.
1. Некоторые ошибки данных в таблицах (такие как неверные десятичные разделители), проще найти и исправить в табличном/текстовом редакторе, нежели после загрузки в __R__.

&gt; Следование этим правилам значительно облегчит работу с табличными данными в среде __R__.
    </textarea>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create();
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function() {
  var d = document, s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})();</script>

<script>
(function() {
  var i, text, code, codes = document.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
})();
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
