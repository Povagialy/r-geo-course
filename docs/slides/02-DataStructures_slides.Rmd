---
title: "Структуры данных и циклы"
subtitle: "Визуализация и анализ географических данных на языке R"
author: "Тимофей Самсонов"
date: "`r Sys.Date()`"
output:
  xaringan::moon_reader:
    # chakra: libs/remark-latest.min.js
    css: [default, metropolis, metropolis-fonts]
---

# Структуры данных и циклы

```{r setup, echo = FALSE, purl = FALSE, cache = FALSE, include=FALSE}
knitr::opts_knit$set(global.par = TRUE)
knitr::opts_chunk$set(warning=FALSE, collapse = TRUE)
```

## __Структура данных__ --- это программная единица, позволяющая хранить и обрабатывать множество однотипных и/или логически связанных данных.

---

# Векторы

Вектор представляет собой упорядоченную последовательность объектов одного типа. Вектор может состоять _только_ из чисел, _только_ из строк, _только_ из дат или _только_ из логических значений и т.д. 

## Создание

Существует множество способов создания векторов. Среди них наиболее употребительны:

1. Явное перечисление элементов
2. Создание пустого вектора ("болванки"), состоящего из заданного числа элементов
3. Генерация последовательности значений
4. Генерация случайного множества значений

---

# Векторы

Для создания вектора путем __перечисления__ элементов используется функция `c()`:
```{r, collapse=TRUE}
# вектор из строк — цвета некоторых веток Московского метро
colors = c("Красная", "Зеленая", "Синяя", "Коричневая", "Оранжевая")
colors
```

```{r, collapse=TRUE}
# вектор из чисел — длина веток в километрах (в той же последовательности)
lengths = c(28, 40, 45, 19, 38)
lengths
```

```{r, collapse=TRUE}
# вектор из булевых переменных — наличие  открытых наземных участков (в той же последовательности)
opens = c(FALSE, TRUE, TRUE, FALSE, FALSE)
opens
```

---

# Векторы

## Создание пустого вектора

```{r, collapse=TRUE}
# Вектор из 5 элементов, который предполагается заполнить целыми числами
intvalues = vector(mode = "integer", length = 5)
intvalues # по умолчанию заполнен нулями

# Вектор из 10 элементов, который предполагается заполнить символьными данными (строками)
charvalues = vector("character", 10)
charvalues # по умолчанию заполнен пустыми строками
```

---

# Векторы

## Генерация последовательности

Наконец, третий распространенный способ создания векторов --- это __генерация последовательности__. Чтобы сформировать вектор из натуральных чисел от `M` до `N`, можно воспользоваться специальной конструкцией: `M:N`:
```{r, collapse=TRUE}
index = 1:5 # эквивалентно c(1,2,3,4,5)
index
```

Существует и более общий способ создания последовательности --- функция `seq()`, которая позволяет генерировать вектора значений нужной длины и/или с нужным шагом:
```{r, collapse=TRUE}
seq(from = 1, by = 2, length.out = 10) # 10 нечетных чисел, начиная с единицы
seq(from = 2, to = 20, by = 3) # от 2 до 20 с шагом 3 (сколько поместится)
seq(length.out = 10, to = 2, by = -2) # убывающая последовательность из 10 четных чисел с последним элементом, равным 2
```

---

# Векторы

## Генерация последовательности дат

Аналогичным образом можно создавать _последовательности дат_:
```{r, collapse=TRUE}
seq(from = as.Date('2016/09/01'), by = 1, length.out = 7) # Даты первой недели учебного 2016/2017 года

seq(from = Sys.Date(), by = 7, length.out = 5) # Пять дат через неделю, начиная с сегодняшнего дня
```

## Генерация случайной последовательности

Наиболее часто испольщуются функции `runif()` (равномерное распределение) и `rnorm()` (нормальное распределение):
```{r}
runif(5, 0, 100) # 5 чисел равномерного распределения в диапазоне от 0 до 100
rnorm(5, 10, 5) # 5 чисел нормального распределения со средним = 10 и СКО = 5
```

---

# Индексирование

К отдельным __элементам вектора__ можно обращаться по их индексам:
```{r, collapse=TRUE}
colors[1] # первый элемент вектора
colors[3] # третий элемент
```

__Количество элементов (длину) вектора__ можно узнать с помощью функции `length()`:
```{r, collapse=TRUE}
length(colors)
```

Последний элемент вектора можно извлечь, если мы знаем его длину:
```{r, collapse=TRUE}
n = length(colors)
colors[n]
```

---

# Индексирование

## Извлечение подвекторов

Последовательности удобно использовать для извлечения подвекторов. Предположим, нужно извлечь первые 4 элемента. Для этого запишем:
```{r, collapse=TRUE}
lengths[1:4]
```

Индексирующий вектор можно создать заранее. Это удобно, если номера могут меняться в программе:
```{r, collapse=TRUE}
m = 1
n = 4
index = m:n
lengths[index]
```

---

# Индексирование

## Произвольные последовательности

Обратите внимание на то что по сути один вектор используется для извлечения элементов из другого вектора. Это означает, что мы можем использовать не только простые последовательности натуральных чисел, но и векторы из прозвольных индексов. Например:
```{r, collapse=TRUE}
index = c(1, 3, 4) # хотим извлечь 1, 3 и 4 элемент списка
lengths[index]

index = c(5, 1, 4, 2) # индексы могут располагаться в произвольном порядке
lengths[index]
```

---

# Преобразование

К числовым векторам можно применять множество функций. Прежде всего, нужно знать функции вычисления базовых параметров статистического ряда --- минимум, максимум, среднее, медиана, дисперсия, размах вариации, среднеквадратическое отклонение, сумма:
```{r, collapse=TRUE}
min(lengths) # минимум
max(lengths) # максимум
range(lengths) # размах вариации = максимум - минимум
mean(lengths) # среднее арифметическое
median(lengths) # медиана
var(lengths) # дисперсия (по английски - вариация, variation)
sd(lengths) # среднеквадратическое отклонение (standard deviation)
sum(lengths) # сумма
```

---

# Преобразование

Любая математическая функция, применимая к числу, будет применима и к вектору:
```{r, collapse=TRUE}
lengths * 1000 # преобразуем длины линий в метры
sqrt(lengths) # квадратный корень из длины каждого элемента

stations = c(20, 21, 22, 12, 24) # количество станций

dens = stations / lengths # плотность станций по веткам метро = кол-во станций / длина 
dens
```

---

# Сортировка и поиск

К важнейшим преобразованиям векторов относится их __сортировка__:
```{r, collapse=TRUE}
sort(lengths) # сортировка по возрастанию значений
lengths # сравним с исходным

sort(lengths, decreasing = TRUE) # сортировка по убыванию значений. Нужно задать параметр decreasing
```

Для __поиска__ индекса элемента используется функция `match()`:
```{r, collapse=TRUE}
(l = max(lengths)) # находим максимальное значение
(idx = match(l, lengths)) # находим индекс элемента, равного l, в списке lengths
(color = colors[idx]) # извлекаем цвет ветки метро
```

---

# Проверка условий

Проверка условия для вектора приводит к получению вектора логических значений:
```{r}
lengths > 20
```

Для векторов существует специальная форма векторизованного условного оператора -- функция `ifelse()`. Например, мы можем охарактеризовать каждую линию метро как длинную или короткую, установив порог в 20 км:
```{r}
lengths
(line_type = ifelse(lengths > 20, 'Длинная', 'Короткая'))
```

---

# Описательные статистики

Можно получить краткую статистическую сводку по вектору (и любой другой структуре данных) с использованием функции `summary()`. Для качественных переменных выдаются частоты вхождения каждого случая, для количественных — набор основных описательных статистик:
```{r}
summary(lengths)
summary(opens)
```

---

# Матрицы

__Матрица__ — это обобщение понятия вектора на 2 измерения. Матрица, как правило, создается с помощью функции `matrix()`, которая принимает 3 обязательных аргумента: вектор исходных значений, количество строк и количество столбцов:
```{r, collapse=TRUE}
v = 1:12  # создадим вектор из натуральных чисел от 1 до 12
m = matrix(v, nrow = 3, ncol = 4)
m
```

По умолчанию матрица заполняется данными вектора по столбцам. Если вы хотите заполнить ее по строкам, необходимо указать параметр `byrow = TRUE`:
```{r, collapse=TRUE}
m = matrix(v, nrow = 3, ncol = 4, byrow = TRUE)
m
```

---

# Матрицы

## Индексирование

Доступ к элементам матрицы осуществляется аналогично вектору:
```{r, collapse=TRUE}
m[2,4]  # 2 строка, 4 толбец
m[3,1]  # 3 строка, 1 столбец
```

Чтобы извлечь одну строку или столбецб необходимо пропустить номер второго измерения. Результат является вектором:
```{r, collapse=TRUE}
m[2,]  # 2 строка
m[,3]  # 3 cтолбец
```

---

# Матрицы

## Преобразование

К матрицам можно применять операции, аналогичные операциям над векторами:
```{r, collapse=TRUE}
log(m)  # натуральный логарифм ото всех элементов
sum(m)  # сумма всех элементов матрицы
```

B и получать по ним описательные статистики:
```{r}
summary(m)
```

---

# Матрицы

## Сортировка

Сортировка матрицы приведет к тому что будет возвращен обычный вектор:
```{r, collapse=TRUE}
sort(m)
```

---

# Матрицы

## Специальные операции

К матрицам применимы операции транспонирования и вычисления определителя:
```{r, collapse=TRUE, error = TRUE}
t(m)  # транспонированная матрица
m2 = matrix(-3:3,nrow = 3, ncol = 3)
det(m2) # определитель матрицы
```

Матрицы также можно перемножать с помощью специального оператора `%*%`:
```{r, collapse=TRUE, error = TRUE}
m2 %*% m
```

---

# Матрицы

## Поиск элемента

Для поиска индексов требуемого элемента необходимо использовать функцию `which()`. Если мы хотим найти в матрице m позицию числа $8$, то вызов функции будет выглядеть так:
```{r, collapse=TRUE}
indexes = which(m == 8, arr.ind = TRUE)
row = indexes[1,1]
col = indexes[1,2]
m[row,col]
```

---

# Матрицы

## Сборка из векторов

Для этого можно использовать функции `cbind()` и `rbind()`:
```{r, collapse=TRUE}
lengths = c(28, 40, 45, 19, 38)
stations = c(20, 21, 22, 12, 24)
cbind(lengths, stations)  # соединим вектора в качестве столбцов
rbind(lengths, stations)  # соединим вектора в качестве строк
```

---

# Матрицы

## Сборка из векторов

Cтроки и столбцы матрицы можно использовать как векторы при выполнении арифметических операций:
```{r, collapse=TRUE}
mm = cbind(lengths, stations)
mm[,2]/mm[,1]  # количество станций на 1 км пути
```

Результат можно присоединить к уже созданной матрице:
```{r, collapse=TRUE}
dens = mm[,2]/mm[,1]
mm = cbind(mm, dens)
mm
```

---

# Массивы

__Массивы (arrays)__ --- это многомерные структуры данных, с колчеством измерений 3 и более. Трехмерный массив представляет собой куб однородных данных. Для создания массива используется функция `array()`:
```{r, collapse=TRUE}
z = array(1:36, c(3,4,2)) # вектор значений для заполнения массива, а также длина каждого измерения
print(z)
```

---

# Фреймы данных

__Фреймы данных__ — это обобщение понятия матрицы на данные смешанных типов. Фреймы данных - наиболее распространенный формат представления табличных данных.

Для создания фреймов данных используется функция `data.frame()`:
```{r, collapse=TRUE}
(df = data.frame(colors,lengths,stations)) # как мы видим, уже никаких кавычек вокруг чисел
```

К фреймам также можно пристыковывать новые столбцы:
```{r, collapse=TRUE}
(df = cbind(df, dens))
```

---

# Фреймы данных

## Извлечение элементов

Как и прежде, к столбцам и строкам можно обращаться по индексам:
```{r, collapse=TRUE}
df[2,2]
df[,3]
df[4,]
```

Вы можете обращаться к отдельным столбцам фрейма данных по их названию, используя оператор `$` (доллар):
```{r, collapse=TRUE}
df$lengths
df$stations
```

---

# Фреймы данных

## Работа со столбцами

Так же как и ранее, можно выполнять различные операции над столбцами:
```{r, collapse=TRUE}
max(df$stations)
df$lengths / df$stations
```

Названия столбцов можно получить с помощью функции `colnames()`
```{r, collapse=TRUE}
colnames(df)
```

---

# Фреймы данных

## Присоединение строк

Чтобы присоединить строку, сначала можно создать фрейм данных из одной строки и перенести в него названия столбцов:
```{r, collapse=TRUE}
row = data.frame("Фиолетовая", 40.5, 22, 22/45)
colnames(row) = colnames(df)
```

После того как столбцы приведены в соответствие, можно присоединить новую строку:
```{r, collapse=TRUE}
(df = rbind(df,row))
```

---

# Фреймы данных

## Сортировка

Чтобы _отсортировать_ фрейм данных по значению определенного поля, необходимо узнать порядок элементов в этом поле с помощью функции `order()` и проиндексировать им первое измерение фрейма:
```{r}
df[order(df$lengths), ]
```

---

# Фреймы данных

## Фильтрация

Чтобы _отфильтровать_ фрейм данных по значению определенного поля, необходимо передать условие в первое измерение фрейма:
```{r}
df[df$lengths > 25, ]
```

---

# Фреймы данных

## Описательные статистики

К фреймам данных, так же как и к однородным структурам, можно применять функцию `summary()` для получения описательных статистик. При этом отчет формируется по каждому столбцу:
```{r}
summary(df)
```

---

# Списки

__Список__ — это наиболее общий тип контейнера в R. Список отличается от вектора тем, что он может содержать набор объектов произвольного типа.
```{r, collapse=TRUE}
d = "Этот фрейм данных содержит данные по 6 линиям Московского метро"
s = summary(df)  # summary() выдает обобщающую статистику вектору, матрице или фрейму данных
```

Сооружаем список из трех элементов:
```{r, collapse=TRUE}
metrolist = list(d, df, s)
metrolist
```

---

# Списки

Можно дать элементам списка осмысленные названия при создании:
```{r, collapse=TRUE}
metrolist = list(desc = d, table = df, summary = s)
metrolist
```

---

# Списки

## Извлечение элементов

Можно обратиться к элементу списка по его названию:
```{r, collapse=TRUE}
metrolist$summary
```

К элементу списка можно также обратиться по его порядковому номеру или названию, заключив их в _двойные_ квадратные скобки:
```{r, collapse=TRUE}
metrolist[[1]]
metrolist[["desc"]]
```

---

# Списки

## Описательные статистики

Вызов функции `summary()` в приложении к списку выведет статистику по типам и количеству элементов списка:
```{r}
summary(metrolist)
```

---

# Факторы

Понятие __фактора__ в терминологии __R__ используется для обозначения категориальной (качественной) переменной. Например, каждая линия Московского метро имеет свой номер. Создадим небольшей фрейм данных с электродепо по интересующим нас веткам метро и рассчитаем по ним описательные статистики:
```{r}
depots = data.frame(
  depot = c('Северное', 'Черкизово', 'Сокол', 'Замоскворецкое', 
            'Братеево', 'Измайлово', 'Фили', 'Митино', 
            'Красная Пресня', 'Калужское', 'Свиблово'),
  year_opened = c(1935, 1990, 1938, 1969, 
                  2014, 1950, 1962, 2016,
                  1954, 1962, 1978),
  line_number = c(1, 1, 2, 2, 2, 3, 3, 3, 5, 6, 6)
)
```

---

# Факторы

```{r}
summary(depots)
```

Как видно, __R__ посчитал нам средний номер линии метро - 3.091. Чтобы этого не происходило, укажем в явном виде с помощью функции `factor()`, что номер линии метров является номинальной переменной:
```{r}
depots$line_number = as.factor(depots$line_number)
print(depots$line_number)
```

---

# Факторы

Попробуем теперь посчитать описательные статистики по переменной и таблице в целом:
```{r}
mean(depots$line_number)
summary(depots)
```

Теперь мы видим, что вместо стандартных статистик __R__ для переменной *line_number* выдает таблицу частот, из которой ясно, что на первой линии два депо, на второй линии три депо и так далее.

---

# Описание структуры данных

Для описания структуры данных можно использовать две широко используемые диагностические функции: `class()` выведет тип структуры, а `str()` выведет детальную выписку по компонентам этой структуры:
```{r}
class(depots) # тип объекта
str(depots) # структура объекта
```

---

# Циклы

__Цикл__ --- это разновидность управляющей конструкции, предназначенная для организации многократного исполнения набора инструкций. В __R__ циклы наиболее часто используются для пакетной обработки данных, ввода и вывода.

Первый вид циклов — это конструкция __for__ с синтаксисом `for (x in X) statement`:

- переменная `x` должна пробежать по всем элементам последовательности `X`. В качестве последовательности может выступать любой вектор или список.
- каждый раз, когда `x` будет присвоено значение очередного элемента из `X`, будет выполнено выражение `statement`, которое называют _телом цикла_. Соответственно, цикл выполнится столько раз, сколько элементов содержится в последовательности `X`. 

> Выполнение тела цикла на каждом проходе называют _итерацией_.

---

# Циклы

## for

Например, с помощью цикла можно вывести на экран числа от 1 до 10, по одному с каждой строки:
```{r, collapse = TRUE}
## ЦИКЛЫ
for (i in 1:10) print(i)
```

---

# Циклы

## for

Если тело цикла содержит более одной инструкции R, оно должно быть заключено в фигурные скобки:
```{r, collapse = TRUE}
for (i in 1:10) {
  a = factorial(i) # факториал i
  b = exp(i) # e в степени i
  print(a/b) # факториал растет быстрее экспоненты
}
```

---

# Циклы

## while

Другой вариант цикла организуется с помощью конструкции `while`, имеющей синтаксис `while (condition) statement`:
```{r, collapse = TRUE}
i = 0
while(i < 5) {
  i = i+1
  print(i)
}
```
Обратите внимание на то, что мы внутри цикла обновляем значение переменной i.

> Увеличение значения переменной цикла называется _инкрементом_, а уменьшение --- _декрементом_.

---

# Циклы

Пример --- вычисление медианного значения для каждого столбца таблицы линий метро:
```{r}
n = ncol(df)
medians = vector('numeric', n)

for (i in 1:n) {
  if(is.numeric(df[, i])){
    medians[i] = median(df[, i])
  } else {
    medians[i] = NA
  }
}
colnames(df) # Переменные
medians # Медианные значения
```

---

# Циклы

## Прерывание

- `break` прерывает цикл
- `next` прерывает текущую итерацию цикла

Например, мы можем выводить информацию об электродепо, имеющихся на линии метро с введенным пользователем номером, до тех пор, пока он не введет символ `q`. Чтобы цикл был бесконечным, используем специальную форму `while (TRUE)`:
```{r, eval=FALSE}
while (TRUE) {
  cat('Введите номер ветки метро:')
  input = readline()
  if (input == 'q')
    break
  else {
    n = as.numeric(input)
    if (!is.na(n))
      depots[depots$line_number == n, ]
  }
}
```

---

# Циклы

Оператор `next` используется реже, он взаимозаменяем с конструкцией `if-else`:

```{r, eval=FALSE}
while (...) {
  if (condition1)
    next
  ... # сюда попадем, только если condition1 == FALSE
  
  if (condition2)
    next
  ... # сюда попадем, только если condition2 == FALSE
}
```

или:
```{r, eval=FALSE}
while (...) {
  if (!condition1) {
    ... # сюда попадем, только если condition1 == FALSE
    
    if (!condition2) {
      ... # сюда попадем, только если condition2 == FALSE
    }
  }
}
```
