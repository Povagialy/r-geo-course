---
title: "Таблицы"
subtitle: "Визуализация и анализ географических данных на языке R"
author: "Тимофей Самсонов"
date: "`r Sys.Date()`"
output:
  xaringan::moon_reader:
    # chakra: libs/remark-latest.min.js
    css: [default, metropolis, metropolis-fonts]
---

```{r setup, echo = FALSE, purl = FALSE, cache = FALSE, include=FALSE}
library(datasets)
knitr::opts_knit$set(global.par = TRUE)
knitr::opts_knit$set(root.dir = "../")
knitr::opts_chunk$set(warning=FALSE, collapse=TRUE)
```

# Предварительные требования

Для работы по теме текущей лекции вам понадобятся пакеты из __tidyverse__, а также __writexl__. Установите их, используя следующую команду:
```{r, eval=FALSE}
install.packages('tidyverse')
install.packages('writexl')
```

> Внимание: установка пакетов выполняется один раз из консоли. Вызов функции `install.packages()` не должен присутствовать в ваших скриптах

---

# Tidyverse

Пакет       | Назначение
------------|-----------
__tibble__  | Усовершенствованный вариант фрейма данных
__dplyr__   | Грамматика манипуляций над табличными данными
__tidyr__   | Приведение таблиц в аккуратный вид, удобный для обработки
__readr__   | Чтение табличных данных из текстовых файлов
__readxl__  | Чтение табличных данных из файлов Microsoft Excel
__haven__   | Чтение табличных данных из файлов SPSS, Stata и SAS
__purrr__   | Функциональное программирование
__stringr__ | Работа со строками
__forcats__ | Автоматизация работы с факторами
__ggplot2__ | Построение графиков на основе правил грамматики 

Вы можете подключать эти пакеты по одному, или сделать их все доступными в текущей сессии __R__, используя команду `library(tidyverse)`. 

---

# Вызов функций без подключения пакета

__Вы можете вызвать функцию из любого пакета, не подключая его целиком в текущую сессию R.__ 

В этом случае вызов функции будет выглядеть как `package::function()`, где `package` -- название пакета, а `function` - название функции. 

> Подобный синтаксис бывает особенно удобным, когда _в разных пакетах имеются функции с одинаковым именем_, и при вызове R использует не ту, которая нужна (по умолчанию будет использована функция из пакета, который был подключен _позже_).

---

# Тибблы и фреймы данных

В современных пакетах типа __tidyverse__ используется разновидность фрейма данных, которая называется __тиббл__ (`tibble`). Создать тиббл можно напрямую, либо путем конвертации фрейма данных:
```{r}
library(tibble)
tibble(
  a = 1:3, 
  b = 1, 
  c = -1:1
)
dfr = data.frame(a = 1:3, b = 1,  c = -1:1)
as_tibble(dfr)
```

---

# Тибблы и фреймы данных

Тибблы можно создавать вручную не только по столбцам, но и по строкам, используя функцию `tribble()` (переводится как _transposed tibble_ --- транспонированный тиббл), указав имена столбцов с помощью тильды (`~`):
```{r}
tribble(
  ~a, ~b, ~c,
   1,  1, -1,
   2,  1,  0,
   3,  1,  1
)
```

> В данной и последующих лекциях понятия мы будем использовать понятия таблица, фрейм данных и тиббл как взаимозаменяемые.

---

# Чтение

## Встроенные данные

Пакеты R часто содержат тестовые наборы данных. Эти данные, как правило, предназначены для ознакомления с возможностями пакета. 

Чтобы узнать, какие данные есть в пакете, вы можете вызвать функцию `data(package = 'packagename')`, где `packagename` --- это имя интересующего вас пакета. 

Например, посмотрим, какие данные есть в пакете `dplyr`, который мы далее будем использовать для манипуляций с таблицами:
```{r}
data(package = 'dplyr')
```
![_Данные, доступные в пакете dplyr_](images/data_dplyr.png)

---

# Встроенные данные

Для загрузки набора данных передайте его название в качестве первого параметра функции `data()`. Ну-ка, что там с персонажами из _Star Wars_:
```{r}
data(starwars, package = 'dplyr')
starwars
```

---

# Файлы с разделителем

__CSV (Comma-separated value)__ --- общее название для формата представления таблиц в виде текстовых файлов, организованных по следующему принципу:

1. Каждая строка в файле соответствует строке в таблице.
2. Ячейки отделяются друг от друга символом-разделителем.
3. Если ячейка пустая, то между соседними разделителями не должно быть никаких символов.

Стандартным разделителем ячеек является запятая (`,`), а десятичным разделителем --- точка (`.`). Однако это не является строгим правилом. Например, в ряде локалей (например, русской) запятая используется в качестве десятичного разделителя, поэтому колонки часто разделяют точкой с запятой (`;`).

Формат CSV никак не оговаривает наличие заголовочной строки с названиями столбцов в начале файла — она может как отсутствовать, так и присутствовать. Поэтому при чтении таблиц из файлов необходимо информировать программу о наличии заголовка путем указания соответствующего параметра.

---

# Файлы с разделителем

Например, вот так выглядит текстовая таблица в формате CSV с данными по численности населения в Федеральных округах Российской Федерации за 2005 и 2010-2013 гг. (по данным Росстата):
```
N,Region,Year05,Year10,Year11,Year12,Year13
1,Центральный,4341,3761,3613,3651,3570
2,Северо-Западный,3192,3088,2866,2877,2796
3,Южный федеральный,1409,1446,1436,1394,1321
4,Северо-Кавказский,496,390,397,395,374
5,Приволжский,3162,2883,2857,2854,2849
6,Уральский,1681,1860,1834,1665,1624
7,Сибирский,2575,2218,2142,2077,1941
8,Дальневосточный,871,870,821,765,713
```

---

# Файлы с разделителем

Таблицы в формате __CSV__ можно прочесть как с помощью стандартных средств языка R, так и с помощью пакета `readr`, который входит в набор пакетов _tidyverse_.

Для чтения таблиц с разделителем в readr имеется несколько функций:

- `read_csv()` читает файлы с разделителем запятой
- `read_csv2()` читайт файлы с разделителем точкой-с-запятой (может быть особенно актуально для русских файлов)
- `read_tsv()` читает файлы с разделителем табуляцией или пробелом
- `read_delim()` читает файлы с произвольным разделителем (указывается в качестве параметра)

---

# Файлы с разделителем

```{r}
library(readr)
(okruga = read_csv('data/okruga.csv'))
```

---

# Файлы с фиксированной шириной столбца

```
           1   43.500000       28.000000       111.05298       178.41447    
           2   43.500000       28.500000       187.38620       301.05331    
           3   44.000000       28.500000       168.82031       271.22421    
           4   44.500000       28.500000       157.22586       252.59746    
           5   44.500000       29.000000       189.46452       304.39597    
           6   45.000000       29.000000       170.40709       273.77536    
           7   45.000000       29.500000       198.92389       319.58777    
           8   45.500000       29.500000       188.64406       303.07242    
           9   46.000000       30.000000       180.10541       289.35379    
          10   46.000000       30.500000       207.91818       334.03564
```

Для чтения таких файлов в __readr__ есть функции:

- `read_fwf()` читает файлы с фиксированной шириной столбца, позволяя задавать ширины столбцов (через `fwf_widths()`) или начальные позиции каждого столбца (через `fwf_positions()`)
- `read_table()` читает наиболее распространенный вариант файла с фиксированной шириной столбца, в котором колонки разделены пробелами. Позиции столбцов определяются автоматически, что очень удобно.

---

# Файлы с фиксированной шириной столбца

```{r}
(wenergy = read_table('data/wind_energy.txt', col_names = c('id', 'lat', 'lon', 'energy50', 'energy110')))
```

---

# Таблицы Microsoft Excel

Можно рекомендовать пользоваться пакетом __readxl__, поскольку он не имеет внешних зависимостей, а его функции концептуально идентичны функциям пакета __readr__. 

Прочтем данные о лесовосстановлении (в тысяч га), полученные из регионального ежегодника Росстата за 2017 год:
```{r}
library(readxl)
(reforest = read_excel('data/reforest.xlsx', 
                       col_types = c('text', rep('numeric', 8))))
```

---

# Параметры

Функции пакетов `readr` и `readxl` имеют идентичный набор параметров, позволяющих управлять процедурой чтения данных (многоточие используется вместо перечисления параметров):

- `skip = n` позволяет пропустить первые n строк таблицы (например, если в них содержатся какие-то комментарии)
- `col_names = FALSE` позволяет не интерпретировать первую строку как заголовочную (вместо этого она будет читаться как строка с данными)
- `col_names = c(...)` позволяет задать имена столбцов (удобно, если в файле они длинные)
- `col_types = cols(...)` позволяет задать типы столбцов (необходимо, если функция неправильно определяет их сама)
- `na = '-'` позволяет указать символ, который используется для указания пропущенных значений (в данном случае указан прочерк-дефис)
- `locale = locale(...)` управляет локалью (в том числе позволяет указать кодировку файла)

> По умолчанию файлы читаются в той кодировке, которая соответствует операционной системе, на которой запущен R.

---

# Просмотр

Для просмотра фрейма данных в консоли __RStudio__ вы можете использовать несколько опций. Пусть наш фрейм данных называется `reforest`. Тогда:

1. `print(reforest)` --- выводит фрейм в консоль целиком (можно написать просто `tab` в консоли).
2. `head(reforest, n)` --- отбирает первые $n$ строк фрейма 
3. `tail(reforest, n)` --- отбирает последние $n$ строк фрейма

По умолчанию для функций `head()` и `tail()` $n=6$. Обычно этот параметр опускают, поскольку нужно просмотреть только первые несколько строк и шести вполне достаточно. Если вы напечатаете в консоли `head(reforest)` или `tail(reforest)`, то для выбранных строк будет вызвана функция `print()`, аналогично выводу всего фрейма.

---

# Просмотр

```{r, collapse=TRUE}
head(reforest)
tail(reforest)
```

---

# Функция __View()__

`RStudio` предоставляет графический интерфейс для просмотра таблиц, в котором таблицу можно сортировать и фильтровать:
```{r, eval = FALSE, collapse=TRUE}
View(tab)
```

Поскольку функции `head()` и `tail()` возвращают строки с хвоста или начала фрейма данных, их можно и подать на вход функции `View()`:

```{r, eval = FALSE, collapse=TRUE}
View(head(reforest, 3))
```

> __Как правило, не следует оставлять вызовы функции `View()` в тексте законченной программы.__ Используйте `View()` для вывода окончательного результата в конце программы или при отладке программы.

---

# Названия

Столбцы и строки таблицы имеют названия, которые можно читать и записывать с помощью функций `colnames()` и `rownames()`:
```{r}
# Чтение названий столбцов и строк
colnames(okruga)
rownames(okruga)

# Замена названий столбцов и строк
colnames(okruga) <- c("N", "Region", "Year05", "Year10", "Year11", "Year12", "Year13")
print(okruga)
```

Названия строк редко заменяются, поскольку с точки зрения реляционной алгебры большого смысла они не имеют.

---

# Обращение к столбцам

Тип возвращаемого значения зависит от синтаксиса:

- обращение через `$` возвращает вектор;
- обращение в скобках с запятой к одному столбцу возвращает вектор;
- обращение в скобках с запятой к нескольким столбцам возвращает фрейм данных;
- обращение в скобках без запятой возвращает фрейм данных.

Несколько примеров:
```{r, eval=FALSE, collapse=TRUE}
# Один столбец - результат зависит от запятой
okruga$Year05      # столбец в виде вектора
okruga[, "Year05"] # столбец в виде вектора
okruga[, 2]        # столбец в виде вектора

okruga["Year05"] # столбец в виде фрейма данных/тиббла
okruga[2]        # столбец в виде фрейма данных/тиббла

# Несколько столбцов - всегда фрейм данных/тиббл
okruga[, c(1, 4)]
okruga[, c("Region", "Year11")]
okruga[c("Region", "Year11")]
okruga[c(1, 4)]
```

---

# Обращение к строкам

Обращаться к строкам можно по их номерам. В этом случае в качестве индекса можно передать номер (номера) интересующих строк, либо вектор логических значений, в котором интересующие строки помечены как TRUE, а остальные — FALSE (в этом случае длина вектора должна равняться количеству строк в таблице):
```{r, eval=FALSE}
okruga[5, ] # Одна строка
okruga[2:4, ] # Несколько строк
okruga[okruga$Year10 > 2000, ] # Несколько строк через TRUE/FALSE
```
> В отличие от работы со столбцами, выбор строк всегда возвращает таблицу (фрейм или тиббл).

---

# Обращение к ячейкам

Чтобы выбрать конкретные ячейки в таблице, необходимо задать оба измерения:
```{r}
okruga[2:3, c("Year11", "Year12")]
```

Обратите внимание на то, что при этом возвращаются все комбинации строк и столбцов. То есть, нельзя выбрать ячейки `2,"Year11"` и `3,"Year2"` --- вместе с ними также будут выбраны ячейки `3,"Year11"` и `2,"Year2"`.

---

# Грамматика манипуляций

К основным манипуляциям относятся _выбор переменных, фильтрация строк, сортировка, вычисление новых столбцов, агрегирующие статистики и группировка_. 

Эти средства предоставляет пакет [__dplyr__](https://dplyr.tidyverse.org) (произносится как _deep liar_ — 'диплáйер'), входящий в набор инструментов [tidyverse](https://www.tidyverse.org):

Функция       | Назначение
--------------|-----------------
`select()`    | Выбор переменных
`filter()`    | Выбор строк (фильтрация)
`arrange()`   | Упорядочение строк
`mutate()`    | Добавление и изменение переменных (мутирование)
`summarise()` | Агрегирование значений переменных
`group_by()`  | Группировка строк (для последующего агрегирования)

> Названия столбцов в функциях __dplyr__ указываются без кавычек, что позволяет сделать код проще и читаемее

---

# Грамматика манипуляций

Рассмотрим применение этих функций на примере работы с таблицей по восстановлению лесного фонда в регионах России. 

Для начала переименуем столбцы с годами, чтобы их названия начинались с буквы `y`:
```{r}
old_names = colnames(reforest)
colnames(reforest) = c(old_names[1], paste('y', old_names[2:9], sep = ''))
library(dplyr)
```

---

# Выбор переменных

Начнем с __выбора__ нужных переменных, используя `select()`. Оставим только название региона и данные за 2010 и 2015 гг:
```{r}
(rdf = select(reforest, Region, y2010, y2015))
```

---

# Выбор переменных

Ту же самую задачу можно решить от противного — указать со знаком `-` те столбцы, которые надо убрать:
```{r}
(rdf = select(reforest, -y2005, -y2011:-y2014, -y2016))
```
Обратите внимание на то, что можно указывать еще и диапазоны названий столбцов, если они идут друг за другом.

---

# Выбор строк (фильтрация)

Чтобы осуществить __фильтрацию__, необходимо задать условие, накладываемое на строки. 

Выполним фильтрацию таблицы, убрав строки, в которых содержатся слова `Федерация` и `федеральный округ`. Для этого используем функцию `str_detect()` из пакета __stringr__, который также входит в _tidyverse_:
```{r}
flt = !stringr::str_detect(rdf$Region, 'Федерация|федеральный округ') # готовим фильтр для строк
(regdf = filter(rdf, flt)) # применяем фильтр
```

---

# Выбор строк (фильтрация)

Условие можно прописать непосредственно при вызове `filter()`. 

Например, выберем регионы, в которых объем лесовосстановительных работ в 2015 году был более 50 тыс. га:
```{r}
filter(regdf, y2015 > 50)
```

---

# Сортировка

Для __сортировки__ таблицы используется `arrange()`:
```{r}
arrange(regdf, y2015) # по возрастанию
```

---

# Сортировка

Для __сортировки__ по убыванию надо отправить соответствующую переменную в функцию `desc()`:
```{r}
arrange(regdf, desc(y2015)) # по убыванию
```

---

# Добавление или изменение переменных (мутирование)

__Добавление__ новых переменных (столбцов) и изменение существующих осуществляется посредством `mutate()`. 

Например, определим, как изменился объем лесовосстановительных работ в 2015 году по сравнению с 2010 годом:
```{r}
(regdf = mutate(regdf, delta = y2015 - y2010))
```

---

# Добавление или изменение переменных (трансмутирование)

`transmute()` сохраняет только столбцы, указанные в параметрах. Если вы хотите просто сохранить какой-то из столбцов, то укажите его через оператор равенства:
```{r}
transmute(regdf, Region = Region, delta = y2015 - y2010) # сохраняем только Region и delta
```

---

# Агрегирование

Вы можете выполнять __агрегирование__ данных и вычислять суммы, средние значения и т.д. используя `summarise()`.

Посчитаем суммарный, минимальный и максимальный объем лесовосстановительных работ по всей стране:
```{r}
summarise(regdf, 
          sumforest = sum(y2015, na.rm = TRUE),
          minforest = min(y2015, na.rm = TRUE),
          maxforest = max(y2015, na.rm = TRUE))
```

---

# Агрегирующие функции

Как правило, `summarise()` используется в паре с агрегирующими функциями, которые берут вектор значений и возвращают одно значение. К таким функциям относятся стандартные операции типа `min()`, `max()`, `mean()`, `sum()` и т.д.

В пакете __dplyr__ также имеются полезные агрегирующие функции:

- `n()` вычисляет количество элементов.
- `n_distinct()` вычисляет количество уникальных элементов.
- `first(x)`, `last(x)` и `nth(x, n)` извлекают, соответственно, первый, последний и n-ный элемент (они бывают особенно удобны, если вы сортируете строки по какому-то критерию). 

---

# Группировка

Достаточно часто данные надо агрегировать не по всей таблице, а __по группам__ измерений. 

В этом случае сначала делается группировка, затем агрегирование данных в каждой группе. 

Предположим, что нам нужно найти регион с наибольшим объемом лесовосставновительных работ в каждом Федеральном округе. Для этого нам потребуется:

1. Дополнить каждую строку региона информацией о принадлежности к федеральному округу
1. Сгруппировать субъекты по федеральным округам
1. Отсортировать каждую группу по убыванию значения поля
1. Взять первую строку в каждой группе
1. Объединить строки в одну таблицу

---

# Группировка

Создадим столбец с информацией о принадлежности субъектов к федеральным округам для последующей группировки. 
```{r}
flt2 = stringr::str_detect(rdf$Region, 'федеральный округ') # ищем округа
(rdf2 = mutate(rdf, okrug = if_else(flt2, Region, NULL))) # перенесем названия округов в новый столбец
```

---

# Группировка

Теперь нам поможет функция `fill()` из пакета __tidyr__:
```{r}
(rdf2 = tidyr::fill(rdf2, okrug)) # заполним все пустые строчки предыдущим значением
```

---

# Группировка

Оставим только регионы:
```{r}
(regdf = filter(rdf2, flt)) # оставим только регионы
```

---

# Группировка

Теперь мы можем определить регион с максимальным объемом лесовосстановительных работ в каждом Федеральном округе, используя вспомогательную функцию `row_number()` которая возвращает номер для каждой строки таблицы:
```{r}
regdf_gr = group_by(regdf, okrug)
regdf_arr = arrange(regdf_gr, desc(y2015))
(regdf_res = filter(regdf_arr, row_number() == 1))
```

---

# Группировка

`group_by()` часто используется в паре с `summarise()`. Например мы можем получить суммарный объем лесовосстановительных работ по каждому федеральному округу:
```{r}
regdf_gr = group_by(regdf, okrug)
summarise(regdf_gr, total = sum(y2015, na.rm = TRUE))
```

---

# Конвейер манипуляций

 __Пайп-оператор `%>%`__ предназначен для компактной и наглядной записи _последовательностей_ обработки данных. Работает он следующим образом:

 - `x %>% f` эквивалентно `f(x)`
 - `x %>% f(y)` эквивалентно `f(x, y)`
 - `x %>% f %>% g %>% h` эквивалентно `h(g(f(x)))`

Организация конвейера манипуляций с использованием пайп-оператора позволяет:

- упорядочить операции по обработке данных слева направо (в противоположность направлению изнутри наружу);
- избежать вложенных вызовов функций (матрёшки);
- минимизировать количество переменных для храненния промежуточных результатов;
- упростить добавление новых операций по обработке данных в любое место последовательности.

> __Пайп-оператор `%>%` можно быстро набрать в RStudio__, нажав клавиатурное сочетание <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>M</kbd> (<kbd>Cmd</kbd> + <kbd>Shift</kbd> + <kbd>M</kbd> на помпьютерах Mac)

---

# Конвейер манипуляций

С помощью пайп-оператора код по нахождению региона-лидера можно записать так:
```{r, collapse=TRUE}
regdf = rdf %>% 
  mutate(okrug = if_else(flt2, Region, NULL)) %>% 
  tidyr::fill(okrug) %>% 
  filter(flt)

leaders = regdf %>% 
  group_by(okrug) %>% 
  arrange(desc(y2015)) %>% 
  filter(row_number() == 1)

print(leaders)
```

---

# Традиционная запись

```{r, collapse=TRUE}
regdf = filter(
           tidyr::fill(
             mutate(
               rdf,
               okrug = if_else(flt2, Region, NULL)
             ),
             okrug
           ),
           flt
         )

result = filter(
           arrange(
             group_by(
               regdf, 
               okrug
             ),
             desc(y2015)
           ),
           row_number() == 1
         )

```

---

# Преобразование структуры

Аккуратные данные ([__tidy data__](https://www.jstatsoft.org/article/view/v059i10)) отвечают следующим требованиям:

1. Каждый столбец представляет переменную
2. Каждая строка представляет измерение
3. Каждая ячейка представляет значение

Приведение таблицы к аккуратному виду можно сделать, используя функции из пакета [__tidyr__](https://tidyr.tidyverse.org). Основных функций в этом пакете всего две:

- `gather()` берет несколько колонок и преобразует их к виду «ключ---значение»: широкие таблицы становятся длинными.
- `spread()` берет две колонки, соответствующие ключу и значению, и распределяет их на множество колонок: длинные таблицы становятся широкими.

Помимо этого, есть еще 2 полезных функции, которые позволяют «распиливать» или «склеивать» колонки:

- `separate()` разделяет колонку на несколько колонок, используя заданный символ-разделитель или позицию.
- `unite()` скливает несколько колонок, используя заданный символ-разделитель.

---

# Преобразование структуры

Рассмотрим на примере таблицы _reforest_ по лесовосстановленю в регионах России приведение к аккуратному виду:
```{r}
library(tidyr)
(reforest_tidy = reforest %>% gather(year, value, y2005:y2016))
```

---

# Преобразование структуры

Осталось избавиться от буквы `y` перед каждым годом — для этого можно использовать `separate()`, `select()` и `mutate()` :
```{r}
(reforest_tidy = reforest_tidy %>% 
  separate(year, c('y', 'year'), 1) %>% 
  select(-y) %>% 
  mutate(year = as.integer(year)))
```

---

# Преобразование структуры

Теперь можно выполнять любые запросы, комбинирующие год измерения и величину показателя:
```{r}
reforest_tidy %>% filter(year > 2011 & year < 2016 & value == 0)
  
```

---

# Преобразование структуры

В некоторых случая бывает удобно распределить переменную по нескольким колонкам. В частности, это может быть удобно, если нам надо вычислить разности между годами. Для этого используем `spread()`:
```{r}
(reforest = reforest_tidy %>% spread(year, value))
```

---

# Преобразование структуры

Теперь вычислим разности по сравнению с предыдущим годом:
```{r}
diffs = reforest %>% select(`2011`:`2016`) -
        reforest %>% select(`2010`:`2015`)

diffs %>% 
  mutate(Region = reforest$Region) %>% 
  select(Region, `2011`:`2016`) %>% 
  head() # Посмотрим шапку таблицы
```

---

# Соединение

В процессе __соединения__ в обеих таблицах находятся строки, соответствующие одному и тому же измерению (например, региону). 

Чтобы найти соответствие, в обеих таблицах должен быть по крайней мере один столбец, идентифицирующий каждую строку. В первой таблице он называется __первичным ключом__ _(primary key)_, во второй таблице --- __внешним ключом__ _(foreign key)_.

---

# Соединение в __dplyr__

_Мутирующее соединение:_

- `inner_join(x, y, by = )` возвращает все строки из `x`, для которых имеются соответствующие строки в `y`, а также все столбцы из `x` и `y`.
- `left_join(x, y, by = )` возвращает все строки из `x`, а также все столбцы из `x` и `y`. Строки в `x`, для которых не найдены соответствия в `y`, будут иметь значения `NA` в присоединенных столбцах
- `right_join(x, y, by = )` возвращает все строки из `y`, а также все столбцы из `x` и `y`. Строки в `y`, для которых не найдены соответствия в `x`, будут иметь значения `NA` в присоединенных столбцах
- `full_join(x, y, by = )` возвращает все строки и колонки из `x` и `y`. В строках, для которых не найдено соответствие ячейки присоединяемых столбцов будут заполнены значениями `NA`

_Фильтрующее соединение:_

- `semi_join(x, y, by = )` возвращает все строки из `x`, для которых имеются соответствующие строки в `y`, а также все столбцы из `x`
- `anti_join(x, y, by = )` возвращает все строки из `x`, для которых _не_ найдены соответствующие строки в `y`, а также все столбцы из `x`

---

# Соединение

Рассмотрим соединение таблиц на примере данных по лесовосстановлению и заготовкам древесины. Подгрузим таблицу по лесозаготовкам:
```{r}
(timber = read_excel('data/timber.xlsx', 
                    col_types = c('text', rep('numeric', 8))) %>% 
  filter(!stringr::str_detect(Регион, 'Федерация|федеральный округ')))
```

---

# Соединение

Приведем ее к аккуратному виду, который соответствует виду таблицы по лесовосстановлению:
```{r}
(timber_tidy = timber %>% 
  gather(year, harvest, `2010`:`2016`) %>% 
  transmute(Region = Регион,
            year = as.numeric(year),
            harvest = harvest))
```

---

# Соединение

Теперь нам осталось присоединить данные по лесозаготовкам к таблице по лесовосстановлению, используя имя региона (`Region`) и год (`year`) в качестве ключевых полей:
```{r}
(compare = reforest_tidy %>% 
  inner_join(timber_tidy, by = c("Region" = "Region", "year" = "year")))
```

---

# Соединение

Наконец, вычислим искомое отношение и упорядочим регионы:
```{r}
(compare = compare %>% 
   mutate(ratio = 1000 * value / harvest) %>% 
   select(Region, year, ratio, value, harvest) %>% 
   arrange(year, desc(ratio)))
```

---

# Запись

Запись файлов _в текстовом формате_ можно осуществить посредством функций из пакета __readr__, таких как `write_delim()`, `write_csv()` и `write_tsv()`. Базовый синтаксис их предельно прост:
```{r}
write_csv(compare, "data/output/timber_compare.csv")
```

Для записи таблиц _Microsoft Excel_ можно использовать возможности пакета [__writexl__](https://cran.r-project.org/web/packages/writexl/index.html):
```{r}
library(writexl)
write_xlsx(compare, "data/output/timber_compare.xlsx")
```

Каждая из этих функций содержит ряд дополнительных параметров, позволяющих управлять внешним видом выгружаемых таблиц. Более подробно с ними вы можете ознакомиться, вызвав справку для соответствующей функции.

---

# Рекомендации по подготовке таблиц для чтения в R

1. В первой строке таблицы должны располагаться названия столбцов.
1. Во второй строке таблицы должны начинаться данные. Не допускайте многострочных заголовков.
1. В названиях столбцов недопустимы объединенные ячейки, покрывающие несколько столбцов. Это может привести к неверному подсчету количества столбцов и, как следствие, некорректному чтению таблицы в целом.
1. Названия столбцов должны состоять из латинских букв и цифр, начинаться с буквы и не содержать пробелов. Сложносочиненные названия выделяйте прописными буквами. Плохое название столбца: `Валовый внутренний продукт за 2015 г.`. Хорошее название столбца: `GDP2015`.
1. Некоторые ошибки данных в таблицах (такие как неверные десятичные разделители), проще найти и исправить в табличном/текстовом редакторе, нежели после загрузки в __R__.

> Следование этим правилам значительно облегчит работу с табличными данными в среде __R__.