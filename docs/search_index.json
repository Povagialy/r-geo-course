[
["thematic-mapping-new.html", "Глава 10 Тематические карты в R Предварительные условия 10.1 Введение 10.2 Способы изображения 10.3 Цветовые шкалы 10.4 Классификация 10.5 Компоновка 10.6 Фасеты и серии карт 10.7 Картографические анимации 10.8 Интерактивные карты 10.9 Контрольные вопросы и упражнения", " Глава 10 Тематические карты в R Предварительные условия Для выполнения кода данной лекции вам понадобятся следующие пакеты: library(sf) library(tmap) library(readxl) library(raster) library(mapview) library(classInt) library(gapminder) library(tidyverse) library(googlesheets) library(rnaturalearth) 10.1 Введение Тематические карты представляют собой важный инструмент географических исследований. Таблицы и графики не дают полного представления о пространственном распределении изучаемого явления. Это знание способна дать исследователю карта. Разнообразие типов и видов карт достаточно велико. Комплексные картографические произведения, содержащие многослойный набор объектов, создаются, как правило, средствами геоинформационных пакетов. Такие карты требуют тщательной и кропотливой работы с легендой, устранения графических конфликтов между знаками, многократного редактирования входных данных, условий, фильтров и способов изображения в попытке достичь эстетичного и вместе с тем информативного результата. В то же время, гораздо большее количество создаваемых в повседневной практике карт носят простой аналитический характер. Такие карты показывают одно, максимум два явления, и могут иллюстрировать входные данные, результаты промежуточных или итоговых расчетов. Создание именно таких карт целесообразно автоматизировать средствами программирования. В этом разделе мы познакомимся с созданием тематических карт средствами пакета tmap. В качестве источника открытых данных мы будем использовать Natural Earth и WorldClim. 10.1.1 Данные Natural Earth Natural Earth — это открытые мелкомасштабные картографические данные высокого качества. Данные доступны для трех масштабов: 1:10М, 1:50М и 1:110М. Для доступа к этим данным из среды R без загрузки исходных файлов можно использовать пакет rnaturalearth. Пакет позволяет выгружать данные из внешнего репозитория, а также содержит три предзакачанных слоя: ne_countries() границы стран ne_states() границы единиц АТД 1 порядка ne_coastline() береговая линия Для загрузки других слоев необходимо использовать функцию ne_download(), передав ей масштаб, название слоя и его категорию: countries = ne_countries() %&gt;% st_as_sf() coast = ne_coastline() %&gt;% st_as_sf() ocean = ne_download(scale = 110, type = &#39;ocean&#39;, category = &#39;physical&#39;) %&gt;% st_as_sf() ## OGR data source with driver: ESRI Shapefile ## Source: &quot;/private/var/folders/h1/_pw8qgdd6y7gy251_ttnq8240000gn/T/Rtmplt8FkN&quot;, layer: &quot;ne_110m_ocean&quot; ## with 2 features ## It has 3 fields cities = ne_download(scale = 110, type = &#39;populated_places&#39;, category = &#39;cultural&#39;) %&gt;% st_as_sf() ## OGR data source with driver: ESRI Shapefile ## Source: &quot;/private/var/folders/h1/_pw8qgdd6y7gy251_ttnq8240000gn/T/Rtmplt8FkN&quot;, layer: &quot;ne_110m_populated_places&quot; ## with 243 features ## It has 119 fields ## Integer64 fields read as strings: wof_id ne_id rivers = ne_download(scale = 110, type = &#39;rivers_lake_centerlines&#39;, category = &#39;physical&#39;) %&gt;% st_as_sf() ## OGR data source with driver: ESRI Shapefile ## Source: &quot;/private/var/folders/h1/_pw8qgdd6y7gy251_ttnq8240000gn/T/Rtmplt8FkN&quot;, layer: &quot;ne_110m_rivers_lake_centerlines&quot; ## with 13 features ## It has 31 fields ## Integer64 fields read as strings: scalerank ne_id Познакомимся с загруженными данными: plot(ocean %&gt;% st_geometry(), col = &#39;lightblue&#39;) plot(countries, col = &#39;white&#39;, border = &#39;grey&#39;, add = TRUE) plot(coast, add = TRUE, col = &#39;steelblue&#39;) plot(rivers, add = TRUE, col = &#39;steelblue&#39;) plot(cities, add = TRUE, col = &#39;black&#39;, pch = 19, cex = 0.2) Перед построением карт мира данные целесообразно спроецировать. Чтобы не трансформировать каждый слой отдельно, можно объединить слои в список и воспользоваться функционалом lapply для множественного трансформирования. Для создания списка воспользуемся функцией lst() из пакета tibble, которая присваивает компонентам списка имена, соответствующие названиям входных переменных (чтобы не писать ocean = ocean): lyr = tibble::lst(ocean, coast, countries, rivers, cities) lyrp = lapply(lyr, st_transform, crs = &quot;+proj=eck3&quot;) # Псевдоцилиндрическая проекция Эккерта plot(lyrp$countries %&gt;% st_geometry(), col = &#39;white&#39;, border = &#39;grey&#39;, lwd = 0.5) plot(lyrp$ocean , col = &#39;lightblue&#39;, lwd = 0.5, border = &#39;steelblue&#39;, add = TRUE) plot(lyrp$rivers, add = TRUE, lwd = 0.5, col = &#39;steelblue&#39;) plot(lyrp$cities, add = TRUE, col = &#39;black&#39;, pch = 19, cex = 0.1) 10.1.2 Данные WorldClim WorldClim — это открытые сеточные наборы климатических характеристик с пространственным разрешением от \\(30&#39;&#39;\\) (около 1 км) до \\(10&#39;\\) (около 20 км). Данные можно выгрузить в виде файлов GeoTiff, однако эту операцию можно сделать и программным путем через пакет raster — используя функцию getData(). Выполним загрузку 10-минутного растра с суммарным количеством осадков за год: prec = getData(&quot;worldclim&quot;, var = &quot;prec&quot;, res = 10) plot(prec, nc = 2) # это 12-канальный растр Использовать программную загрузку целесообразно для небольших наборов данных. Если счет пошел на десятки мегабайт и выше, следует все-таки выкачать данные в виде файла и работать с ним. Выполним трансформирование данных в проекцию Миллера. Для того чтобы карта не обрезалась по охвату растра (он не включает данные на Антарктиду), необходимо расширить его охват на весь земной шар. Для этого используем функцию extend() из пакета raster: precm = prec %&gt;% extend(extent(-180, 180, -90, 90)) %&gt;% projectRaster(crs = &quot;+proj=mill&quot;) lyrm = lapply(lyr, st_transform, crs = &quot;+proj=mill&quot;) # Цилиндрическая проекция Миллера Визуализируем полученные данные на карте: ramp = colorRampPalette(c(&quot;white&quot;, &quot;violetred&quot;)) # Визуализируем данные на январь: plot(precm, 1, col = ramp(10), colNA = &#39;grey&#39;, main = &#39;Количество осадков в январе, мм&#39;, box = FALSE, axes = FALSE) plot(lyrm$ocean, border = &#39;steelblue&#39;, col = &#39;lightblue&#39;, add = TRUE) 10.2 Способы изображения В этом разделе изложение сосредоточено на параметрах способов изображения. Приведение легенд и компоновки карты в аккуратный вид рассматривается далее в разделе Компоновка. Пакет tmap предоставляет простой в использовании и достаточно мощный механизм формирования тематических карт. Шаблон построения карты в этом пакете напоминает ggplot и выглядит следующим образом: tm_shape(&lt;DATA&gt;) + tm_&lt;METHOD&gt;(&lt;PARAMETERS&gt;) где: DATA - объект пространственного типа (sf, sp, stars или raster) METHOD - метод визуализации этого объекта (способ изображения) PARAMETERS - параметры метода 10.2.1 Векторные данные Для реализации качественного и количественного фона, а также картограмм используется метод tm_polygons(). Он автоматически определяет тип переменной и строит соответствующую шкалу: tm_shape(lyrp$countries) + tm_polygons(&#39;economy&#39;) + # качественная переменная tm_shape(lyrp$ocean)+ tm_fill(col = &#39;azure&#39;) + tm_borders(col = &#39;steelblue&#39;) Количественный фон или картограммы получаются при картографировании числового показателя применением той же функции tm_polygons(): (&#39;1H3nzTwbn8z4lJ5gJ_WfDgCeGEXK3PVGcNjQ_U5og8eo&#39; %&gt;% # продолжительность жизни gs_key(lookup = FALSE) %&gt;% # не используем авторизацию gs_read(ws = 1) %&gt;% rename(name = 1) %&gt;% gather(year, lifexp, -name) %&gt;% filter(year == 2016) %&gt;% left_join(read_excel(&#39;gapminder.xlsx&#39;, 2)) %&gt;% mutate(geo = stringr::str_to_upper(geo)) -&gt; lifedf) # выгружаем данные по продолжительности и сохраняем в переменную lifedf ## # A tibble: 260 x 13 ## name year lifexp geo four_regions eight_regions six_regions ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Abkh… 2016 NA &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 2 Afgh… 2016 52.7 AFG asia asia_west south_asia ## 3 Akro… 2016 NA &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 4 Alba… 2016 78.1 ALB europe europe_east europe_cen… ## 5 Alge… 2016 76.5 DZA africa africa_north middle_eas… ## 6 Amer… 2016 73 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 7 Ando… 2016 84.8 AND europe europe_west europe_cen… ## 8 Ango… 2016 60 AGO africa africa_sub_s… sub_sahara… ## 9 Angu… 2016 NA &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 10 Anti… 2016 76.5 ATG americas america_north america ## # ... with 250 more rows, and 6 more variables: members_oecd_g77 &lt;chr&gt;, ## # Latitude &lt;dbl&gt;, Longitude &lt;dbl&gt;, `UN member since` &lt;dttm&gt;, `World bank ## # region` &lt;chr&gt;, `World bank income group 2017` &lt;chr&gt; coun = lyrp$countries %&gt;% left_join(lifedf, by = c(&#39;adm0_a3&#39; = &#39;geo&#39;)) tm_shape(coun) + tm_polygons(&#39;lifexp&#39;, border.col = &#39;gray20&#39;) + # количественная переменная tm_shape(lyrp$ocean) + tm_fill(col = &#39;azure&#39;) + tm_borders(col = &#39;steelblue4&#39;) Для реализации способа картодиаграмм используется геометрия tm_bubbles(). Чтобы оставить отображение границ полигонов, нам необходимо к одной геометрии применить несколько способов изображения: tm_shape(coun) + tm_fill(col = &#39;white&#39;) + tm_borders(col = &#39;grey&#39;) + tm_bubbles(&#39;gdp_md_est&#39;, scale = 3, col = &#39;red&#39;, alpha = 0.5) + # количественная переменная tm_shape(lyrp$ocean) + tm_fill(col = &#39;lightblue&#39;) + tm_borders(col = &#39;steelblue&#39;) Аналогичным образом реализуется значковый способ применительно к объектам, локализованным по точкам. Картографируем численность населения по крупнейшим городам: tm_shape(lyrp$countries) + tm_fill(col = &#39;white&#39;) + tm_borders(col = &#39;grey&#39;) + tm_shape(lyrp$ocean) + tm_fill(col = &#39;lightblue&#39;) + tm_borders(col = &#39;steelblue&#39;) + tm_shape(lyrp$cities) + tm_bubbles(&#39;POP2015&#39;, col = &#39;olivedrab&#39;, alpha = 0.8) Надписи объектов на карте размещаются с помощью функции tm_text. Данная функция содержит весьма полезные параметры remove.overlap и auto.placement, которые позволяют убрать перекрывающиеся подписи и автоматически разместить из вокруг точек так, чтобы уменьшить перекрытия с самими знаками и другими подписями. Дополним предыдущую карту названиями городов: tm_shape(lyrp$countries) + tm_fill(col = &#39;white&#39;) + tm_borders(col = &#39;grey&#39;) + tm_shape(lyrp$ocean) + tm_fill(col = &#39;lightblue&#39;) + tm_borders(col = &#39;steelblue&#39;) + tm_shape(lyrp$cities) + tm_bubbles(&#39;POP2015&#39;, col = &#39;olivedrab&#39;, alpha = 0.8) + tm_text(&#39;name_ru&#39;, size = 0.5, remove.overlap = TRUE, auto.placement = TRUE) 10.2.2 Растровые данные При отображении растровых данных используется способ отображения tm_raster(). В случае отображения количественных растров Параметр breaks определяет границы интервалов, для которых будут использованы цвета, взятые из параметра palette: tm_shape(precm) + tm_raster(&#39;prec1&#39;, breaks = c(10, 50, 100, 200, 500, 1000), palette = ramp(5)) + tm_shape(lyrm$ocean) + tm_fill(col = &#39;lightblue&#39;) + tm_borders(col = &#39;steelblue&#39;) Растровые данные могут хранить и качественную информацию: например, тип почв или вид землепользования. В качестве примера визуализируем типы земельного покрова (land cover) из растрового стека land, который есть в пакете tmap. Цвета здесь выбираются автоматически, их настройка рассматривается в следующем параграфе: data(land, package = &#39;tmap&#39;) tm_shape(land) + tm_raster(&#39;cover&#39;) 10.3 Цветовые шкалы Для изменения цветовой шкалы при определении способа изображения вы можете определить параметр palette. Пакет tmap позволяет работать с цветовыми палитрами Color Brewer или задавать цвета вручную. Очень удобным инструментом подбора шкалы является функция palette_explorer() из пакета tmaptools. При вызове функции открывается интерактивное приложение, позволяющее менять настройки цветовых палитр: tmaptools::palette_explorer() Приложение Palette Explorer из пакета tmaptools Данных палитр хватит для решения большинства задач по картографической визуализации. Применим категориальную палитру Dark2: tm_shape(lyrp$countries) + tm_polygons(&#39;economy&#39;, palette = &#39;Dark2&#39;) + # качественная переменная tm_shape(lyrp$ocean)+ tm_fill(col = &#39;azure&#39;) + tm_borders(col = &#39;steelblue&#39;) Для количественного показателя (количество осадков) применим палитру PuBuGn: tm_shape(precm) + tm_raster(&#39;prec1&#39;, breaks = c(10, 50, 100, 200, 500, 1000), palette = &#39;PuBuGn&#39;) + tm_shape(lyrm$ocean) + tm_fill(col = &#39;lightblue&#39;) + tm_borders(col = &#39;steelblue&#39;) Вы всегда можете, конечно, определить цвета вручную. В этом случае их количество должно совпадать с количеством интервалов классификации: tm_shape(precm) + tm_raster(&#39;prec1&#39;, breaks = c(10, 50, 100, 200, 500, 1000), palette = c(&#39;white&#39;, &#39;gray80&#39;, &#39;gray60&#39;, &#39;gray40&#39;, &#39;gray20&#39;)) + tm_shape(lyrm$ocean) + tm_fill(col = &#39;lightblue&#39;) + tm_borders(col = &#39;steelblue&#39;) Для категориальных данных необходимо тщательно подбирать цвета, стандартные шкалы тут могут не подойти (более подробно о шкалах — далее). Для вышеприведенного примера с растром типов земельного покрова можно подобрать следующие цвета: pal = c(&quot;#003200&quot;, &quot;#3C9600&quot;, &quot;#006E00&quot;, &quot;#556E19&quot;, &quot;#00C800&quot;, &quot;#8CBE8C&quot;, &quot;#467864&quot;, &quot;#B4E664&quot;, &quot;#9BC832&quot;, &quot;#EBFF64&quot;, &quot;#F06432&quot;, &quot;#9132E6&quot;, &quot;#E664E6&quot;, &quot;#9B82E6&quot;, &quot;#B4FEF0&quot;, &quot;#646464&quot;, &quot;#C8C8C8&quot;, &quot;#FF0000&quot;, &quot;#FFFFFF&quot;, &quot;#5ADCDC&quot;) tm_shape(land) + tm_raster(&#39;cover&#39;, palette = pal) 10.4 Классификация 10.4.1 Методы классификации Классификация данных — важнейший этап картографирования, который во многом определяет, как данные будут представлены на карте и какие географические выводы читатель сделает на ее основе. Существует множество методов классификации числовых рядов. Классифицировать данные автоматически можно с помощью функции classIntervals() из пакета classInt. Наберите в консоли ?classInt чтобы прочитать справку о методах классификации. Посмотрим несколько методов классификации. Первый параметр функции classInt — это числовой ряд. Число классов следует передать в параметр n =, метод классификации указывается в параметре style =. Для начала попробуем метод равных интервалов, который просто делит размах вариации (диапазон от минимума до максимум) на \\(n\\) равных интервалов. Функция plot() применительно к созданной классификации рисует замечательный график, на котором показаны границы классов и эмпирическая функция распределения показателя. В параметр pal можно передать цветовую палитру: # Запишем число классов в переменную nclasses = 5 intervals = classIntervals(coun$lifexp, n = nclasses, style = &quot;equal&quot;) # извлечь полученные границы можно через $brks intervals$brks ## [1] 48.860 55.748 62.636 69.524 76.412 83.300 plot(intervals, pal = ramp(nclasses), cex=0.5, main = &quot;Равные интервалы MIN/MAX&quot;) Созданные интервалы хоть и равны, но не аккуратны. Зато метод классификации &quot;pretty&quot; создает также равные интервалы, но может слегка расширить диапазон или добавить 1 класс, чтобы получить границы интервалов, округленные до целых чисел: intervals = classIntervals(coun$lifexp, n = nclasses, style = &quot;pretty&quot;) intervals$brks ## [1] 45 50 55 60 65 70 75 80 85 plot(intervals, pal = ramp(nclasses), cex=0.5, main = &quot;Округленные равные интервалы&quot;) Квантили — равноколичественные интервалы. В каждом классе содержится одинаковое число объектов: intervals = classIntervals(coun$lifexp, n = nclasses, style = &quot;quantile&quot;) intervals$brks ## [1] 48.860 64.488 71.300 75.440 79.360 83.300 plot(intervals, pal = ramp(nclasses), cex=0.5, main = &quot;Квантили (равноколичественные)&quot;) Метод “естественных интервалов”, или метод Фишера-Дженкса позволяет найти классы, максимально однородные внутри и при этом максимально отличающиеся друг от друга: intervals = classIntervals(coun$lifexp, n = nclasses, style = &quot;jenks&quot;) intervals$brks ## [1] 48.86 55.90 63.70 70.40 77.10 83.30 plot(intervals, pal = ramp(nclasses), cex=0.5, main = &quot;Естественные интервалы&quot;) 10.4.2 Применение на картах Чтобы использовать заранее вычисленные интервалы классификации, их необходимо подать в параметр breaks при построении карты: brks = classIntervals(coun$lifexp, n = 4, style = &quot;pretty&quot;)$brks tm_shape(coun) + tm_polygons(&#39;lifexp&#39;, border.col = &#39;gray20&#39;, palette = &#39;YlGn&#39;, breaks = brks) + # количественная переменная tm_shape(lyrp$ocean) + tm_fill(col = &#39;azure&#39;) + tm_borders(col = &#39;steelblue4&#39;) Аналогичным путем работают шкалы для растровых данных: tm_shape(precm) + tm_raster(&#39;prec1&#39;, breaks = classIntervals(values(precm), n = 5, style = &quot;quantile&quot;)$brks, palette = &#39;PuBuGn&#39;) + tm_shape(lyrm$ocean) + tm_fill(col = &#39;lightblue&#39;) + tm_borders(col = &#39;steelblue&#39;) Учтите, что метод естественных интервалов — ресурсоемкий в вычислительном плане. Поэтому если вы хотите с его помощью классифицировать растровые данные, целесообразно сделать выборку не более чем из нескольких тысяч пикселов. Иначе придется долго ждать. Для классификации естественными интервалами сделаем выборку в 2 000 значений с растра c помощью функции sampleRandom() из пакета raster: smpl = sampleRandom(precm$prec1, size = 2000) tm_shape(precm) + tm_raster(&#39;prec1&#39;, breaks = classIntervals(smpl, n = 5, style = &quot;jenks&quot;)$brks, palette = &#39;PuBuGn&#39;) + tm_shape(lyrm$ocean) + tm_fill(col = &#39;lightblue&#39;) + tm_borders(col = &#39;steelblue&#39;) 10.4.3 Классификация при отображении Пакет tmap позволяет выполнять классификацию данных непосредственно при отображении. Это бывает удобно, когда одну и ту же классификацию не надо использовать несколько раз, и когда нет необходимости делать выборку значений (как в случае метода естественных интервалов). Для этого функции способов изображения предлагают несколько параметров: n — количество классов style — метод классификации (так же как и в classIntervals()) breaks — значения границ интервалов (необходимы, если style == fixed) interval.closure — замыкание интервала (по умолчанию стоит left, что означает, что в интервал включается нижняя граница, за исключением последнего интервала, включающего и нижнюю и верхнюю границу) midpoint — нейтральное значение, которое используется для сопоставления с центральным цветом в расходящихся цветовых палитрах Построим карту продолжительности жизни, используя классификацию при отображении: tm_shape(coun) + tm_polygons(&#39;lifexp&#39;, palette = &#39;YlGn&#39;, n = 5, style = &#39;fisher&#39;, border.col = &#39;gray20&#39;) + # количественная переменная tm_shape(lyrp$ocean) + tm_fill(col = &#39;azure&#39;) + tm_borders(col = &#39;steelblue4&#39;) Установка средней точки при классификации оказывается очень полезной в тех случаях, когда данные являются биполярными. Покажем это на примере данных WorldClim по температуре: temp = getData(&quot;worldclim&quot;, var = &quot;tmean&quot;, res = 10) %&gt;% extend(extent(-180, 180, -90, 90)) %&gt;% projectRaster(crs = &quot;+proj=mill&quot;) / 10 # не забываем поделить результат на 10, # так как данные хранятся в виде цедых чисел! Визуализируем данные по температуре, используя классическую красно-бело-синюю палитру RdBu и нейтральную точку 0 градусов по Цельсию. По умолчанию в данной палитре красный цвет соответствует малым значениям. пакет tmap позволяет инвертировать цвета палитры, добавив знак минус перед ее названием. Помимо этого, для размещения положительных значений наверху выполним обратную сортировку элементов легенды, используя параметр legend.reverse = TRUE: tm_shape(temp) + tm_raster(&#39;tmean1&#39;, n = 11, midpoint = 0, style = &#39;pretty&#39;, legend.reverse = TRUE, palette = &#39;-RdBu&#39;) + tm_shape(lyrm$ocean) + tm_fill(col = &#39;azure&#39;) + tm_borders(col = &#39;steelblue&#39;) 10.4.4 Пропущенные данные Весьма важно отметить на карте области, для которых данные отсутствуют. Вы могли обратить внимание, что для способов изображения, применимых к векторным данным, tmap автоматически добавляет класс легенды, который отвечает за пропуски. Для растров, однако, он это не делает. Чтобы принудительно вывести в легенду и на карту символ, отвечающий за пропущенные значения, необходимо определить параметр colorNA. Обычно, в зависимости от цветовой палитры легенды, для этого используют серый или белый цвет: tm_shape(temp) + tm_raster(&#39;tmean1&#39;, colorNA = &#39;grey&#39;, # определяем цвет для пропущенных значений n = 11, midpoint = 0, style = &#39;pretty&#39;, legend.reverse = TRUE, palette = &#39;-RdBu&#39;) + tm_shape(lyrm$ocean) + tm_fill(col = &#39;azure&#39;) + tm_borders(col = &#39;steelblue&#39;) 10.5 Компоновка Пакет tmap предоставляет широкий набор настроек компоновки картографического изображения, который включает настройку легенды, заголовка карты и ряда других важных параметров. Большинство настроек компоновки осуществляется через функцию tm_layout(), однако часть из них, специфичная для конкретного слоя, определяется непосредственно при настройке способа изображения. В примере ниже показано, как: добавить заголовок карты (main.title), разместить легенду в нижнем левом углу (legend.position = c('left', 'bottom')) поместить ее легенду в полупрозрачный прямоугольник (параметры legend&lt;...&gt;), убрать заголовок легенды (title), заменить стандартный шрифт на OpenSans (fontfamily): tm_shape(lyrp$countries) + tm_polygons(&#39;economy&#39;, title = &#39;&#39;) + # убираем заголовок легенды tm_shape(lyrp$ocean)+ tm_fill(col = &#39;azure&#39;) + tm_borders(col = &#39;steelblue&#39;) + tm_layout(legend.position = c(&#39;left&#39;, &#39;bottom&#39;), fontfamily = &#39;OpenSans&#39;, # шрифт main.title.size = 1.2, # масштаб шрифта в заголовке main.title = &#39;Тип экономики&#39;, # заголовок legend.frame = TRUE, # рамка вокруг легенды legend.frame.lwd = 0.2, # толщина рамки вокруг легенды legend.bg.alpha = 0.8, # прозрачность фона в легенде legend.bg.color = &#39;white&#39;) # цвет фона легенды Для того чтобы определить заголовок легенды размера значка или диаграммы, необходимо задать параметр title.size. Помимо этого, легенду можно пристыковать непосредственно к рамке карты, если задать значения параметра legend.position в верхнем регистре: tm_shape(coun) + tm_fill(col = &#39;white&#39;) + tm_borders(col = &#39;grey&#39;) + tm_bubbles(&#39;gdp_md_est&#39;, scale = 2.5, col = &#39;red&#39;, alpha = 0.5, title.size = &#39;$ млн&#39;) + # количественная переменная tm_shape(lyrp$ocean) + tm_fill(col = &#39;lightblue&#39;) + tm_borders(col = &#39;steelblue&#39;) + tm_layout(legend.position = c(&#39;LEFT&#39;, &#39;BOTTOM&#39;), # верхний регистр — легенда встык fontfamily = &#39;OpenSans&#39;, # шрифт main.title.size = 1.2, # масштаб шрифта в заголовке main.title = &#39;Валовый внутренний продукт стран мира&#39;, # заголовок frame.lwd = 2, legend.frame = TRUE, # рамка вокруг легенды legend.frame.lwd = 0.5, # толщина рамки вокруг легенды legend.bg.color = &#39;white&#39;) # цвет фона легенды По умолчанию tmap размещает легенду внутри фрейма картографического изображения. Однако ее можно вынести и наружу, используя параметр legend.outside функции tm_layout(). В примере ниже показано также, как можно задать текст легенды для отсутствующих данных (textNA), отформатировать разделитель в легенде с интервалами значений (legend.format), убрать рамку карты (frame), сдвинуть заголовок вдоль строки, выровняв его с центром карты (main.title.position): tm_shape(coun) + tm_polygons(&#39;lifexp&#39;, border.col = &#39;gray20&#39;, palette = &#39;YlGn&#39;, n = 4, style = &#39;jenks&#39;, title = &#39;Лет&#39;, colorNA = &#39;lightgray&#39;, textNA = &#39;Нет данных&#39;, legend.format = list(text.separator = &#39;—&#39;)) + # количественная переменная tm_shape(lyrp$ocean) + tm_fill(col = &#39;azure&#39;) + tm_borders(col = &#39;steelblue4&#39;) + tm_layout(frame = FALSE, main.title.position = 0.15, legend.outside = TRUE, legend.outside.position = &#39;right&#39;, fontfamily = &#39;OpenSans&#39;, main.title.size = 1.2, main.title = &#39;Продолжительность жизни&#39;, legend.bg.color = &#39;white&#39;) Для отображения координатной сетки вы можете использовать функцию tm_grid(). По умолчанию она строит координатную сетку в единицах измерения проекции. Однако если требуется градусная сетка, то ее можно определить, используя параметр projection = &quot;longlat&quot;: tm_shape(temp) + tm_raster(&#39;tmean1&#39;, title = &#39;°C&#39;, colorNA = &#39;grey&#39;, # определяем цвет для пропущенных значений textNA = &#39;Нет данных&#39;, legend.format = list(text.separator = &#39;—&#39;), n = 11, midpoint = 0, style = &#39;pretty&#39;, legend.reverse = TRUE, palette = &#39;-RdBu&#39;) + tm_shape(lyrm$ocean) + tm_fill(col = &#39;azure&#39;) + tm_borders(col = &#39;steelblue&#39;) + tm_layout(legend.position = c(&#39;left&#39;, &#39;bottom&#39;), fontfamily = &#39;OpenSans&#39;, main.title.size = 1.2, main.title = &#39;Средняя температура января&#39;, legend.frame = TRUE, legend.frame.lwd = 0.2, legend.bg.alpha = 0.5, legend.bg.color = &#39;white&#39;) + tm_grid(x = seq(-180, 180, by = 30), y = seq(-90, 90, by = 30), lwd = 0.2, col = &quot;black&quot;, projection = &quot;longlat&quot;, labels.inside.frame = FALSE) Если вам необходимо обеспечить значки градуса, вы можете сделать это, используя параметр labels.format, определив в нем анонимную функцию, добавляющую значок градуса в переданный ей вектор подписей. Помимо этого, вам может понадобиться увеличить поля вокруг карты, чтобы освободить пространство для размещения меток (на предыдущей карте они не влезли). Это делается через параметр outer.margins, который ожидает получить вектор из четырех значений (по умолчанию все они равны 0.02, т.е. 2% от размера окна). tm_shape(temp) + tm_raster(&#39;tmean1&#39;, title = &#39;°C&#39;, colorNA = &#39;grey&#39;, # определяем цвет для пропущенных значений textNA = &#39;Нет данных&#39;, legend.format = list(text.separator = &#39;—&#39;), n = 11, midpoint = 0, style = &#39;pretty&#39;, legend.reverse = TRUE, palette = &#39;-RdBu&#39;) + tm_shape(lyrm$ocean) + tm_fill(col = &#39;azure&#39;) + tm_borders(col = &#39;steelblue&#39;) + tm_layout(legend.position = c(&#39;LEFT&#39;, &#39;BOTTOM&#39;), fontfamily = &#39;OpenSans&#39;, main.title.size = 1.2, main.title = &#39;Средняя температура января&#39;, legend.frame = TRUE, legend.frame.lwd = 0.2, legend.bg.alpha = 0.8, legend.bg.color = &#39;white&#39;, outer.margins = c(0.05, 0.02, 0.02, 0.02), inner.margins = c(0, 0, 0, 0)) + tm_grid(x = seq(-180, 180, by = 30), y = seq(-90, 90, by = 30), lwd = 0.2, col = &quot;black&quot;, projection = &quot;longlat&quot;, labels.inside.frame = FALSE, labels.format = list(fun = function(X) paste0(X, &#39;°&#39;))) Подписи сетки координат можно добавить и для более сложных проекций, однако располагаться они будут по-прежнему вдоль осей X и Y. В примере ниже также показано как можно увеличить расстояние между заголовком и картой, определив более крупный отступ от верхней стороны в параметре inner.margins: tm_shape(coun) + tm_polygons(&#39;lifexp&#39;, palette = &#39;YlGn&#39;, n = 4, style = &#39;jenks&#39;, border.col = &#39;gray20&#39;, title = &#39;Лет&#39;, colorNA = &#39;lightgray&#39;, textNA = &#39;Нет данных&#39;, legend.reverse = TRUE, legend.format = list(text.separator = &#39;—&#39;)) + # количественная переменная tm_shape(lyrp$ocean) + tm_fill(col = &#39;azure&#39;) + tm_borders(col = &#39;steelblue4&#39;) + tm_layout(frame = FALSE, main.title.position = 0.15, legend.outside = TRUE, legend.outside.position = &#39;right&#39;, fontfamily = &#39;OpenSans&#39;, main.title.size = 1.2, main.title = &#39;Продолжительность жизни&#39;, legend.bg.color = &#39;white&#39;, outer.margins = c(0.02, 0.05, 0.02, 0.02), inner.margins = c(0.02, 0.02, 0.07, 0.02)) + tm_grid(x = seq(-180, 180, by = 60), y = seq(-90, 90, by = 30), lwd = 0.2, col = &quot;black&quot;, projection = &quot;longlat&quot;, labels.inside.frame = FALSE, labels.format = list(fun = function(X) paste0(X, &#39;°&#39;))) 10.6 Фасеты и серии карт Фасетная компоновка предполагает, упорядочение элементов в матричной форме на одной странице. Как правило, картографические фасеты идентичны по содержанию, но показывают одно и то же явление при различных заданных условиях: за разные года, по разным странам и т.д. Создание фасет с помощью tmap осуществляется с помощью специальной функции tm_facets(), которой необходимо передать название переменной, отвечающей за разделение. В свою очередь, это означает, что данные должны быть приведены к «длинной» форме (если информация за разные года содержится в разных столбцах, то нужно год записать в отдельную переменную). Здесь вам пригодится знание пакета tidyr. Рассмотрим создание фасет на примере данных Gapminder по средней продолжительности жизни c 1960 по 2010 г: (&#39;1H3nzTwbn8z4lJ5gJ_WfDgCeGEXK3PVGcNjQ_U5og8eo&#39; %&gt;% # продолжительность жизни gs_key(lookup = FALSE) %&gt;% # не используем авторизацию gs_read(ws = 1) %&gt;% rename(name = 1) %&gt;% gather(year, lifexp, -name) %&gt;% filter(year %in% c(1960, 1970, 1980, 1990, 2000, 2010)) %&gt;% left_join(read_excel(&#39;gapminder.xlsx&#39;, 2)) %&gt;% mutate(geo = stringr::str_to_upper(geo)) -&gt; lifedf2) # выгружаем данные по ВВП на душу населения и сохраняем в переменную lifedf ## # A tibble: 1,560 x 13 ## name year lifexp geo four_regions eight_regions six_regions ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Abkh… 1960 NA &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 2 Afgh… 1960 31.9 AFG asia asia_west south_asia ## 3 Akro… 1960 NA &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 4 Alba… 1960 62.9 ALB europe europe_east europe_cen… ## 5 Alge… 1960 47.5 DZA africa africa_north middle_eas… ## 6 Amer… 1960 NA &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 7 Ando… 1960 NA AND europe europe_west europe_cen… ## 8 Ango… 1960 36.0 AGO africa africa_sub_s… sub_sahara… ## 9 Angu… 1960 NA &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 10 Anti… 1960 63.0 ATG americas america_north america ## # ... with 1,550 more rows, and 6 more variables: members_oecd_g77 &lt;chr&gt;, ## # Latitude &lt;dbl&gt;, Longitude &lt;dbl&gt;, `UN member since` &lt;dttm&gt;, `World bank ## # region` &lt;chr&gt;, `World bank income group 2017` &lt;chr&gt; coun2 = lyrp$countries %&gt;% left_join(lifedf2, by = c(&#39;adm0_a3&#39; = &#39;geo&#39;)) Создадим серию карт за разные года: tm_shape(coun2) + tm_polygons(&#39;lifexp&#39;, palette = &#39;YlGnBu&#39;, n = 3, style = &#39;pretty&#39;, border.col = &#39;gray20&#39;, title = &#39;Лет&#39;, colorNA = &#39;lightgray&#39;, textNA = &#39;Нет данных&#39;, legend.reverse = TRUE, legend.format = list(text.separator = &#39;—&#39;)) + # количественная переменная tm_facets(by = &#39;year&#39;, free.coords = FALSE, drop.units = TRUE, drop.NA.facets = TRUE, ncol = 2) + tm_shape(lyrp$ocean) + tm_fill(col = &#39;azure&#39;) + tm_borders(col = &#39;steelblue4&#39;) + tm_layout(frame = FALSE, legend.outside = TRUE, legend.outside.position = &#39;bottom&#39;, fontfamily = &#39;OpenSans&#39;, main.title.size = 1.2, main.title = &#39;Средняя продолжительность жизни&#39;, legend.bg.color = &#39;white&#39;, outer.margins = c(0.02, 0.1, 0.02, 0.02), inner.margins = c(0.02, 0.02, 0.07, 0.02)) Фасетные карты по растровым данным в настоящий момент не поддерживаются в пакете tmap, но вы можете создать их, используя функцию tmap_arrange(), которая принимает на вход список из карт tmap и упорядочивает их в фасетной компоновке. В примере ниже показано, как: вычислить равноступенную шкалу, единую для всех карт — используя максимум и минимум по всем растрам из стека, а также функцию fullseq() из пакета scales, заведомо накрывающую указанный диапазон значений интервалами заданного размера. применить функционал map2()из пакета purrr (входит в tidyverse) для одновременной итерации по двум спискам: названий растров в стеке (X) и названий месяцев (Y), которые нужны для формирования заголовков упорядочить карты по регулярной сетке с двумя столбцами и полями отступа каждой фасеты (параметр outer.margins), используя tmap_arrange() minval = min(cellStats(temp, &#39;min&#39;)) maxval = max(cellStats(temp, &#39;max&#39;)) brks = scales::fullseq(c(minval, maxval), 10) months = c(&#39;Январь&#39;, &#39;Февраль&#39;, &#39;Март&#39;, &#39;Апрель&#39;, &#39;Март&#39;, &#39;Июнь&#39;, &#39;Июль&#39;, &#39;Август&#39;, &#39;Сентябрь&#39;, &#39;Октябрь&#39;, &#39;Ноябрь&#39;, &#39;Декабрь&#39;) maps = purrr::map2(names(temp), months, function(X, Y) { tm_shape(temp) + tm_raster(X, title = &#39;°C&#39;, colorNA = &#39;grey&#39;, # определяем цвет для пропущенных значений textNA = &#39;Нет данных&#39;, legend.format = list(text.separator = &#39;—&#39;), breaks = brks, midpoint = 0, style = &#39;fixed&#39;, legend.reverse = TRUE, palette = &#39;-RdBu&#39;) + tm_shape(lyrm$ocean) + tm_fill(col = &#39;azure&#39;) + tm_borders(col = &#39;steelblue&#39;) + tm_layout(legend.position = c(&#39;LEFT&#39;, &#39;BOTTOM&#39;), fontfamily = &#39;OpenSans&#39;, main.title.size = 1.2, main.title = Y, legend.frame = TRUE, legend.frame.lwd = 0.2, legend.bg.alpha = 0.8, legend.bg.color = &#39;white&#39;, inner.margins = c(0, 0, 0, 0)) + tm_grid(x = seq(-180, 180, by = 30), y = seq(-90, 90, by = 30), lwd = 0.2, col = &quot;black&quot;, projection = &quot;longlat&quot;, labels.inside.frame = FALSE, labels.format = list(fun = function(Z) paste0(Z, &#39;°&#39;))) }) tmap_arrange(maps, asp = NA, ncol = 2, outer.margins = 0.05) 10.7 Картографические анимации Картографические анимации вы пакете tmap создаются путем следующей последовательности действий: Добавить в построение карты функцию tm_facets(along = &quot;name&quot;), где name — название атрибута, значения которого отвечают за каждый кадр анимации. Записать созданную карту в переменную (условно назовем ее map). Вызвать для созданной переменной функцию tmap_animation(map, filename = &quot;filename.gif&quot;, delay = 25), определив имя файла и задержку в миллисекундах между кадрами. Внимание: для того чтобы работало построение анимаций средствами tmap, на вашем компьютере должна быть установлена библиотека ImageMagick. Для примера построим анимацию по данным изменения средней продолжительности жизни: map = tm_shape(coun2) + tm_polygons(&#39;lifexp&#39;, palette = &#39;YlGnBu&#39;, n = 3, style = &#39;pretty&#39;, border.col = &#39;gray20&#39;, title = &#39;Лет&#39;, colorNA = &#39;lightgray&#39;, textNA = &#39;Нет данных&#39;, legend.reverse = TRUE, legend.format = list(text.separator = &#39;—&#39;)) + # количественная переменная tm_facets(along = &#39;year&#39;, free.coords = FALSE, drop.units = TRUE) + tm_shape(lyrp$ocean) + tm_fill(col = &#39;azure&#39;) + tm_borders(col = &#39;steelblue4&#39;) tmap_animation(map, &#39;images/lifexp.gif&#39;, delay = 100) 10.8 Интерактивные карты Любую карту tmap можно перевести в интерактивный режим с помощью функции tmap_mode() с параметром 'view'. Управлять дополнительными параметрами, специфичными для интерактивного режима, можно используя функцию tm_view(). В частности, можно установить координаты центра карты и масштабный уровень в параметре set.view и ограничить диапазон масштабных уровней в параметре set.zoom.limits. Состав полей, значения которых отображаются во всплывающем окне при щелчке на символе, определяются параметром popup.vars: tmap_mode(&#39;view&#39;) tm_shape(coun) + tm_polygons(&#39;lifexp&#39;, border.col = &#39;gray20&#39;, palette = &#39;YlGn&#39;, n = 4, style = &#39;jenks&#39;, title = &#39;Лет&#39;, colorNA = &#39;lightgray&#39;, textNA = &#39;Нет данных&#39;, legend.format = list(text.separator = &#39;—&#39;), popup.vars = c(&#39;sovereignt&#39;, &#39;lifexp&#39;)) + # поля для всплывающего окна tm_view(set.view = c(20, 45, 2), # центр карты и масштабный уровень set.zoom.limits = c(1, 4)) Чтобы добавить карту-подложку, необходимо предварительно вызвать функцию tm_basemap(), передав ей название картографического сервиса. В примере ниже также показано, как можно сделать размер кружка постоянным во всех масштабах (параметр symbol.size.fixed): tmap_mode(&#39;view&#39;) coun = coun %&gt;% mutate(gdp_scaled = round(0.001 * gdp_md_est)) tm_basemap(&quot;OpenStreetMap&quot;) + tm_shape(coun) + tm_borders(col = &#39;black&#39;, alpha = 0.5, lwd = 0.3) + tm_shape(st_point_on_surface(coun)) + # делаем точки, чтобы диаграммы были точно внутри tm_bubbles(&#39;gdp_scaled&#39;, scale = 3, col = &#39;violetred&#39;, alpha = 0.5, popup.vars = c(&#39;sovereignt&#39;, &#39;gdp_scaled&#39;)) + tm_text(&#39;gdp_scaled&#39;, size = &#39;gdp_scaled&#39;, remove.overlap = TRUE, size.lowerbound = 0.2, scale = 2) + tm_view(set.view = c(20, 45, 3), set.zoom.limits = c(2, 4), symbol.size.fixed = TRUE, text.size.variable = TRUE) 10.9 Контрольные вопросы и упражнения 10.9.1 Вопросы Опишите шаблон построения тематической карты средствами tmap. Что из себя представляют его три основные компоненты? Могут ли на одной тематической карте комбинироваться пространственные данные в разных проекциях? Перечислите названия функций, отвечающих за отображение полигонов, линий и окружностей средствами tmap. Чему должно быть равно значение параметра col при отображении одноканального растра в случае если классификация и цвета определяются посредством параметров breaks и palette? Опишите порядок использования функции classIntervals() и ее основные параметры. Перечислите методы классификации, доступные в classIntervals(), а также принципы и работы. Какой из методов наиболее трудоемок в вычислительном плане? В каком соотношении должно быть количество граничных классов и количество цветов при классификации? График какой функции отображается при вызове функции plot() применительно к результату выполнения classIntervals()? Какие возможности существуют для применения классификации при построении карт средствами tmap? Обязательно ли заранее определять количество классов? В каком случае это может быть полезно. Как можно изменить порядок размещения элементов легенды в tmap? Опишите возможности управления расположением и внутренним форматированием легенды средствами tmap. С помощью какой функции можно построить координатную сетку на карте tmap? Как добавить значки градусов в подписи выходов сетки координат на карте tmap? Какие параметры позволяют управлять внешними и внутренними полями карты tmap? Опишите последовательность действий, которую необходимо реализовать для построения фасетной карты средствами tmap. Как можно реализовать построение таких карт на основе растровых данных? Опишите последовательность действий, которую необходимо реализовать для построения картографических анимаций средствами tmap. Какая библиотека должна быть установлена для этого на компьютере пользователя? Каким образом можно перевести отображение карт tmap в интерактивный режим? А обратно в статичный? Расскажите, что вы знаете о данных Natural Earth. На каком сайте они размещены? Сколько существует масштабных уровней? В каких форматах доступны данные? Как получить доступ к ним программным путем непосредственно из среды R? 10.9.2 Упражнения Используя возможности пакетов rnaturalearth и tmap, создайте карту мира, в которой страны раскрашены в соответствии с континентом (переменная continent). Визуализируйте ее в статичном и интерактивном режиме. Выполните выборку стран на Европейский континент. Трансформируйте данные о странах в коническую равнопромежуточную проекцию. Визуализируйте численность населения по странам (переменная pop_est) способом картодиаграмм. Добавьте на карту реки, озера и города, используя возможности ne_download(). Самсонов Т.Е. Визуализация и анализ географических данных на языке R. М.: Географический факультет МГУ, 2017. DOI: 10.5281/zenodo.901911 "]
]
