[
["index.html", "Визуализация и анализ географических данных на языке R Введение Программное обеспечение Установка и подключение пакетов Выполнение программного кода Установка рабочей директории Диагностические функции Получение справки Комментарии Стандарт оформления кода на R Зарезервированные слова Названия переменных Названия специальных символов Ссылка на пособие", " Визуализация и анализ географических данных на языке R Тимофей Самсонов 2020-02-10 Введение Добро пожаловать в курс “Визуализация и анализ географических данных на языке R”! В данном курсе мы освоим азы программирования на языке R, а затем научимся использовать его для решения географических задач. Никаких предварительных знаний и навыков программирования не требуется. Программное обеспечение Для успешного прохождения курса на вашем компьютере должно быть установлено следующее программное обеспечение: Язык R Среда разработки RStudio Выбирайте инсталлятор, соответствующий вашей операционной системе. Обратите внимание на то, что RStudio не будет работать, пока вы не установите базовые библиотеки языка R. Поэтому обе вышеуказанные компоненты ПО обязательны для установки. Установка и подключение пакетов Существует множество дополнительных пакетов R практически на все случаи жизни (вы тоже можете написать свой). Как и дистрибутив R, они доступны через CRAN (Comprehensive R Archive Network). Одним из таких пакетов является, например, пакет readxl, позволяющий читать и записывать файлы в форматах Microsoft Excel. Существует два способа установки пакетов в RStudio. Во-первых, вы можете сделать это в графическом интерфесе, нажав кнопку Install на панели Packages (по умолчанию эта панель расположена в нижней правой четверти окна программы). В появившемся окне введите название пакета и нажмите Install: Установка пакета Во-вторых, вы можете вызвать из консоли команду install.packages(), передав ей в качестве параметра название пакета, заключенное в кавычки: install.packages(&quot;readxl&quot;) Никогда не включайте команду install.packages() в тело скрипта. Это приведет к тому, что каждый раз при запуске программы среда RStudio будет пытаться заново установить пакет, который уже установлен. Запускайте эту функцию только из консоли. Подключение пакета осуществляется с помощью функции library(), при этом название пакета можно в кавычки не заключать: library(readxl) Выполнение программного кода Существует несколько способов выполнения исходного кода: Выполнить одну строку: поставить курсор в любую строку и нажать над редактором кода кнопку Run или сочетание клавиш Ctrl+Enter (Cmd+Enter для OS X). Выполнить несколько строк: выделить необходимые строки и нажать над редактором кода кнопку Run или сочетание клавиш Ctrl+Enter (Cmd+Enter для OS X). Выполнить весь код можно сразу тремя способами: Выделить весь текст и нажать над редактором кода кнопку Run или сочетание клавиш Ctrl+Enter (Cmd+Enter для OS X) Нажать клавиатурное сочетание Ctrl+Alt+Enter (Cmd+Alt+Enter для OS X) Нажать в правом верхнем углу редактора кода кнопку Source Команды Source и Ctrl+Alt+Enter могут не сработать, если у вас не установлена рабочая директория, или если в пути к рабочей директории содержатся кириллические символы (не актуально для Windows 10+ и OS X, которые являются системами, основанными на кодировке Unicode). Существует также ряд дополнительных опций выполнения кода, которые вы можете найти в меню Code &gt; Run Region Выполняя код построчно, делайте это последовательно, начиная с первой строки программы. Одна из самых распространенных ошибок новичков заключается в попытке выполнить некую строку, не выполнив предыдущий код. Нет никаких гарантий, что что-то получится, если открыть файл, поставить курсор в произвольную строку посередине программы и попытаться выполнить ее. Возможно, вам и повезет — если эта строка никак не зависит от предыдущего кода. Однако в реальных программах такие строки составляют лишь небольшую долю от общего объема. Как правило, в них происходит инициализация новых переменных стартовыми значениями. Установка рабочей директории Вы можете открывать и сохранять любые поддерживаемые файлы в R, указывая полный системный путь к файлу. Например, так может выглядеть открытие и сохранение таблицы в формате CSV на компьютере Mac: d = read.csv(&quot;/Volumes/Data/GitHub/r-geo-course/data/oxr_vod.csv&quot;) write.csv(d, &quot;/Volumes/Data/GitHub/r-geo-course/data/oxr_vod_copy.csv&quot;) Однако, если вам требуется открыть или сохранить несколько файлов (и не только данных, но и графиков, карт и т.п.), программа будет выглядеть громоздко. К тому же, прописывать каждый раз полный путь достаточно утомительно и неприятно (даже путем копирования и вставки), а главное — может привести к ошибкам. Чтобы облегчить работу с файлами, в R существует понятие домашней директории. Домашняя директория задается для текущей сессии R с помощью функции setwd(). После установки домашней директории R будет полагать, что все открываемые и сохраняемые файлы должны находиться в ней: setwd(&quot;/Volumes/Data/GitHub/r-geo-course/data&quot;) read.csv(&quot;oxr_vod.csv&quot;) write.csv(d, &quot;oxr_vod_copy.csv&quot;) Как видно, мы добавили дополнительную строчку кода, но сэкономили на длине двух других строк. При увеличении количества обращений к файлам польза домашней директории будет возрастать. При этом вы можете открывать и сохранять файлы в поддиректориях, наддиректориях и соседних директориях, используя синтаксис, стандартный для большинства операционных систем: # сохранить файл в поддиректорию data write.csv(d, &quot;data/oxr_vod_copy.csv&quot;) # сохранить файл в наддиректорию по отношению к текущей директории write.csv(d, &quot;../oxr_vod_copy.csv&quot;) # сохранить файл в директорию data, соседнюю по отношению к текущей директории write.csv(d, &quot;../data/oxr_vod_copy.csv&quot;) Если вы перенесли код и данные с другого компьютера (возможно, вы получили их от своего коллеги или скачали с репозитория данного пособия), необходимо заменить путь, указанный в функции setwd() на путь к каталогу, в который вы положили данные. Рабочая директория и местоположение скрипта могут не совпадать. Вы можете хранить их в разных местах. Однако рекомендуется держать их вместе, что облегчит передачу вашей программы вместе с данными другим пользователям. К сожалению, не существует надежного программного способа сказать среде выполнения R, что в качестве домашей директории следует использовать директорию в которой лежит сам скрипт (что, вообще говоря, было бы крайне удобно). Возможно, в будущем разработчики языка добавят такую полезную функцию. Однако, если для работы с R вы пользуетесь средой RStudio, задача может быть решена путем использования проектов. Подробнее читайте здесь. Диагностические функции В R существует ряд диагностических функций, которые позволяют узнавать информацию об объектах, переменных, а также текущих параметрах среды, оказывающих влияние на результаты выполнения программы. Эти функции полезны, когда необходимо понять, какого типа, размера и содержания данные хранятся в той или иной переменной. Нижеприведенный список функций не являются исчерпывающим, но охватывает наиболее употребильные функции: Функция Назначение class() Класс (тип данных или структура данных) объекта str() Компактное представление внутренней структуры объекта. names() Названия элементов объекта colnames() Названия колонок фрейма данных или матрицы rownames() Названия строк фрейма данных или матрицы mode() Режим хранения объекта. length() Размер (длина) объекта. dim() Измерение объекта. sessionInfo() Информация о текущей сессии R и подключенных пакетах. options() Получение и установка параметров среды. getwd() Текущая рабочая директория Получение справки Любая функция R содержит документированное описание ее параметров и правил использования. Справку можно получить несколькими способами: Найти интересующую вас функцию вручную на вкладке Packages, выбрав нужный пакет Воспользоваться строкой поиска на вкладке Help Ввести знак вопроса и название функции в консоли (будет искать только среди подключенных в настоящий момент пакетов): library(readxl) ?read_xlsx # равносильно вызову функции help(read_xlsx) Справка по функции Ввести двойной знак вопроса и название функции в консоли (будет искать по всем установленным пакетам, независимо от того, подключены ли они в настоящий момент): ??spsample Поиск по функциям Во многих пакетах есть также подробная документация с примерами использования функций в виде руководств и так называемых виньеток (vignettes), которые представляют из себя расширенные руководства (статьи) по использованию пакета. С документацией пакета можно ознакомиться, щелкнув на его названии на вкладке Packages и перейдя по ссылке User guides, package vignettes and other documentation: Документация пакета Комментарии Комментарии — это фрагменты текста программы, начинающиеся с символа #. Комментарии не воспринимаются как исполняемый код и служат для документирования программы. При выполнении программы содержимое комментария в зависимости от настроек среды может выводиться или не выводиться в консоль, однако их содержание никак не влияет на результаты выполнения программы. Всегда пишите комментарии, чтобы по прошествии времени можно было открыть файл и быстро восстановить в памяти логику программы и смысл отдельных операций. Комментарии особенно необходимы, если вашей программой будет пользоваться кто-то другой — без них будет трудно разобраться в программном коде. Действие комментария продолжается от символа # до конца строки. Соответственно, вы можете поставить данный символ в самом начале строки и тогда комментарий будет занимать всю строку. Комментарий также можно расположить справа от исполняемого кода, и тогда он будет занимать только часть строки. Прервать комментарий и написать справа от него исполняемый код нельзя Полнострочные комментарии часто используются для выделения разделов в программе и написания объемных пояснений. Часто в них вводят имитации разделительных линий с помощью символов дефиса (-) или подчеркивания (_), а заголовки набирают прописными буквами. Короткие комментарии справа от фрагментов кода обычно служат пояснением конкретных простых операций. Подобная логика употребления комментариев не является обязательной. Вы можете оформлять их на свое усмотрение. Главное, чтобы они выполняли свою основную функцию — пояснять смысл выполняемых действий. Например: # ОПЕРАЦИИ С ЧИСЛАМИ # --------------------------- # В данном разделе рассматриваются арифметические операции, такие как сложение, вычитание, деление, деление с остатком, взятие остатка и возведение в степень: a = 3 + 2 # Сложение b = 4 ^ 8 # Возведение в степень c = b %% a # Взятие остатка # Деление d = c / a # Умножение e = d * b Однако, усердствовать с комментированием каждой мелочи в программе, разумеется, не стоит. Со временем у вас выработается взвешенный подход к документированию программ и понимание того, какие ее фрагменты требуют пояснения, а какие самоочевидны. Для быстрой вставки комментария, обозначающего новый раздел программы, воспользуйтесь командой меню Code &gt; Insert Section или клавиатурным сочетанием Ctrl+Shift+R (Cmd+Shift+R для OS X) Стандарт оформления кода на R Очень важно сразу же приучить себя грамотно, структурированно и красиво оформлять код на языке R. Это существенно облегчит чтение и понимание ваших программ не только вами, но и другими пользователями и разработчиками. Помимо вышеуказанных рекомендаций по написанию комментариев существует также определенное количество хорошо зарекомендовавших себя и широко используемых практик оформления кода. Эти практики есть в каждом языке программирования и их можно найти в литературе (и в Интернете) в виде негласных сводов правил (style guides) Если вы не хотите быть белой вороной в мире R, вам будет полезно внимательно ознакомиться со стандартом оформления кода на R от компании Google, которая широко использует этот язык в своей работе. Стандарт оформления кода иногда также называют стилем программирования. Мы не будем использовать этот термин, поскольку под стилем программирования традиционно понимают фундаментальный подход (парадигму) к построению программ: процедурный, функциональный, логический, объектно-ориентированный стиль и некоторые другие. К числу негласных правил оформления кода на R можно отнести следующие: Последовательно используйте знак присвоения &lt;- или = на протяжении всей программы. Если вы начали использовать = – применяйте его на протяжении всей программы, не используя &lt;-. Традиционный подход предполагает использование &lt;-, однако все больше программистов использует знак = в своих программах, что делает R более похожим на другие языки программирования. Помните, что использование = официально не рекомендуется, поскольку существует много старого кода на R, который может ошибочно выполняться в сочетании с кодом, использующим =. Но вы, скорее всего, с такими проблемами не столкнетесь. Так что выбор за вами! После запятой всегда ставьте пробел, перед запятой – нет: # Правильно: a = c(1, 2, 3, 4) m = matrix(a, 2, 2) # Неправильно: a = c(1,2,3,4) a = c(1 ,2 ,3 ,4) a = c(1 , 2 , 3 , 4) m = matrix(a,2,2) m = matrix(a ,2 ,2) m = matrix(a , 2 , 2) Отделяйте любые бинарные операторы (такие как =, +, -, &lt;-, *) пробелами с двух сторон: a = sin(b + pi * 0.5) # правильно a=sin(b+pi*0.5) # неправильно Между названием функции и открывающей скобкой пробела быть не должно. То же самое касается обращения к элементам вектора, матрицы и т.п.: # Правильно: sin(b) a[2] # Неправильно: sin (b) a [2] В то же время, при вызове команд управления выполнением программы (условные операторы и циклы) перед и после скобок пробел должен стоять: # Правильно: if (a &gt; 0) { print(a) } i = 0 while (i &lt; a) { print(i) i = i + 1 } # Неправильно: if(a &gt; 0){ print(a) } i = 0 while(i &lt; a){ print(i) i = i + 1 } Зарезервированные слова В R существует небольшое количество зарезервированных слов, которые нельзя использовать в качестве имен переменных, функций и проч. Список этих слов можно получить, набрав в консоли ?Reserved. К ним относятся: Слово Назначение if Условный оператор ЕСЛИ else Условный оператор ИНАЧЕ repeat Цикл без внешнего условия while Цикл “пока верно условие, повторять” function Функция for Цикл “пройти по элементам последовательности” in Оператор вхождения в множество next Переход на новую итерацию цикла break Принудительный выход из цикла или условного оператора TRUE Логическое значение ИСТИНА FALSE Логическое значение ЛОЖЬ NULL Пустое значение Inf Бесконечность NaN Нечисловое значние NA Отсутствующее значение NA_integer_ Отсутствующее целое число NA_real_ Отсутствующее число с плавающей точкой NA_complex_ Отсутствующее комплексное число NA_character_ Отсутствующая строка Названия переменных В качестве названий переменных нельзя использовать заразервированные слова, а также не рекомендуется использовать названия общеупотребительных (диагностических) функций и констант. Также не следует давать переменным названия, совпадающие с широко распространенными функциями – например, котороткими функциями из пакета base, такими как t(), с() и т.д., так как это может привести к путанице в программе и даже ошибкам выполнения кода. Каждый раз, создавая переменную, спрашивайте себя, не совпадает ли ее название с названием одной из используемых вами функций. Названия специальных символов В R, как и во многих других языках программирования испльзуются различные специальные символы. Их смысл и значение мы узнаем по ходу изучения языка, а пока что выучите их названия, чтобы грамотно употреблять в своей речи Символ Название $ доллар # шарп &amp; амперсанд (решетка) / прямой слэш \\ обратный слэш | пайп (вертикальная черта) ^ циркумфлекс (крышечка) @ эт (собачка) ~ тильда '' одинарные кавычки \"\" двойные кавычки `` обратные кавычки Ссылка на пособие Если этот курс лекций оказался полезным для вас, и вы хотите процитировать его с списке литературы вашей работы, то ссылку можно оформить по следующей форме: Самсонов Т.Е. Визуализация и анализ географических данных на языке R. М.: Географический факультет МГУ, 2020. DOI: 10.5281/zenodo.901911 "],
["data-types.html", "Глава 1 Типы данных, условия, ввод и вывод 1.1 Типы данных 1.2 Манипуляции с типами 1.3 Ввод и вывод данных в консоли 1.4 Условный оператор 1.5 Оператор переключения 1.6 Прерывание программы 1.7 Технические детали 1.8 Краткий обзор 1.9 Контрольные вопросы и упражнения", " Глава 1 Типы данных, условия, ввод и вывод Программный код главы 1.1 Типы данных Тип данных — это класс данных, характеризуемый членами класса и операциями, которые могут быть к ним применены1. С помощью типов данных мы можем представлять привычные нам сущности, такие как числа, строки и т.д. В языке R существует 5 базовых типов данных: Название Тип данных complex комплексные числа character строки integer целые числа logical логические (булевы) numeric числа с плавающей точкой Помимо этого есть тип Date, который позволяет работать с датами. Рассмотрим использование каждого из перечисленных типов. 1.1.1 Числа Числа — основной тип данных в R. К ним относятся числа c плавающей точкой и целые числа. В терминологии R такие данные называются интервальными, поскольку к ним применимо понятие интервала на числовой прямой. Целые числа относятся к дискретным интервальным, а числа с плавающей точкой — к непрерывным интервальным. Числа можно складывать, вычитать и умножать: 2 + 3 ## [1] 5 2 - 3 ## [1] -1 2 * 3 ## [1] 6 Разделителем целой и дробной части является точка, а не запятая: 2.5 + 3.1 ## [1] 5.6 Существует также специальный оператор для возведения в степень. Для этого вы можете использовать или двойной знак умножения (**) или циркумфлекс (^), который в обиходе называют просто “крышечкой”: 2 ^ 3 ## [1] 8 2 ** 3 ## [1] 8 Результат деления по умолчанию имеет тип с плавающей точкой: 5 / 3 ## [1] 1.666667 5 / 2.5 ## [1] 2 Если вы хотите чтобы деление производилось целочисленным образом (без дробной части) необходимо использовать оператор %/%: 5 %/% 3 ## [1] 1 Остаток от деления можно получить с помощью оператора %%: 5 %% 3 ## [1] 2 Вышеприведенные арифметические операции являются бинарными, то есть требуют наличия двух чисел. Числа называются “операндами”. Отделять операнды от оператора пробелом или нет — дело вкуса. Однако рекомендуется все же отделять, так как это повышает читаемость кода. Следующие два выражения эквивалентны. Однако сравните простоту их восприятия: 5%/%3 ## [1] 1 5 %/% 3 ## [1] 1 Как правило, в настоящих программах числа в явном виде встречаются лишь иногда. Вместо этого для их обозначения используют переменные. В вышеприведенных выражениях мы неоднократно использовали число 3. Теперь представьте, что вы хотите проверить, каковы будут результаты, если вместо 3 использовать 4. Вам придется заменить все тройки на четверки. Если их много, то это будет утомительная работа, и вы наверняка что-то пропустите. Конечно, можно использовать поиск с автозаменой, но что если тройки надо заменить не везде? Одно и то же число может выполнять разные функции в разных выражениях. Чтобы избежать подобных проблем, в программе вводят переменные и присваивают им значения. Оператор присваивания значения выглядит как = a = 5 b = 3 Чтобы вывести значение переменной на экран, достаточно просто ввести его: a ## [1] 5 b ## [1] 3 Мы можем выполнить над переменными все те же операции что и над константами: a + b ## [1] 8 a - b ## [1] 2 a / b ## [1] 1.666667 a %/% b ## [1] 1 a %% b ## [1] 2 Легко меняем значение второй переменной с 3 на 4 и выполняем код заново. b = 4 a + b ## [1] 9 a - b ## [1] 1 a / b ## [1] 1.25 a %/% b ## [1] 1 a %% b ## [1] 1 Нам пришлось изменить значение переменной только один раз в момент ее создания, все последующие операции остались неизменны, но их результаты обновились! Новую переменную можно создать на основе значений существующих переменных: c = b d = a+c Посмотрим, что получилось: c ## [1] 4 d ## [1] 9 Вы можете комбинировать переменные и заданные явным образом константы: e = d + 2.5 e ## [1] 11.5 Противоположное по знаку число получается добавлением унарного оператора - перед константой или переменной: f = -2 f ## [1] -2 f = -e f ## [1] -11.5 Операция взятия остатка от деления бывает полезной, например, когда мы хотим выяснить, является число четным или нет. Для этого достаточно взять остаток от деления на 2. Если число является четным, остаток будет равен нулю. В данном случае c равно 4, d равно 9: c %% 2 ## [1] 0 d %% 2 ## [1] 1 1.1.1.1 Числовые функции Прежде чем мы перейдем к рассмотрению прочих типов данных и структур данных нам необходимо познакомиться с функциями, поскольку они встречаются буквально на каждом шагу. Понятие функции идентично тому, к чему мы привыкли в математике. Например, функция может называться Z, и принимать 2 аргумента: x и y. В этом случае она записывается как Z(x,y). Чтобы получить значение функции, необходимо подставить некоторые значения вместо x и y в скобках. Нас даже может не интересовать, как фактически устроена функция внутри, но важно понимать, что именно она должна вычислять. С созданием функций мы познакомимся позднее. Важнейшие примеры функций — математические. Это функции взятия корня sqrt(x), модуля abs(x), округления round(x, digits), натурального логарифма abs(x), тригонометрические функции sin(x), cos(x), tan(x), обратные к ним asin(y), acos(y), atan(y) и многие другие. Основные математические функции содержатся в пакете base, который по умолчанию доступен в среде R и не требует подключения. В качестве аргумента функции можно использовать переменную, константу, а также выражения: sqrt(a) ## [1] 2.236068 sin(a) ## [1] -0.9589243 tan(1.5) ## [1] 14.10142 abs(a + b - 2.5) ## [1] 6.5 Вы также можете легко вкладывать функции одна в одну, если результат вычисления одной функции нужно подставить в другую: sin(sqrt(a)) ## [1] 0.7867491 sqrt(sin(a) + 2) ## [1] 1.020331 Также как и с арифметическими выражениями, результат вычисления функции можно записать в переменную: b = sin(sqrt(a)) b ## [1] 0.7867491 Если переменной b ранее было присвоено другое значение, оно перезапишется. Вы также можете записать в переменную результат операции, выполненной над ней же. Например, если вы не уверены, что a — неотрицательное число, а вам это необходимо в дальнейших расчетах, вы можете применить к нему операцию взятия модуля: b = sin(a) b ## [1] -0.9589243 b = abs(b) b ## [1] 0.9589243 1.1.2 Строки Строки — также еще один важнейший тип данных. Строки состоят из символов. Чтобы создать строковую переменную, необходимо заключить текст строки в кавычки: s = &quot;В историю трудно войти, но легко вляпаться (М.Жванецкий)&quot; s ## [1] &quot;В историю трудно войти, но легко вляпаться (М.Жванецкий)&quot; Длину строки в символах можно узнать с помощью функции nchar() nchar(s) ## [1] 56 Строки можно складывать так же как и числа. Эта операция называется конкатенацией. В результате конкатенации строки состыковываются друг с другом и получается одна строка. В отличие от чисел, конкатенация производится не оператором +, а специальной функцией paste(). Состыковываемые строки нужно перечислить через запятую, их число может быть произвольно s1 = &quot;В историю трудно войти,&quot; s2 = &quot;но легко вляпаться&quot; s3 = &quot;(М.Жванецкий)&quot; Посмотрим содержимое подстрок: s1 ## [1] &quot;В историю трудно войти,&quot; s2 ## [1] &quot;но легко вляпаться&quot; s3 ## [1] &quot;(М.Жванецкий)&quot; А теперь объединим их в одну: s = paste(s1, s2) s ## [1] &quot;В историю трудно войти, но легко вляпаться&quot; s = paste(s1, s2, s3) s ## [1] &quot;В историю трудно войти, но легко вляпаться (М.Жванецкий)&quot; Настоящая сила конкатенации проявляется когда вам необходимо объединить в одной строке некоторое текстовое описание (заранее известное) и значения переменных, которые у вас вычисляются в программе (заранее неизвестные). Предположим, вы нашли в программе что максимальная численность населения в Детройте пришлась на 1950 год и составила 1850 тыс. человек. Найденный год записан у вас в переменную year, а население в переменную pop. Вы их значения пока что не знаете, они вычислены по табличным данным в программе. Как вывести эту информацию на экран “человеческим”\" образом? Для этого нужно использовать конкатенацию строк. Условно запишем значения переменных, как будто мы их знаем year = 1950 pop = 1850 s1 = &quot;Максимальная численность населения в Детройте пришлась на&quot; s2 = &quot;год и составила&quot; s3 = &quot;тыс. чел&quot; s = paste(s1, year, s2, pop, s3) s ## [1] &quot;Максимальная численность населения в Детройте пришлась на 1950 год и составила 1850 тыс. чел&quot; Обратите внимание на то что мы конкатенировали строки с числами. Конвертация типов осуществилась автоматически. Помимо этого, функция сама вставила пробелы между строками. Функция paste() содержит параметр sep, отвечающий за символ, который будет вставляться между конкатенируемыми строками. По умолчанию sep = \" \", то есть, между строками будет вставляться пробел. Подобное поведение желательно не всегда. Например, если после переменной у вас идет запятая, то между ними будет вставлен пробел. В таком случае при вызове paste() необходимо указать sep = \"\", то есть пустую строку: paste(... sep = \"\"). Вы также можете воспользоваться функцией paste0(), которая делает [почти] то же самое, что и paste(..., sep = \"\"), но избавляет вас от задания параметра sep. 1.1.3 Даты Даты являются необходимыми при работе с временными данными. В географическом анализе подобные задачи возникают сплошь и рядом. Точность указания времени может быть самой различной. От года до долей секунды. Чаще всего используются даты, указанные с точностью до дня. Для создания даты используется функция as.Date(). В данном случае точка — это лишь часть названия функции, а не какой-то особый оператор. В качестве аргумента функции необходимо задать дату, записанную в виде строки. Запишем дату рождения автора (можете заменить ее на свою): birth = as.Date(&#39;1986/02/18&#39;) birth ## [1] &quot;1986-02-18&quot; Сегодняшнюю дату вы можете узнать с помощью специальной функции Sys.Date(): current = Sys.Date() current ## [1] &quot;2020-02-10&quot; Даты также можно складывать и вычитать. В зависимости от дискретности данных, вы получите результат в часах, днях, годах и т.д. Например, узнать продолжительность жизни в днях можно так: livedays = current - birth livedays ## Time difference of 12410 days Вы также можете прибавить к текущей дате некоторое значение. Например, необходимо узнать, какая дата будет через 40 дней: current + 40 ## [1] &quot;2020-03-21&quot; 1.1.4 Логические Логические переменные возникают там, где нужно проверить условие. Переменная логического типа может принимать значение TRUE (истина) или FALSE (ложь). Для их обозначения также возможны более компактные константы T и F соответственно. Следующие операторы приводят к возникновению логических переменных: РАВНО (==) — проверка равенства операндов НЕ РАВНО (!=) — проверка неравенства операндов МЕНЬШЕ (&lt;) — первый аргумент меньше второго МЕНЬШЕ ИЛИ РАВНО (&lt;=) — первый аргумент меньше или равен второму БОЛЬШЕ (&gt;) — первый аргумент больше второго БОЛЬШЕ ИЛИ РАВНО (&gt;=) — первый аргумент больше или равен второму Посмотрим, как они работают: a = 1 b = 2 a == b ## [1] FALSE a != b ## [1] TRUE a &gt; b ## [1] FALSE a &lt; b ## [1] TRUE Если необходимо проверить несколько условий одновременно, их можно комбинировать с помощью логических операторов. Наиболее популярные среди них: И (&amp;&amp;) - проверка истинности обоих условий ИЛИ (||) - проверка истинности хотя бы одного из условий НЕ (!) - отрицание операнда (истина меняется на ложь, ложь на истину) c = 3 (b &gt; a) &amp;&amp; (c &gt; b) ## [1] TRUE (a &gt; b) &amp;&amp; (c &gt; b) ## [1] FALSE (a &gt; b) || (c &gt; b) ## [1] TRUE !(a &gt; b) ## [1] TRUE Более подробно работу с логическими переменными мы разберем далее при знакомстве с условным оператором if. 1.2 Манипуляции с типами 1.2.1 Определение типа данных Определение типа данных осуществляется с помощью функции class() (см. раздел Диагностические функции во Введении) class(1) ## [1] &quot;numeric&quot; class(0.5) ## [1] &quot;numeric&quot; class(1 + 2i) ## [1] &quot;complex&quot; class(&quot;sample&quot;) ## [1] &quot;character&quot; class(TRUE) ## [1] &quot;logical&quot; class(as.Date(&#39;1986-02-18&#39;)) ## [1] &quot;Date&quot; В вышеприведенном примере видно, что R по умолчанию “повышает” ранг целочисленных данных до более общего типа чисел с плавающей точкой, тем самым закладываясь на возможность точного деления без остатка. Если вы хотите, чтобы данные в явном виде интерпретировались как целочисленные, их нужно принудительно привести к этому типу. Операторы преобразования типов рассмотрены ниже. 1.2.2 Преобразование типов данных Преобразование типов данных осуществляется с помощью функций семейства as(d, type), где d — это входная переменная, а type — название типа данных, к которому эти данные надо преобразовать (см. таблицу в начале главы). Несколько примеров: k = 1 print(k) ## [1] 1 class(k) ## [1] &quot;numeric&quot; l = as(k, &quot;integer&quot;) print(l) ## [1] 1 class(l) ## [1] &quot;integer&quot; m = as(l, &quot;character&quot;) print(m) ## [1] &quot;1&quot; class(m) ## [1] &quot;character&quot; n = as(m, &quot;numeric&quot;) print(n) ## [1] 1 class(n) ## [1] &quot;numeric&quot; Для функции as() существуют обертки (wrappers), которые позволяют записывать такие преобразования более компактно и выглядят как as.&lt;dataype&gt;(d), где datatype — название типа данных: k = 1 l = as.integer(k) print(l) ## [1] 1 class(l) ## [1] &quot;integer&quot; m = as.character(l) print(m) ## [1] &quot;1&quot; class(m) ## [1] &quot;character&quot; n = as.numeric(m) print(n) ## [1] 1 class(n) ## [1] &quot;numeric&quot; d = as.Date(&#39;1986-02-18&#39;) print(d) ## [1] &quot;1986-02-18&quot; class(d) ## [1] &quot;Date&quot; Если преобразовать число c плавающей точкой до целого, то дробная часть будет отброшена: as.integer(2.7) ## [1] 2 После преобразования типа данных, разумеется, к переменной будут применимы только те функции, которые определены для данного типа данных: a = 2.5 b = as.character(a) b + 2 ## Error in b + 2: нечисловой аргумент для бинарного оператора nchar(b) ## [1] 3 1.2.3 Проверка типов данных и пустых значений Для проверки типа данных можно использовать функции семейства is.&lt;datatype&gt;: is.integer(2.7) ## [1] FALSE is.numeric(2.7) ## [1] TRUE is.character(&#39;Привет!&#39;) ## [1] TRUE Особое значение имеют функции проверки пустых переменных (имеющих значение NA - not available), которые могут получаться в результате несовместимых преобразований или соответствовать пропускам в исходных данных: as.integer(&#39;Привет!&#39;) ## [1] NA is.na(as.integer(&#39;Привет!&#39;)) ## [1] TRUE 1.3 Ввод и вывод данных в консоли 1.3.1 Ввод данных Для ввода данных через консоль можно воспользоваться функцией readline(), которая будет ожидать пользовательский ввод и нажатие клавиши Enter, после чего вернет введенные данные в виде строки. Предположим, пользователь вызывает эту функцию и вводит с клавиатуры 1024: a = readline() Выведем результат на экран: a ## [1] &quot;1024&quot; Функция readline() всегда возвращает строку, поэтому если вы ожидаете ввод числа, полученное значение необходимо явным образом преобразовать к числовому типу. Весьма полезной особенностью readline() является возможность указания строки запроса (чтобы пользователь понимал, что от него хотят). Строку запроса можно указать при вызове функции: lat = readline(&#39;Введите широту точки:&#39;) ## Введите широту точки: ## 54 lat ## [1] &quot;54&quot; 1.3.2 Вывод данных Для вывода данных в консоль можно воспользоваться тремя способами: Просто напечатать название переменной с новой строки (не работает при запуске программы командой Source) Вызвать функцию print() Вызвать функцию cat() Заключить выражение в круглые скобки () Первый способ мы уже регулярно использовали ранее в настоящей главе. Следует обратить внимание на то, что он хорош для отладки программы, но выглядит некрасиво в рабочих программах, поскольку просто печатая название переменной с новой строки вы как бы явно не говорите о том, что хотите вывести ее значение в консоль, а лишь подразумеваете это. Более того, если скрипт запускается командой Source, данный метод вывода переменной просто не сработает, интерпретатор его проигнорирует. Поэтому после отладки следует убрать из программы все лишние выводы в консоль, а оставшиеся (действительно нужные) оформить с помощью функций print() или cat(). Функция print() работает точно так же, как и просто название переменной с новой строки, отличаясь лишь двумя особенностями: print() явным образом говорит о том, что вы хотите вывести в консоль некую информацию print() работает при любых методах запуска программы, в том числе методом Source. Например: a = 1024 a ## [1] 1024 print(a) ## [1] 1024 b = &quot;Fourty winks in progress&quot; b ## [1] &quot;Fourty winks in progress&quot; print(b) ## [1] &quot;Fourty winks in progress&quot; print(paste(&quot;2 в степени 10 равно&quot;, 2^10)) ## [1] &quot;2 в степени 10 равно 1024&quot; print(paste(&quot;Сегодняшняя дата - &quot;, Sys.Date())) ## [1] &quot;Сегодняшняя дата - 2020-02-10&quot; Функция cat() отличается от print() следующими особенностями: cat() выводит значение переменной, и не печатает ее измерения и внешние атрибуты типа двойных кавычек вокруг строки. Это означает, что cat() можно использовать и для записи данных в файл (на практике этим мало кто пользуется, но знать такую возможность надо). cat() принимает множество аргументов и может осуществлять конкатенацию строк аналогично функции paste() cat() не возвращает никакого значений, в то время как print() возвращает значение, переданное ей в качестве аргумента. cat() можно использовать только для атомарных типов данных. Для классов (таких как Date) она будет выводит содержимое объекта, которое может не совпадать с тем, что пользователь ожидает вывести Например: cat(a) ## 1024 cat(b) ## Fourty winks in progress cat(&quot;2 в степени 10 равно&quot;, 2^10) ## 2 в степени 10 равно 1024 cat(&quot;Сегодняшнаяя дата -&quot;, Sys.Date()) ## Сегодняшнаяя дата - 18302 Можно видеть, что в последнем случае cat() напечатала отнюдь не дату в ее привычном представлении, а некое число, которое является внутренним представлением даты в типе данных Date. Такие типы данных являются классами объектов в R, и у них есть своя функция print(), которая и выдает содержимое объекта в виде, который ожидается пользователем. Поэтому пользоваться функцией cat() надо с некоторой осторожностью. Заключительная возможность — вывод с помощью заключения выражения в круглые скобки — очень удобна на стадии отладки программы. При этом переменная, которая создается в выражении, остается доступной в программе: (a = rnorm(5)) # сгенерируем 5 случайных чисел, запишем их в переменную a и выведем на экран ## [1] 0.5873440 1.2069579 1.9252670 0.4524668 0.2818155 (b = 2 * a) # переменная a доступна, ее можно использовать и далее для вычислений ## [1] 1.1746879 2.4139158 3.8505339 0.9049336 0.5636309 1.4 Условный оператор Проверка условий позволяет осуществлять так называемое ветвление в программе. Ветвление означает, что при определенных условиях (значениях переменных) будет выполнен один программный код, а при других условиях — другой. В R для проверки условий используется условный оператор if — else if — else следующего вида: if (condition) { statement1 } else if (condition) { statement2 } else { statement3 } Сначала проверяется условие в выражении if (condition), и если оно истинно, то выполнится вложенный в фигурные скобки программный код statement1, после чего оставшиеся условия не будут проверяться. Если первое условие ложно, программа перейдет к проверке следующего условия else if (condition). Далее, если оно истинно, то выполнится вложенный код statement2, если нет — проверка переключится на следующее условие и так далее. Заключительный код statement3, следующий за словом else, выполнится только если ложными окажутся все предыдущие условия. Конструкций else if может быть произвольное количество, конструкции if и else могут встречаться в условном операторе только один раз, в начале и конце соответственно. При этом условный оператор может состоять только из конструкции if, а else if и else не являются обязательными. Например, сгенерируем случайное число, округлим его до одного знака после запятой и проверим относительно нуля: (a = round(rnorm(1), 1)) ## [1] -1.5 if (a &lt; 0) { cat(&#39;Получилось отрицательное число!&#39;) } else if (a &gt; 0) { cat(&#39;Получилось положительное число!&#39;) } else { cat(&#39;Получился нуль!&#39;) } ## Получилось отрицательное число! Условия можно использовать, в частности, для того чтобы обрабатывать пользовательский ввод в программе. Например, охарактеризуем положение точки относительно Полярного круга: phi = as.numeric(readline(&#39;Введите широту вашей точки:&#39;)) Пользователь вводит 68, а мы оцениваем результат: if (!is.na(phi)) { # проверяем, является ли введенное значение числом if (abs(phi) &gt;= 66.562 &amp;&amp; abs(phi) &lt;= 90) { # выполняем проверку на заполярность cat(&#39;Точка находится в Заполярье&#39;) } else { cat(&#39;Точка не находится в Заполярье&#39;) } } else { cat(&#39;Необходимо ввести число!&#39;) # оповещаем о некорректном вводе } ## Точка находится в Заполярье 1.5 Оператор переключения Оператор переключения (switch) является удобной заменой условному оператору в тех случаях, когда надо вычислить значение переменной в зависимости от значения другой переменной, которая может принимать ограниченное (заранее известное) число значений. Например: name = readline(&#39;Введите название федерального округа:&#39;) Пользователь вводит: Приволжский # Определим центр в зависимости от названия: capital = switch(name, &#39;Центральный&#39; = &#39;Москва&#39;, &#39;Северо-Западный&#39; = &#39;Санкт-Петербург&#39;, &#39;Южный&#39; = &#39;Ростов-на-Дону&#39;, &#39;Северо-Кавказский&#39; = &#39;Пятигорск&#39;, &#39;Приволжский&#39; = &#39;Нижний Новгород&#39;, &#39;Уральский&#39; = &#39;Екатеринбург&#39;, &#39;Сибирский&#39; = &#39;Новосибирск&#39;, &#39;Дальневосточный&#39; = &#39;Хабаровск&#39;) print(capital) ## [1] &quot;Нижний Новгород&quot; 1.6 Прерывание программы В процессе выполнения программы могут возникнуть ситуации, при которых дальнейшее выполнение программы невозможно или недопустимо. Например, пользователь вместо числа ввёл в консоли букву. Хорошим тоном разработчика в данном случае будет не пускать ситуацию на самотёк и ждать пока программа сама споткнется и выдаст системное сообщение об ошибке, а обработать некорректный ввод сразу, сообщить об этом пользователю и остановить программу явным образом. Прервать выполнение программы можно разными способами. Рассмотрим две часто используемые для этого функции: stop(...) выводит на экран объекты, перечисленные через запятую в ... и завершает выполнение программы. При ручном вызове этой функции в ... целесообразно передать текстовую строку с сообщением о причине остановки программы. Вызов stop() происходит обычно после проверки некоторого условия оператором if-else. stopifnot(...) вызывает stop(), если хотя бы одно из выражений, перечисленных через запятую в ... имеет значение FALSE. При этом в stop() передается первое выражение, которое было оценено в FALSE. Реализуем вышеописанный пример с контролем пользовательского ввода: n = as.numeric(readline(&#39;Введите число:&#39;)) stopifnot(is.numeric(n)) # остановим выполнение, если получилось не число cat(n^2) # возведем в квадрат и выведем на экран, если все ОК Если пользователь введет abc, программа остановит выполнение: ## Error: is.numeric(n) is not TRUE Обратите внимание, что R напечатал также и само выражение, которое было оценено как FALSE. Вышеприведенный код можно сделать более дружелюбным для пользователя, если воспользоваться непосредственно функцией stop(): n = as.numeric(readline(&#39;Введите число:&#39;)) if (!is.numeric(n)) stop(&#39;Введенная строка не является числом&#39;) # остановим выполнение cat(n^2) # возведем в квадрат и выведем на экран, если все ОК Вывод программы в случае ввода строки abc будет следующим: ## Error in eval(expr, envir, enclos): Введенная строка не является числом 1.7 Технические детали Когда вы присваиваете значение переменной другой переменной, копирования не происходит. Оба имени будут ссылаться на один и тот же объект, до тех пор, пока через одно из имен не будет предпринята попытка модифицировать объект. Это можно легко проверить с помощью функции tracemem(): a = 1 b = a cat(&#39;a:&#39;, tracemem(a), &#39;\\n&#39;) ## a: &lt;0x7fb04cd75dd8&gt; cat(&#39;b:&#39;, tracemem(b), &#39;\\n&#39;) ## b: &lt;0x7fb04cd75dd8&gt; a = 2 cat(&#39;a:&#39;, tracemem(a), &#39;\\n&#39;) # объект скопирован в другую область памяти ## a: &lt;0x7fb04cde5a90&gt; cat(&#39;b:&#39;, tracemem(b), &#39;\\n&#39;) ## b: &lt;0x7fb04cd75dd8&gt; Подобное поведение называется copy-on-modify. Оно позволяет экономить на вычислениях в случае, когда копия и оригинал остаются неизменными. Аналогичное правило применяется когда вы копируете структуры данных, такие как векторы, списки и фреймы данных (см. Главу 2). Более подробно см. параграф 2.3 в (Wickham 2019). 1.8 Краткий обзор Для просмотра презентации щелкните на ней один раз левой кнопкой мыши и листайте, используя кнопки на клавиатуре: Презентацию можно открыть в отдельном окне или вкладке браузере. Для этого щелкните по ней правой кнопкой мыши и выберите соответствующую команду. 1.9 Контрольные вопросы и упражнения 1.9.1 Вопросы Какие типы данных поддерживаются в R? Каковы их англоязычные наименования? Что такое переменная? Какой оператор используется для записи значения в переменную? С помощью какой функции можно узнать тип переменной? С помощью какого семейства функций можно преобразовывать типы переменных? Можно ли использовать ранее созданное имя переменной для хранения новых данных другого типа? Можно ли записать в переменную результат выполнения выражения, в котором она сама же и участвует? Какая функция позволяет прочитать пользовательский ввод с клавиатуры в консоли? Какой тип данных будет иметь возвращаемое значение? Какую функцию можно использовать для вывода значения переменной в консоль? Чем отличается использование этой функции от случая, когда вы просто пишете название переменной в строке программы? Какой символ является разделителем целой и дробной части при записи чисел с плавающей точкой? Что такое операторы и операнды? Приведите примеры бинарных и унарных операторов. Какое значение будет имет результат деления на ноль? Какие функции выполняют операторы %%, %/%, ^, **? Как проверить, является ли число четным? Как определить количество символов в строке? Как называется операция состыковки нескольких строк и с помощью какой функции она выполняется? Как добиться того, чтобы при этом не добавлялись пробелы между строками? С помощью какой функции можно создать дату из строки? Как извлечь из даты год? Месяц? День? Какая функция позволяет получить дату сегодняшнего дня? Можно ли складывать даты и числа? Если да, то в каких единицах измерения будет выражен результат? Какова краткая форма записи логических значений TRUE и FALSE? Каким числам соответствуют логические значения TRUE и FALSE? Сколько операндов должно быть верно, чтобы оператор логического И (&amp;&amp;) принял значение TRUE? Что можно сказать в этом отношении об операторе ИЛИ (||)? Можно ли применять арифметические операции к логическим переменным? Что произойдет, если прибавить или вычесть из числа a значение TRUE? А если заменить TRUE на FALSE? Что такое условный оператор и для каких сценариев обработки данных необходимы условные операторы? Перечислите ключевые слова, которые могут быть использованы для организации условных операторов При каких сценариях целесообразно использовать оператор переключения? 1.9.2 Упражнения Запишите условие проверки неравенства чисел a и b не менее чем тремя способами. Напишите программу, которая запрашивает в консоли целое число и определяет, является ли оно чётным или нечетным. Программа должна предварительно определить, является ли введенное число а) числом и б) целым числом. Подсказка: результат конвертации строки в целое число и число с плавающей точкой отличается. Вы можете использовать это для проверки, является ли введенное число целым. Напишите программу, которая считывает из консоли введенную пользователем строку и выводит в консоль количество символов в этой строке. Вывод оформите следующим образом: \"Длина введенной строки равняется ... символам\", где вместо многоточия стоит вычисленная длина. В программе в виде переменных задайте координаты населенного пункта А (x1, y1), а также дирекционный угол D и расстояние L до населенного пункта B. Напишите код, который определяет координаты населенного пункта B (x2, y2). Функция atan2() позволяет найти математический азимут (полярный угол), если известны координаты вектора между двумя точками. Используя эту функцию, напишите программу, которая вычисляет географический азимут между точками А (x1, y1) и B (x2, y2). Координаты точек задайте в виде переменных непосредственно в коде. Математический азимут отсчитывается от направления на восток против часовой стрелки. Географический азимут отсчитывается от направления на север по часовой стрелке). Самсонов Т.Е. Визуализация и анализ географических данных на языке R. М.: Географический факультет МГУ, 2020. DOI: 10.5281/zenodo.901911 References "],
["data-structures.html", "Глава 2 Структуры данных и циклы 2.1 Однородные структуры данных 2.2 Разнородные структуры данных 2.3 Факторы 2.4 Описание структуры данных 2.5 Циклы 2.6 Технические детали 2.7 Краткий обзор 2.8 Контрольные вопросы и упражнения", " Глава 2 Структуры данных и циклы Программный код главы Структура данных — это программная единица, позволяющая хранить и обрабатывать множество однотипных и/или логически связанных данных. Структуры данных также являются типами данных, но не простыми, а составными. Поэтому обычно, когда говорят “тип данных”, подразумевают именно простые типы данных, рассмотренные в предыдущей главе. В R общеупотребительны следующие структуры данных: векторы, матрицы, массивы, фреймы данных, списки и факторы. С использованием структур данных тесно связаны циклы — разновидность управляющей конструкции, предназначенная для многократного повторения определенного набора инструкций. 2.1 Однородные структуры данных 2.1.1 Векторы Вектор представляет собой упорядоченную последовательность объектов одного типа. Вектор может состоять только из чисел, только из строк, только из дат или только из логических значений и т.д. Числовой вектор легко представить себе в виде набора цифр, выстроенных в ряд и пронумерованных согласно порядку их расстановки. Вектор является простейшей и одновременно базовой структурой данных в R. Понимание принципов работы с векторами необходимо для дальнейшего знакомства с более сложными структурами данных, такими как матрицы, массивы, фреймы данных, тибблы, списки и факторы. 2.1.1.1 Создание Существует множество способов создания векторов. Среди них наиболее употребительны: Явное перечисление элементов Создание пустого вектора (“болванки”), состоящего из заданного числа элементов Генерация последовательности значений Генерация случайного множества значений Для создания вектора путем перечисления элементов используется функция c(): # вектор из строк — цвета некоторых веток Московского метро colors = c(&quot;Красная&quot;, &quot;Зеленая&quot;, &quot;Синяя&quot;, &quot;Коричневая&quot;, &quot;Оранжевая&quot;) colors ## [1] &quot;Красная&quot; &quot;Зеленая&quot; &quot;Синяя&quot; &quot;Коричневая&quot; &quot;Оранжевая&quot; # вектор из чисел — длина веток в километрах (в той же последовательности) lengths = c(28, 40, 45, 19, 38) lengths ## [1] 28 40 45 19 38 # вектор из булевых переменных — наличие открытых наземных участков (в той же последовательности) opens = c(FALSE, TRUE, TRUE, FALSE, FALSE) opens ## [1] FALSE TRUE TRUE FALSE FALSE Внимание: не используйте латинскую букву ‘c’ в качестве названия переменной! Это приведет к конфликту названия встроенной функции c() и определенной вами переменной Помимо этого, распространены сценарии, когда вам нужно создать вектор, но заполнять его значениями вы будете по ходу выполнения программы — скажем, при последовательной обработке строк таблицы. В этом случае вам известно только предполагаемое количество элементов вектора и их тип. Здесь лучше всего подойдет создание пустого вектора, которое выполняется функцией vector(). Функция принимает 2 параметра: mode отвечает за тип данных и может принимать значения равные \"logical\", \"integer\", \"numeric\" (или \"double\"), \"complex\", \"character\" и \"raw\" length отвечает за количество элементов Например: # Вектор из 5 элементов, который предполагается заполнить целыми числами intvalues = vector(mode = &quot;integer&quot;, length = 5) intvalues # по умолчанию заполнен нулями ## [1] 0 0 0 0 0 # Вектор из 10 элементов, который предполагается заполнить символьными данными (строками) charvalues = vector(&quot;character&quot;, 10) charvalues # по умолчанию заполнен пустыми строками ## [1] &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; Обратите внимание на то, что в первом случае подстановка параметров произведена в виде параметр = значение, а во втором указаны только значения. В данном примере оба способа эквивалентны. Однако первый способ безопаснее и понятнее. Если вы указываете только значения параметров, нужно помнить, что интерпретатор будет подставлять их именно в том порядке, в котором они перечислены в описании функции. Описание функции можно посмотреть, набрав ее название в консоли ее название со знаком вопроса в качестве префикса. Например, для вышеуказанной функции надо набрать ?vector Наконец, третий распространенный способ создания векторов — это генерация последовательности. Чтобы сформировать вектор из натуральных чисел от M до N, можно воспользоваться специальной конструкцией: M:N: index = 1:5 # эквивалентно c(1,2,3,4,5) index ## [1] 1 2 3 4 5 index = 2:4 # эквивалентно c(2,3,4) index ## [1] 2 3 4 Существует и более общий способ создания последовательности — функция seq(), которая позволяет генерировать вектора значений нужной длины и/или с нужным шагом: seq(from = 1, by = 2, length.out = 10) # 10 нечетных чисел, начиная с единицы ## [1] 1 3 5 7 9 11 13 15 17 19 seq(from = 2, to = 20, by = 3) # от 2 до 20 с шагом 3 (сколько поместится) ## [1] 2 5 8 11 14 17 20 seq(length.out = 10, to = 2, by = -2) # убывающая последовательность из 10 четных чисел с последним элементом, равным 2 ## [1] 20 18 16 14 12 10 8 6 4 2 Как видно, параметры функции seq() можно комбинировать различными способами и указывать в произвольном порядке (при условии, что вы используете полную форму (параметр = значение). Главное, чтобы их совокупность однозначно описывала последовательность. Хотя, скажем, последний пример убывающей последовательности нельзя признать удачным с точки зрения наглядности. Аналогичным образом можно создавать последовательности дат: seq(from = as.Date(&#39;2016/09/01&#39;), by = 1, length.out = 7) # Даты первой недели учебного 2016/2017 года ## [1] &quot;2016-09-01&quot; &quot;2016-09-02&quot; &quot;2016-09-03&quot; &quot;2016-09-04&quot; &quot;2016-09-05&quot; ## [6] &quot;2016-09-06&quot; &quot;2016-09-07&quot; seq(from = Sys.Date(), by = 7, length.out = 5) # Пять дат через неделю, начиная с сегодняшнего дня ## [1] &quot;2020-02-10&quot; &quot;2020-02-17&quot; &quot;2020-02-24&quot; &quot;2020-03-02&quot; &quot;2020-03-09&quot; Часто оказывается полезным такая функция как генерация множества случайных значений, подчиненных определенному закону распределения. Наиболее часто испольщуются функции runif() (равномерное распределение) и rnorm() (нормальное распределение): runif(5, 0, 100) # 5 чисел равномерного распределения в диапазоне от 0 до 100 ## [1] 56.619161 34.963899 2.896563 79.581823 76.189143 rnorm(5, 10, 5) # 5 чисел нормального распределения со средним = 10 и СКО = 5 ## [1] 17.114827 10.342748 6.427206 10.046531 9.797453 2.1.1.2 Индексирование К отдельным элементам вектора можно обращаться по их индексам: colors[1] # первый элемент вектора ## [1] &quot;Красная&quot; colors[3] # третий элемент ## [1] &quot;Синяя&quot; ВНИМАНИЕ: элементы векторов и других структур данных в языке R индексируются от 1 до N, где N — это длина вектора. Это отличает R от широко распространенных Си-подобных языков программирования (C, C++, C#, Java, Python), в которых индексы элементов начинаются с 0 и заканчиваются N-1. Например, первый элемент списка (аналог вектора в R) на языке Python извлекался бы как colors[0]. Будьте внимательны, особенно если программируете на нескольких языках. Количество элементов (длину) вектора можно узнать с помощью функции length(): length(colors) ## [1] 5 Последний элемент вектора можно извлечь, если мы знаем его длину: n = length(colors) colors[n] ## [1] &quot;Оранжевая&quot; Последовательности удобно использовать для извлечения подвекторов. Предположим, нужно извлечь первые 4 элемента. Для этого запишем: lengths[1:4] ## [1] 28 40 45 19 Индексирующий вектор можно создать заранее. Это удобно, если номера могут меняться в программе: m = 1 n = 4 index = m:n lengths[index] ## [1] 28 40 45 19 Обратите внимание на то что по сути один вектор используется для извлечения элементов из другого вектора. Это означает, что мы можем использовать не только простые последовательности натуральных чисел, но и векторы из прозвольных индексов. Например: index = c(1, 3, 4) # хотим извлечь 1, 3 и 4 элемент списка lengths[index] ## [1] 28 45 19 index = c(5, 1, 4, 2) # индексы могут располагаться в произвольном порядке lengths[index] ## [1] 38 28 19 40 2.1.1.3 Преобразование К числовым векторам можно применять множество функций. Прежде всего, нужно знать функции вычисления базовых параметров статистического ряда — минимум, максимум, среднее, медиана, дисперсия, размах вариации, среднеквадратическое отклонение, сумма: min(lengths) # минимум ## [1] 19 max(lengths) # максимум ## [1] 45 range(lengths) # размах вариации = максимум - минимум ## [1] 19 45 mean(lengths) # среднее арифметическое ## [1] 34 median(lengths) # медиана ## [1] 38 var(lengths) # дисперсия (по английски - вариация, variation) ## [1] 108.5 sd(lengths) # среднеквадратическое отклонение (standard deviation) ## [1] 10.41633 sum(lengths) # сумма ## [1] 170 Одной из мощнейших особенностей R является то что он не проводит различий между числами и векторами чисел. Поскольку R является матричным языком, каждое число представляется как вектор длиной 1 (или матрица \\(1х1\\)). Это означает, что любая математическая функция, применимая к числу, будет применима и к вектору: lengths * 1000 # преобразуем длины линий в метры ## [1] 28000 40000 45000 19000 38000 sqrt(lengths) # квадратный корень из длины каждого элемента ## [1] 5.291503 6.324555 6.708204 4.358899 6.164414 stations = c(20, 21, 22, 12, 24) # количество станций dens = stations / lengths # плотность станций по веткам метро = кол-во станций / длина dens ## [1] 0.7142857 0.5250000 0.4888889 0.6315789 0.6315789 2.1.1.4 Поиск и сортировка К важнейшим преобразованиям векторов относится их сортировка: lengths2 = sort(lengths) # сортировка по возрастанию значений lengths2 # отсортированный вектор ## [1] 19 28 38 40 45 lengths # сравним с исходным ## [1] 28 40 45 19 38 lengths2 = sort(lengths, decreasing = TRUE) # сортировка по убыванию значений. Нужно задать параметр decreasing lengths2 # отсортированный вектор ## [1] 45 40 38 28 19 lengths # сравним с исходным ## [1] 28 40 45 19 38 Другая распространенная задача — это поиск индекса элемента по его значению. Например, вы хотите узнать, какая ветка Московского метро (среди рассматриваемых) является самой длинной. Вы, конечно, легко найдете ее длину с помощью функции max(lengths). Однако это не поможет вам узнать ее название, поскольку оно находится в другом векторе, и его индекс в массиве неизвестен. Поскольку векторы упорядочены одинаково, нам достаточно узнать, под каким индексом в массиве lengths располагается максимальный элемент, и затем извлечь цвет линии метро под тем же самым индексом. Дл поиска индекса элемента используется функция match(): l = max(lengths) # находим максимальное значение idx = match(l, lengths) # находим индекс элемента, равного l, в списке lengths color = colors[idx] # извлекаем цвет ветки метро color ## [1] &quot;Синяя&quot; Здесь непохо бы лишний раз потренироваться в конкатенации строк, чтобы вывести результат красиво! s = paste(color, &quot;ветка Московского метро — самая длинная. Ее протяженность составляет&quot;, l, &quot;км&quot;) s ## [1] &quot;Синяя ветка Московского метро — самая длинная. Ее протяженность составляет 45 км&quot; Ну и напоследок пример “матрешки”\" из функций — как найти название самой плотной линии одним выражением: colors[match(max(dens),dens)] ## [1] &quot;Красная&quot; 2.1.1.5 Проверка условий Проверка условия для вектора приводит к получению вектора логических значений: lengths &gt; 20 ## [1] TRUE TRUE TRUE FALSE TRUE Такого рода условия используются для фильтрации фреймов данных (см. далее) Для векторов существует специальная форма векторизованного условного оператора – функция ifelse(). Она позволяет создать вектор, каждый элемент которого вычисляется по-разному в зависимости от значения элемента другого вектора в соответствующей позиции. Например, мы можем охарактеризовать каждую линию метро как длинную или короткую, установив порог в 20 км: (line_type = ifelse(lengths &gt; 20, &#39;Длинная&#39;, &#39;Короткая&#39;)) ## [1] &quot;Длинная&quot; &quot;Длинная&quot; &quot;Длинная&quot; &quot;Короткая&quot; &quot;Длинная&quot; 2.1.1.6 Описательные статистики Можно получить краткую статистическую сводку по вектору (и любой другой структуре данных) с использованием функции summary(). Для качественных переменных выдаются частоты вхождения каждого случая, для количественных — набор основных описательных статистик: summary(lengths) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 19 28 38 34 40 45 summary(opens) ## Mode FALSE TRUE ## logical 3 2 2.1.2 Матрицы Матрица — это обобщение понятия вектора на 2 измерения. С точки зрения анализа данных матрицы ближе к реальным данным, посколько каждая матрица по сути представляет собой таблицу со столбцами и строками. Однако матрица, как и вектор, может содержать только элементы одного типа (числовые, строковые, логические и т.д.). Позже мы познакомимся с фреймами данных, которые не обладают подобным ограничением. Матрица, как правило, создается с помощью функции matrix, которая принимает 3 обязательных аргумента: вектор исходных значений, количество строк и количество столбцов: v = 1:12 # создадим вектор из натуральных чисел от 1 до 12 m = matrix(v, nrow = 3, ncol = 4) m ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 ## [3,] 3 6 9 12 По умолчанию матрица заполняется данными вектора по столбцам, что можно видеть в выводе программы. Если вы хотите заполнить ее по строкам, необходимо указать параметр byrow = TRUE: m = matrix(v, nrow = 3, ncol = 4, byrow = TRUE) m ## [,1] [,2] [,3] [,4] ## [1,] 1 2 3 4 ## [2,] 5 6 7 8 ## [3,] 9 10 11 12 Доступ к элементам матрицы осуществляется аналогично вектору, за исключением того что нужно указать положение ячейки в строке и столбце: m[2,4] # 2 строка, 4 толбец ## [1] 8 m[3,1] # 3 строка, 1 столбец ## [1] 9 Помимо этого, из матрицы можно легко извлечь одну строку или один столбец. Для этого достаточно указать только номер строки или столбца, а номер второго измерения пропустить до или после запятой. Результат является вектором: m[2,] # 2 строка ## [1] 5 6 7 8 m[,3] # 3 cтолбец ## [1] 3 7 11 К матрицам можно применять операции, аналогичные операциям над векторами: log(m) # натуральный логарифм ото всех элементов ## [,1] [,2] [,3] [,4] ## [1,] 0.000000 0.6931472 1.098612 1.386294 ## [2,] 1.609438 1.7917595 1.945910 2.079442 ## [3,] 2.197225 2.3025851 2.397895 2.484907 sum(m) # сумма всех элементов матрицы ## [1] 78 median(m) # медиана ## [1] 6.5 B и получать по ним описательные статистики: summary(m) ## V1 V2 V3 V4 ## Min. :1 Min. : 2 Min. : 3 Min. : 4 ## 1st Qu.:3 1st Qu.: 4 1st Qu.: 5 1st Qu.: 6 ## Median :5 Median : 6 Median : 7 Median : 8 ## Mean :5 Mean : 6 Mean : 7 Mean : 8 ## 3rd Qu.:7 3rd Qu.: 8 3rd Qu.: 9 3rd Qu.:10 ## Max. :9 Max. :10 Max. :11 Max. :12 А вот сортировка матрицы приведет к тому что будет возвращен обычный вектор: sort(m) ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 К матрицам также применимы специальные функции, известные из линейной алгебры, такие как транспонирование и вычисление определителя: t(m) # транспонированная матрица ## [,1] [,2] [,3] ## [1,] 1 5 9 ## [2,] 2 6 10 ## [3,] 3 7 11 ## [4,] 4 8 12 m2=matrix(-3:3,nrow = 3, ncol = 3) m2 ## [,1] [,2] [,3] ## [1,] -3 0 3 ## [2,] -2 1 -3 ## [3,] -1 2 -2 det(m2) # определитель матрицы ## [1] -21 det(m) # ошибка! определитель вычисляется только для квадратных матриц ## Error in determinant.matrix(x, logarithm = TRUE, ...): &#39;x&#39; must be a square matrix Матрицы также можно перемножать с помощью специального оператора %*%. При этом, как мы помним, число столбцов в первой матрице должно равняться числу строк во второй: m2 %*% m ## [,1] [,2] [,3] [,4] ## [1,] 24 24 24 24 ## [2,] -24 -28 -32 -36 ## [3,] -9 -10 -11 -12 m %*% m2 # ошибка! ## Error in m %*% m2: неподобные аргументы Функция match(), которую мы использовали для поиска элементов в векторе, не работает для матриц. Вместо этого необходимо использовать функцию which(). Если мы хотим найти в матрице m позицию числа \\(8\\), то вызов функции будет выглядеть так: which(m == 8, arr.ind = TRUE) ## row col ## [1,] 2 4 В данном случае видно, что результат возвращен в виде матрицы \\(1 \\times 2\\). Обратите внимание на то, что колонки матрицы имеют названия. Попробуем использовать найденные индексы, чтобы извлечь искомый элемент: indexes = which(m == 8, arr.ind = TRUE) row = indexes[1,1] col = indexes[1,2] m[row,col] ## [1] 8 Ура! Найденный элемент действительно равен \\(8\\). Еще один полезный способ создания матрицы — это собрать ее из нескольких векторов, объединив их по строкам. Для этого можно использовать функции cbind() и rbind(). На предыдущем занятии мы создали векторы с длиной и количеством станций на разных ветках метро. Можно объединить их в одну матрицу: lengths = c(28, 40, 45, 19, 38) stations = c(20, 21, 22, 12, 24) cbind(lengths, stations) # соединим вектора в качестве столбцов ## lengths stations ## [1,] 28 20 ## [2,] 40 21 ## [3,] 45 22 ## [4,] 19 12 ## [5,] 38 24 rbind(lengths, stations) # соединим вектора в качестве строк ## [,1] [,2] [,3] [,4] [,5] ## lengths 28 40 45 19 38 ## stations 20 21 22 12 24 Cтроки и столбцы матрицы можно использовать как векторы при выполнении арифметических операций: mm = cbind(lengths, stations) mm[,2]/mm[,1] # количество станций на 1 км пути ## [1] 0.7142857 0.5250000 0.4888889 0.6315789 0.6315789 Результат можно присоединить к уже созданной матрице: dens = mm[,2]/mm[,1] mm=cbind(mm, dens) mm ## lengths stations dens ## [1,] 28 20 0.7142857 ## [2,] 40 21 0.5250000 ## [3,] 45 22 0.4888889 ## [4,] 19 12 0.6315789 ## [5,] 38 24 0.6315789 Содержимое матрицы можно просмотреть в более привычном табличном виде для этого откройте вкладку Environment и щелкните на строку с матрицей в разделе Data Матрицы, однако, не дотягивают по функциональности до представления таблиц, и не предназначены для объединения разнородных данных в один набор (как мы это сделали). Если вы присоедините к матрице столбец с названиями веток метро, система не выдаст сообщение об ошибке, но преобразует матрицу в текстовую, так как текстовый тип данных способен представить любой другой тип данных: colors = c(&quot;Красная&quot;, &quot;Зеленая&quot;, &quot;Синяя&quot;, &quot;Коричневая&quot;, &quot;Оранжевая&quot;) mm2=cbind(mm,colors) mm2 # обратите внимание на то, что вокруг чисел добавились кавычки ## lengths stations dens colors ## [1,] &quot;28&quot; &quot;20&quot; &quot;0.714285714285714&quot; &quot;Красная&quot; ## [2,] &quot;40&quot; &quot;21&quot; &quot;0.525&quot; &quot;Зеленая&quot; ## [3,] &quot;45&quot; &quot;22&quot; &quot;0.488888888888889&quot; &quot;Синяя&quot; ## [4,] &quot;19&quot; &quot;12&quot; &quot;0.631578947368421&quot; &quot;Коричневая&quot; ## [5,] &quot;38&quot; &quot;24&quot; &quot;0.631578947368421&quot; &quot;Оранжевая&quot; При попытке выполнить арифметическое выражение над прежде числовыми полями, вы получите сообщение об ошибке: mm2[,2]/mm2[,1] ## Error in mm2[, 2]/mm2[, 1]: нечисловой аргумент для бинарного оператора 2.1.3 Массивы Массивы (arrays) — это многомерные структуры данных, с колчеством измерений 3 и более. Трехмерный массив представляет собой куб однородных данных. Для создания массива используется функция array(): z = array(1:36, c(3,4,2)) # вектор значений для заполнения массива, а также длина каждого измерения print(z) ## , , 1 ## ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 ## [3,] 3 6 9 12 ## ## , , 2 ## ## [,1] [,2] [,3] [,4] ## [1,] 13 16 19 22 ## [2,] 14 17 20 23 ## [3,] 15 18 21 24 Массивы возникают тогда, например, когда имеются многомерные данные, зафиксированные по регулярной сетке географичесих локаций (это типично для геофизических данных). При этом 2 измерения отвечают за местоположение, а третье измерение — за временной срез или показатель. 2.2 Разнородные структуры данных 2.2.1 Фреймы данных Фреймы данных — это обобщение понятия матрицы на данные смешанных типов. Фреймы данных - наиболее распространенный формат представления табличных данных. Для краткости мы иногда будем называть их просто фреймами. Мы специально не используем для перевода слова data.frame термин ‘таблица’, поскольку таблица — это достаточно общая категория, которая описывает концептуальный способ упорядочивания данных. В том же языке R для представления таблиц могут быть использованы как минимум две структуры данных: фрейм данных (data.frame) и тиббл (tibble), доступный в соответствующем пакете. Мы не будем использовать тибблы в настоящем курсе, но после его освоения вы вполне сможете ознакомиться с ними самостоятельною Для создания фреймов данных используется функция data.frame(): df = data.frame(colors,lengths,stations) df # как мы видим, уже никаких кавычек вокруг чисел ## colors lengths stations ## 1 Красная 28 20 ## 2 Зеленая 40 21 ## 3 Синяя 45 22 ## 4 Коричневая 19 12 ## 5 Оранжевая 38 24 К фреймам также можно пристыковывать новые столбцы: df = cbind(df, dens) df ## colors lengths stations dens ## 1 Красная 28 20 0.7142857 ## 2 Зеленая 40 21 0.5250000 ## 3 Синяя 45 22 0.4888889 ## 4 Коричневая 19 12 0.6315789 ## 5 Оранжевая 38 24 0.6315789 Когда фрейм данных формируется посредством функции data.frame() и cbind(), названия столбцов берутся из названий векторов. Обратите внимание на то, что листинге выше столбцы имеют заголовки, а строки — номера. Как и прежде, к столбцам и строкам можно обращаться по индексам: df[2,2] ## [1] 40 df[,3] ## [1] 20 21 22 12 24 df[4,] ## colors lengths stations dens ## 4 Коричневая 19 12 0.6315789 Вы можете обращаться к отдельным столбцам фрейма данных по их названию, используя оператор $ (доллар): df$lengths ## [1] 28 40 45 19 38 df$stations ## [1] 20 21 22 12 24 Так же как и ранее, можно выполнять различные операции над столбцами: max(df$stations) ## [1] 24 df$lengths / df$stations ## [1] 1.400000 1.904762 2.045455 1.583333 1.583333 Названия столбцов можно получить с помощью функции colnames() colnames(df) ## [1] &quot;colors&quot; &quot;lengths&quot; &quot;stations&quot; &quot;dens&quot; Чтобы присоединить строку, сначала можно создать фрейм данных из одной строки: row = data.frame(&quot;Фиолетовая&quot;, 40.5, 22, 22/45) Далее нужно убедиться, что столбцы в этом мини-фрейме называются также как и в том фрейме, куда мы хотим присоединить строку. Для этого нужно перезаписать результат, возвращаемый функцией colnames(): colnames(row) = colnames(df) Обратите внимание на синтаксис вышеприведенного выражения. Когда функция возвращает результат, она обнаруживает свойство самого объекта, и мы можем его перезаписать. После того как столбцы приведены в соответствие, можно присоединить новую строку: df = rbind(df,row) Чтобы отсортировать фрейм данных по значению определенного поля, необходимо узнать порядок элементов в этом поле с помощью функции order() и проиндексировать им первое измерение фрейма: df[order(df$lengths), ] ## colors lengths stations dens ## 4 Коричневая 19.0 12 0.6315789 ## 1 Красная 28.0 20 0.7142857 ## 5 Оранжевая 38.0 24 0.6315789 ## 2 Зеленая 40.0 21 0.5250000 ## 6 Фиолетовая 40.5 22 0.4888889 ## 3 Синяя 45.0 22 0.4888889 Чтобы отфильтровать фрейм данных по значению определенного поля, необходимо передать условие в первое измерение фрейма: df[df$lengths &gt; 40, ] ## colors lengths stations dens ## 3 Синяя 45.0 22 0.4888889 ## 6 Фиолетовая 40.5 22 0.4888889 Поскольку названия столбцов хранятся как вектор из строк, мы можем их переделать: colnames(df) = c(&quot;Цвет&quot;,&quot;Длина&quot;,&quot;Станции&quot;,&quot;Плотность&quot;) colnames(df) ## [1] &quot;Цвет&quot; &quot;Длина&quot; &quot;Станции&quot; &quot;Плотность&quot; Обратимся по новому названию столбца: df$Длина ## [1] 28.0 40.0 45.0 19.0 38.0 40.5 К фреймам данных, так же как и к однородным структурам, можно применять функцию summary() для получения описательных статистик. При этом отчет формируется по каждому столбцу: summary(df) ## Цвет Длина Станции Плотность ## Зеленая :1 Min. :19.00 Min. :12.00 Min. :0.4889 ## Коричневая:1 1st Qu.:30.50 1st Qu.:20.25 1st Qu.:0.4979 ## Красная :1 Median :39.00 Median :21.50 Median :0.5783 ## Оранжевая :1 Mean :35.08 Mean :20.17 Mean :0.5800 ## Синяя :1 3rd Qu.:40.38 3rd Qu.:22.00 3rd Qu.:0.6316 ## Фиолетовая:1 Max. :45.00 Max. :24.00 Max. :0.7143 2.2.2 Списки Список — это наиболее общий тип контейнера в R. Список отличается от вектора тем, что он может содержать набор объектов произвольного типа. В качестве элементов списка могут быть числа, строки, вектора, матрицы, фреймы данных — и все это в одном контейнере. Списки используются чтобы комбинировать разрозненную информацию. Результатом выполнения многих функций является список. Например, можно создать список из текстового описания фрейма данных, самого фрейма данных и обобщающей статистики по нему: d = &quot;Этот фрейм данных содержит данные по 6 линиям Московского метро&quot; s = summary(df) # summary() выдает обобщающую статистику вектору, матрице или фрейму данных Сооружаем список из трех элементов: metrolist = list(d, df, s) metrolist ## [[1]] ## [1] &quot;Этот фрейм данных содержит данные по 6 линиям Московского метро&quot; ## ## [[2]] ## Цвет Длина Станции Плотность ## 1 Красная 28.0 20 0.7142857 ## 2 Зеленая 40.0 21 0.5250000 ## 3 Синяя 45.0 22 0.4888889 ## 4 Коричневая 19.0 12 0.6315789 ## 5 Оранжевая 38.0 24 0.6315789 ## 6 Фиолетовая 40.5 22 0.4888889 ## ## [[3]] ## Цвет Длина Станции Плотность ## Зеленая :1 Min. :19.00 Min. :12.00 Min. :0.4889 ## Коричневая:1 1st Qu.:30.50 1st Qu.:20.25 1st Qu.:0.4979 ## Красная :1 Median :39.00 Median :21.50 Median :0.5783 ## Оранжевая :1 Mean :35.08 Mean :20.17 Mean :0.5800 ## Синяя :1 3rd Qu.:40.38 3rd Qu.:22.00 3rd Qu.:0.6316 ## Фиолетовая:1 Max. :45.00 Max. :24.00 Max. :0.7143 Можно дать элементам списка осмысленные названия при создании: metrolist = list(desc = d, table = df, summary = s) metrolist ## $desc ## [1] &quot;Этот фрейм данных содержит данные по 6 линиям Московского метро&quot; ## ## $table ## Цвет Длина Станции Плотность ## 1 Красная 28.0 20 0.7142857 ## 2 Зеленая 40.0 21 0.5250000 ## 3 Синяя 45.0 22 0.4888889 ## 4 Коричневая 19.0 12 0.6315789 ## 5 Оранжевая 38.0 24 0.6315789 ## 6 Фиолетовая 40.5 22 0.4888889 ## ## $summary ## Цвет Длина Станции Плотность ## Зеленая :1 Min. :19.00 Min. :12.00 Min. :0.4889 ## Коричневая:1 1st Qu.:30.50 1st Qu.:20.25 1st Qu.:0.4979 ## Красная :1 Median :39.00 Median :21.50 Median :0.5783 ## Оранжевая :1 Mean :35.08 Mean :20.17 Mean :0.5800 ## Синяя :1 3rd Qu.:40.38 3rd Qu.:22.00 3rd Qu.:0.6316 ## Фиолетовая:1 Max. :45.00 Max. :24.00 Max. :0.7143 Теперь можно обратиться к элементу списка по его названию: metrolist$summary ## Цвет Длина Станции Плотность ## Зеленая :1 Min. :19.00 Min. :12.00 Min. :0.4889 ## Коричневая:1 1st Qu.:30.50 1st Qu.:20.25 1st Qu.:0.4979 ## Красная :1 Median :39.00 Median :21.50 Median :0.5783 ## Оранжевая :1 Mean :35.08 Mean :20.17 Mean :0.5800 ## Синяя :1 3rd Qu.:40.38 3rd Qu.:22.00 3rd Qu.:0.6316 ## Фиолетовая:1 Max. :45.00 Max. :24.00 Max. :0.7143 Поскольку summary сама является фреймом данных, из нее можно извлечь столбец: metrolist$summary[,3] ## ## &quot;Min. :12.00 &quot; &quot;1st Qu.:20.25 &quot; &quot;Median :21.50 &quot; &quot;Mean :20.17 &quot; ## ## &quot;3rd Qu.:22.00 &quot; &quot;Max. :24.00 &quot; К элементу списка можно также обратиться по его порядковому номеру или названию, заключив их в двойные квадратные скобки: metrolist[[1]] ## [1] &quot;Этот фрейм данных содержит данные по 6 линиям Московского метро&quot; metrolist[[&quot;desc&quot;]] ## [1] &quot;Этот фрейм данных содержит данные по 6 линиям Московского метро&quot; Использование двойных скобок отличает списки от векторов. Вызов функции summary() в приложении к списку выведет статистику по типам и количеству элементов списка: summary(metrolist) ## Length Class Mode ## desc 1 -none- character ## table 4 data.frame list ## summary 24 table character 2.3 Факторы Понятие фактора в терминологии R используется для обозначения категориальной (качественной) переменной. Как известно, такие переменные могут быть номинальными (с неопределенным порядком) и порядковыми (с заданным отношением порядка). Проблема взаимодействия с категориальными переменными заключается в том, что они могут приобретать разнообразные формы: быть выражены в виде чисел и строк. Эта форма может быть обманчивой. Например, модели самолетов Boeing и Sukhoi SuperJet обознаются числами (747, 100 и т.д.). Однако очевидно, что складывать и вычитать такие числа смысла нет, они являются формой представления номинальной переменной. Другой пример: названия месяцев записываются в виде строк. Если попытаться отсортировать месяцы цветения различных видов деревьев, то получится бессмысленный алфавитный порядок, в котором апрель следует за августом. В данном случае проблема заключается в том, что мы имеем дело с категориальной переменной, в которой задан порядок следования допустимых значений. В географических данных категориальные переменные тоже достаточно распространены. К номинальной шкале измерений относятся всевозможные числовые коды: почтовые, ОКАТО и т.д. К порядковой шкале - административный статус населенного пункта, сила землетрясения по шкале Рихтера. Для того, чтобы соответствующие данные в среде R правильно обрабатывались статистическими функциями и отображались в виде подходящих графических способов, необходимо явным образом проинформировать об этом программу. Для этого и создаются факторы. Фактор построен по принципу ассоциативного массива и является надстройкой над вектором, в которой каждому значению вектора присваивается некий код. Вы можете управлять этими кодами, а можете оставить их на усмотрение программы. Например, каждая линия Московского метро имеет свой номер. Создадим небольшей фрейм данных с электродепо по интересующим нас веткам метро и рассчитаем по ним описательные статистики: depots = data.frame( depot = c(&#39;Северное&#39;, &#39;Черкизово&#39;, &#39;Сокол&#39;, &#39;Замоскворецкое&#39;, &#39;Братеево&#39;, &#39;Измайлово&#39;, &#39;Фили&#39;, &#39;Митино&#39;, &#39;Красная Пресня&#39;, &#39;Калужское&#39;, &#39;Свиблово&#39;), year_opened = c(1935, 1990, 1938, 1969, 2014, 1950, 1962, 2016, 1954, 1962, 1978), line_number = c(1, 1, 2, 2, 2, 3, 3, 3, 5, 6, 6) ) print(depots) ## depot year_opened line_number ## 1 Северное 1935 1 ## 2 Черкизово 1990 1 ## 3 Сокол 1938 2 ## 4 Замоскворецкое 1969 2 ## 5 Братеево 2014 2 ## 6 Измайлово 1950 3 ## 7 Фили 1962 3 ## 8 Митино 2016 3 ## 9 Красная Пресня 1954 5 ## 10 Калужское 1962 6 ## 11 Свиблово 1978 6 summary(depots) ## depot year_opened line_number ## Братеево :1 Min. :1935 Min. :1.000 ## Замоскворецкое:1 1st Qu.:1952 1st Qu.:2.000 ## Измайлово :1 Median :1962 Median :3.000 ## Калужское :1 Mean :1970 Mean :3.091 ## Красная Пресня:1 3rd Qu.:1984 3rd Qu.:4.000 ## Митино :1 Max. :2016 Max. :6.000 ## (Other) :5 Как видно, R посчитал нам средний номер линии метро - 3.091, что выглядит, мягко говоря, странновато. Чтобы этого не происходило, укажем в явном виде с помощью функции factor(), что номер линии метров является номинальной переменной: depots$line_number = as.factor(depots$line_number) print(depots$line_number) ## [1] 1 1 2 2 2 3 3 3 5 6 6 ## Levels: 1 2 3 5 6 Мы видим, что у переменной появился дополнительный атрибут Levels, который отвечает за список уникальных значений номинальной переменной. Отношение порядка мы здесь не вводим, поскольку номер является условным обозначением. Попробуем теперь посчитать описательные статистики по переменной и таблице в целом: mean(depots$line_number) ## [1] NA summary(depots) ## depot year_opened line_number ## Братеево :1 Min. :1935 1:2 ## Замоскворецкое:1 1st Qu.:1952 2:3 ## Измайлово :1 Median :1962 3:3 ## Калужское :1 Mean :1970 5:1 ## Красная Пресня:1 3rd Qu.:1984 6:2 ## Митино :1 Max. :2016 ## (Other) :5 Теперь мы видим, что вместо стандартных статистик R для переменной line_number выдает таблицу частот, из которой ясно, что на первой линии два депо, на второй линии три депо и так далее. 2.4 Описание структуры данных Для описания структуры данных можно использовать две широко используемые диагностические функции: class() выведет тип структуры, а str() выведет детальную выписку по компонентам этой структуры: class(depots) # тип объекта ## [1] &quot;data.frame&quot; str(depots) # структура объекта ## &#39;data.frame&#39;: 11 obs. of 3 variables: ## $ depot : Factor w/ 11 levels &quot;Братеево&quot;,&quot;Замоскворецкое&quot;,..: 8 11 9 2 1 3 10 6 5 4 ... ## $ year_opened: num 1935 1990 1938 1969 2014 ... ## $ line_number: Factor w/ 5 levels &quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;5&quot;,..: 1 1 2 2 2 3 3 3 4 5 ... 2.5 Циклы Цикл — это разновидность управляющей конструкции, предназначенная для организации многократного исполнения набора инструкций. В R циклы наиболее часто используются для пакетной обработки данных, ввода и вывода. Типичными примерами использования циклов являются чтение множества файлов входных данных, а также построение серий графиков и карт одного типа по различным данным. При этом обработка множества строк таблиц в R обычно организуется не средствами циклов, а средствами функций семейства lapply, о которых мы поговорим в главе, посвященной техникам программирования на R. Циклы обычно связаны с проходом по элементам списка/вектора либо с созданием такого списка/вектора. Поэтому они излагаются в настоящей главе. В R, как и во многих других языках программирования, существует несколько вариантов циклов. Первый вид циклов — это конструкция for с синтаксисом for (x in X) statement. Она означает, что: переменная x должна пробежать по всем элементам последовательности X. В качестве последовательности может выступать любой вектор или список. каждый раз, когда x будет присвоено значение очередного элемента из X, будет выполнено выражение statement, которое называют телом цикла. Соответственно, цикл выполнится столько раз, сколько элементов содержится в последовательности X. Выполнение тела цикла на каждом проходе называют итерацией. Например, с помощью цикла можно вывести на экран числа от 1 до 10, по одному с каждой строки: ## ЦИКЛЫ for (i in 1:10) print(i) ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 ## [1] 7 ## [1] 8 ## [1] 9 ## [1] 10 Если тело цикла содержит более одной инструкции R, оно должно быть заключено в фигурные скобки, иначе выполнится только первое выражение, а оставшиеся будут запущены один раз после выхода из цикла: for (i in 1:10) { a = factorial(i) # факториал i b = exp(i) # e в степени i print(a/b) # факториал растет быстрее экспоненты } ## [1] 0.3678794 ## [1] 0.2706706 ## [1] 0.2987224 ## [1] 0.4395753 ## [1] 0.8085536 ## [1] 1.784702 ## [1] 4.595885 ## [1] 13.52585 ## [1] 44.78295 ## [1] 164.7473 Другой вариант цикла организуется с помощью конструкции while, имеющей синтаксис while (condition) statement. Такая конструкция означает, что тело цикла будет выполняться, пока значение выражения condition (условия) равно TRUE. Как правило, в теле цикла обновляется некоторая переменная, которая участвует в проверке условия, и предполагается, что рано или поздно оно станет равным FALSE, что приведет к выходу из цикла. Например, вышеприведенный цикл, печатающий числа от 1 до 10, можно переписать на while следуюшим образом: i = 0 while(i &lt; 10) { i = i+1 print(i) } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 ## [1] 7 ## [1] 8 ## [1] 9 ## [1] 10 Обратите внимание на то, что мы внутри цикла обновляем значение переменной i. Увеличение значения переменной цикла называется инкрементом, а уменьшение — декрементом. Одной из самых распространенных ошибок программистов (особенно начинающих, но и професионалы ее не избегают) является забытая инструкция инкремента (или декремента) переменной цикла, в результате чего цикл становится бесконечным. В этом плане конструкция for более надежна. В качестве примера приведем проход по столбцам фрейма данных и вычисление медианного значения для каждого столбца таблицы линий метро: n = ncol(df) medians = vector(&#39;numeric&#39;, n) for (i in 1:n) { if(is.numeric(df[, i])){ medians[i] = median(df[, i]) } else { medians[i] = NA } } colnames(df) # Переменные ## [1] &quot;Цвет&quot; &quot;Длина&quot; &quot;Станции&quot; &quot;Плотность&quot; medians # Медианные значения ## [1] NA 39.0000000 21.5000000 0.5782895 Существуют специальные операторы, позволяющие принудительно прервать текущую итерацию цикла и перейти на следующую, а также выйти из цикла вообще. Они называются next и break. Они бывают полезны, когда в теле цикла может произойти событие, делающее невозможным (или бессмысленным) его дальнейшее выполнение. Например, мы можем выводить информацию об электродепо, имеющихся на линии метро с введенным пользователем номером, до тех пор, пока он не введет символ q. Чтобы цикл был бесконечным, используем специальную форму while (TRUE): while (TRUE) { cat(&#39;Введите номер ветки метро:&#39;) input = readline() if (input == &#39;q&#39;) break else { n = as.numeric(input) if (!is.na(n)) depots[depots$line_number == n, ] } } Оператор next используется реже, так как в принципе он взаимозаменяем с конструкцией if-else. Он бывет удобен, когда в длинном цикле имеется несколько мест, в которых возможен переход на следующую итерацию. При использовании next последующий код нет необходимости табулировать и забирать в скобки. Следующие паттерны идентичны, но вариант с next позволяет остаться на том же уровне вложенности: Паттерн 1: while (...) { if (condition1) next ... # сюда попадем, только если condition1 == FALSE if (condition2) next ... # сюда попадем, только если condition2 == FALSE } Паттерн 2: while (...) { if (!condition1) { ... # сюда попадем, только если condition1 == FALSE if (!condition2) { ... # сюда попадем, только если condition2 == FALSE } } } 2.6 Технические детали Внутреннюю структуру и размер объекта можно исследовать с помощью пакета lobstr. Например, посмотрим, как организован в пямяти объект metrolist: library(lobstr) ref(metrolist) ## █ [1:0x7fb04cf7f2f8] &lt;named list&gt; ## ├─desc = [2:0x7fb04c6d8920] &lt;chr&gt; ## ├─table = █ [3:0x7fb02b83a938] &lt;df[,4]&gt; ## │ ├─Цвет = [4:0x7fb04ca70978] &lt;fct&gt; ## │ ├─Длина = [5:0x7fb04bd723c8] &lt;dbl&gt; ## │ ├─Станции = [6:0x7fb02b270c38] &lt;dbl&gt; ## │ └─Плотность = [7:0x7fb04b520028] &lt;dbl&gt; ## └─summary = [8:0x7fb069f959f0] &lt;table&gt; obj_size(metrolist) ## 5,696 B 2.7 Краткий обзор Для просмотра презентации щелкните на ней один раз левой кнопкой мыши и листайте, используя кнопки на клавиатуре: Презентацию можно открыть в отдельном окне или вкладке браузере. Для этого щелкните по ней правой кнопкой мыши и выберите соответствующую команду. 2.8 Контрольные вопросы и упражнения 2.8.1 Вопросы На какие две большие группы можно разделить структуры данных в R? Чем он отличаются? Что такое вектор в языке R? Какие способы создания векторов существуют? Можно ли хранить в векторе данные разных типов? Как определить длину вектора? Как извлечь из вектора элемент по его индексу? Как извлечь из вектора множество элементов по их индексам? Как извлечь из вектора последний элемент? С помощью какой функции можно сгенерировать последовательность чисел или дат с заданным шагом? Как сгенерировать последовательность целых чисел с шагом 1, не прибегая к функциям? Можно ли применять к векторам арифметические операторы и математические функции? Что будет результатом их выполнения? С помощью какой функции можно отсортировать вектор? Как изменить порядок сортировки на противоположный? С помощью какой функции можно найти индекс элемента вектора по его значению? Что вернет функция, если этот элемент встречается в векторе несколько раз? Как работает функция ifelse() и для чего она используется? Как работает функция summary() и для чего она используется? Какая функция позволяет создать матрицу? По строкам или по столбцам заполняется матрица при использовании вектора как источника данных по умолчанию? Как извлечь элемент по его индексам из матрицы, массива, фрейма данных, списка? Как извлечь строку или столбец из матрицы или фрейма данных? С помощью какого специального символа можно обратиться к столбцу фрейма данных по его названию? Как получить или записать названия столбцов фрейма данных? Как получить или записать названия строк фрейма данных? Какая структура данных является результатом сортировки матрицы? Какая функция позволяет осуществить транспонирование матрицы? Какой оператор используется для умножения матриц? Каким критериям должны отвечать перемножаемые матрицы, чтобы эта операция была осуществима? Как добавить новый столбец в фрейм данных? Опишите несколько вариантов. Как добавить новую строку в фрейм данных? Что произойдет, если к целочисленной матрице прибавить столбец, заполненный строками? Какая функция позволяет находить индексы элементов матрицы или фрейма данных по их значениям? Что такое цикл и для каких сценариев обработки данных могут быть полезны циклы? Перечислите несколько способов организации циклов в R, необходимые ключевые слова и параметры. Что такое инкремент и декремент? Какое ключевое слово позволяет прервать цикл и выйти из него принудительно? Какое ключевое слово позволяет прекратить текущую итерацию цикла и перейти сразу к новой итерации? Являются ли необходимыми фигурные скобки в случае когда цикл или условный оператор содержит только одно выражение? Что говорит об этом стиль программирования на R? 2.8.2 Упражнения Создайте вектор temp, в котором хранятся значения среднемесячных температур воздуха в городе Санкт-Петербурге (данные можно взять здесь). Напишите программный код, который вычисляет следующие вектора: количественное изменение температуры от месяца к месяцу (в градусах) качественное изменение температуры от месяца к месяцу ('потепление' или 'похолодание'); номера зимних месяцев (со среднемесячной температурой ниже нуля); описательные статистики среднемесячных температур (summary); Выведите исходные и вычисленные данные в консоль (с пояснением что они означают). Подсказка: для вычисления разностей между элементами вектора используйте функцию diff(). На местности задан прямоугольник с координатами левого нижнего (x1, y1) и правого верхнего (x2, y2) угла. Напишите программу, которая размещает внутри этого прямоугольника случайным образом N точек и представляет результат в виде матрицы координат coords с двумя столбцами и N строками. Вызовите в конце программы plot(coords), чтобы посмотреть на результат. Координаты можно не вводить, а задать прямо в программе в виде переменных. Подсказка: координаты случайно размещенных точек имеют равномерное распределение. Вам необходимо сначала сформировать случайные векторы координат X и Y, и после этого объединить их в матрицу. Высотная поясность на северном склоне Западного Кавказа, согласно Большой Российской энциклопедии устроена следующим образом: до 500 м — степь и лесостепь до 800 м — низкогорные широколиственные леса (дуб, граб) до 1300 м — среднегорные широколиственные леса (бук) до 1600 м — смешанные леса (ель, пихта, бук) до 2300 м — криволесия (береза, бук, клён) до 2500 м — субальпийские и альпийские луга до 3300 м — субнивальная зона (фрагментарная растительность) выше (условно до 5000 м) — гляциально-нивальная зона Создайте фрейм данных, включающий три столбца: минимальная высота пояса (Hmin), максимальная высота пояса (Hmax) и название высотного пояса (Zone). Минимальную высоту надо вычислить на основе максимальной, приняв, что для нижнего пояса она условно равна \\(400~м\\). Напишите программу, которая просит пользователя ввести высоту и возвращает высотный пояс, соответствующую введенной высоте (достаточно вывести строчку фрейма данных). Подсказка: Организуйте обход строчек фрейма данных с помощью цикла от \\(1\\) до \\(N\\), где \\(N\\) — количество строк. Искомый пояс будет найден, как только введенное значение станет меньше чем Hmax. После этого можно вывести результат на экран. Если введенное значение больше максимума в столбце Hmax или меньше \\(400\\), программа должна выдавать ошибку. [advanced] Решите задачу №3, используя только операции над векторами и поиск элементов, и не используя циклы. [advanced] Модифицируйте программу, написанную для решения задачи №2 таким образом, чтобы запретить точкам сближаться более чем на заданное расстояние k (это называется регулярным распределением с расстоянием ингибиции k). Сохраните результат в виде фрейма данных points со столбцами X, Y и D, где D – это расстояние до ближайшей точки. Выведите верхние строчки полученной таблицы в консоль, а также полученные точки с помощью команды plot(coords$X, coords$Y). Подсказка: вам придется генерировать в цикле по одной точке и проверять условие на каждой итерации до тех пор, пока вы не наберете требуемое количество точек. Задавайте значение k малым по отношению к размерам прямоугольника, чтобы избежать излишне долгого выполнения программы. Самсонов Т.Е. Визуализация и анализ географических данных на языке R. М.: Географический факультет МГУ, 2020. DOI: 10.5281/zenodo.901911 "],
["tables.html", "Глава 3 Табличные данные 3.1 Предварительные требования 3.2 Структуры данных 3.3 Чтение 3.4 Просмотр 3.5 Столбцы, строки и ячейки 3.6 Преобразования 3.7 Соединение 3.8 Запись 3.9 Рекомендации по подготовке таблиц для чтения в R 3.10 Краткий обзор 3.11 Контрольные вопросы и упражнения", " Глава 3 Табличные данные 3.1 Предварительные требования Для работы по теме текущей лекции вам понадобятся пакеты из tidyverse, а также writexl. Установите их, используя следующую команду: install.packages(&#39;tidyverse&#39;) install.packages(&#39;writexl&#39;) Внимание: установка пакетов выполняется один раз из консоли. Вызов функции install.packages() не должен присутствовать в ваших скриптах tidyverse – это не самостоятельный пакет, а набор пакетов R, которые позволяют автоматизировать решение рутинных задач по обработке данных (то, что принято называть data science). В комплект tidyverse входят следующие пакеты: Пакет Назначение tibble Усовершенствованный вариант фрейма данных dplyr Грамматика манипуляций над табличными данными tidyr Приведение таблиц в аккуратный вид, удобный для обработки readr Чтение табличных данных из текстовых файлов readxl Чтение табличных данных из файлов Microsoft Excel haven Чтение табличных данных из файлов SPSS, Stata и SAS purrr Функциональное программирование stringr Работа со строками forcats Автоматизация работы с факторами ggplot2 Построение графиков на основе правил грамматики Вы можете подключать эти пакеты по одному, или сделать их все доступными в текущей сессии R, используя команду library(tidyverse). В текущей лекции мы будем подключать их по мере необходмости, чтобы акцентировать внимание на принадлежности функций к соответствующим пакетам. Вы можете вызвать функцию из любого пакета, не подключая его целиком в текущую сессию R. Это бывает особенно полезно, когда вы редко используете функции из пакета. В этом случае вызов функции будет выглядеть как package::function(), где package – название пакета, а function - название функции. Подобный синтаксис бывает особенно удобным, когда в разных пакетах имеются функции с одинаковым именем, и при вызове R использует не ту, которая нужна (по умолчанию будет использована функция из пакета, который был подключен позже). 3.2 Структуры данных Стандартным средством представления табличных данных в R являются фреймы данных (data.frame), кратко рассмотренные в предыдущей лекции. В современных пакетах типа tidyverse используется разновидность фрейма данных, которая называется тиббл (tibble). Создать тиббл можно напрямую, либо путем конвертации фрейма данных: library(tibble) tibble( a = 1:3, b = 1, c = -1:1 ) ## # A tibble: 3 x 3 ## a b c ## &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 1 1 -1 ## 2 2 1 0 ## 3 3 1 1 dfr = data.frame(a = 1:3, b = 1, c = -1:1) as_tibble(dfr) ## # A tibble: 3 x 3 ## a b c ## &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 1 1 -1 ## 2 2 1 0 ## 3 3 1 1 Тиббл является расширением класса фрейма данных, то есть любая операция, применимая к фрейму, применима и к тибблу. Однако, тиббл поддерживает дополнительные возможности, которые оказываются очень удобны в анализе: При выводе в консоль тиббл печатает только те столбцы, которые помещаются на экран, и только первые 10 строк (что позволяет избежать переполнения консоли при печати больших таблиц) Тибблы поддерживают имена столбцов, которые недопустимы в фреймах данных (например, начинающиеся с цифры). Так называть столбцы, вообще говоря, неправильно, но это позволяет сохранить именно те названия, которые даны в исходных файлах. Например, географические таблицы часто содержат данные за разные года, и столбцы названы по этим годам. Тибблы поддерживают внутренние группировки данных. Установив группировку по одной или нескольким переменным, можно эффективным и компактным путем считать агрегирующие статистики по группам измерений. Тибблы можно создавать вручную не только по столбцам, но и по строкам. Для реализации последней возможности можно использовать функцию tribble() (переводится как transposed tibble — транспонированный тиббл), указав имена столбцов с помощью тильды (~): tribble( ~a, ~b, ~c, 1, 1, -1, 2, 1, 0, 3, 1, 1 ) ## # A tibble: 3 x 3 ## a b c ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1 -1 ## 2 2 1 0 ## 3 3 1 1 В данной и последующих лекциях понятия мы будем использовать понятия таблица, фрейм данных и тиббл как взаимозаменяемые. 3.3 Чтение Существует множество способов получить набор табличных данных в текущей сессии R. Эти способы варьируются от загрузки данных из пакета до извлечения таблиц из текстовых документов и веб-страниц. В настоящей главе мы рассмотрим наиболее распространенные способы, нацеленные на работу с готовыми таблицами. 3.3.1 Встроенные данные Пакеты R часто содержат тестовые наборы данных. Эти данные, как правило, предназначены для ознакомления с возможностями пакета. Чтобы узнать, какие данные есть в пакете, вы можете вызвать функцию data(package = 'packagename'), где packagename — это имя интересующего вас пакета. Например, посмотрим, какие данные есть в пакете dplyr, который мы далее будем использовать для манипуляций с таблицами: data(package = &#39;dplyr&#39;) Данные, доступные в пакете dplyr На рисунке можно видеть перечень наборов данных и их краткие описания. Для загрузки набора данных передайте его название в качестве первого параметра функции data(). Ну-ка, что там с персонажами из Star Wars: data(starwars, package = &#39;dplyr&#39;) starwars ## # A tibble: 87 x 13 ## name height mass hair_color skin_color eye_color birth_year gender ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Luke… 172 77 blond fair blue 19 male ## 2 C-3PO 167 75 &lt;NA&gt; gold yellow 112 &lt;NA&gt; ## 3 R2-D2 96 32 &lt;NA&gt; white, bl… red 33 &lt;NA&gt; ## 4 Dart… 202 136 none white yellow 41.9 male ## 5 Leia… 150 49 brown light brown 19 female ## 6 Owen… 178 120 brown, gr… light blue 52 male ## 7 Beru… 165 75 brown light blue 47 female ## 8 R5-D4 97 32 &lt;NA&gt; white, red red NA &lt;NA&gt; ## 9 Bigg… 183 84 black light brown 24 male ## 10 Obi-… 182 77 auburn, w… fair blue-gray 57 male ## # … with 77 more rows, and 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, ## # films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt; Обратите внимание, что после подключения набора данных он становится доступным в текущей сесси R именно с тем именем, с которым он сохранен в пакете Если вызвать функцию data() без параметров, будет выведен список данных со всех пакетов, которые подключены в текущей сессии R: data() Данные, доступные в текущей сессии R По умолчанию в RStudio всегда подключен пакет datasets, который устанавливается вместе с базовым дистрибутивом R. Если пакет подключен в текущую сессию, то можно получить набор данных по его имени, не указывая название пакета. Например, в пакете datasets есть набор данных quakes о землетрясениях на о. Фиджи: data(quakes) head(quakes) # просмотрим макушку таблицы ## lat long depth mag stations ## 1 -20.42 181.62 562 4.8 41 ## 2 -20.62 181.03 650 4.2 15 ## 3 -26.00 184.10 42 5.4 43 ## 4 -17.97 181.66 626 4.1 19 ## 5 -20.42 181.96 649 4.0 11 ## 6 -19.68 184.31 195 4.0 12 Таким образом, если вы используйете пакет dplyr в своей программе, данные о героях Звездных Войн можно загрузить не указывая пакет, т.к. он был ранее подключен через функцию library(): library(dplyr) ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union data(starwars) 3.3.2 Текстовые таблицы Текстовые таблицы бывают, как правило, двух типов: с разделителем (CSV) и с фиксированной шириной столбца. 3.3.2.1 Файлы с разделителем CSV (Comma-separated value) — общее название для формата представления таблиц в виде текстовых файлов, организованных по следующему принципу: Каждая строка в файле соответствует строке в таблице. Ячейки отделяются друг от друга символом-разделителем. Если ячейка пустая, то между соседними разделителями не должно быть никаких символов. Стандартным разделителем ячеек является запятая (,), а десятичным разделителем — точка (.). Однако это не является строгим правилом. Например, в ряде локалей (например, русской) запятая используется в качестве десятичного разделителя, поэтому колонки часто разделяют точкой с запятой (;). Формат CSV никак не оговаривает наличие заголовочной строки с названиями столбцов в начале файла — она может как отсутствовать, так и присутствовать. Поэтому при чтении таблиц из файлов необходимо информировать программу о наличии заголовка путем указания соответствующего параметра. Любая функция, используемая вами для чтения файлов, вне зависимости от пакета, который вы используете, как правило, содержит параметры, с помощью которых можно задать символы, отвечающие за десятичный разделитель и разделитель столбцов, а также наличие или отсутствие строки-заголовка и кодировку файла. Если таблица читается некорректно, ознакомьтесь со справкой к функции и при необходимости замените стандартные значения этих параметров на те, что соответствуют формату вашей таблицы. Например, вот так выглядит текстовая таблица в формате CSV с данными по численности населения в Федеральных округах Российской Федерации за 2005 и 2010-2013 гг. (по данным Росстата): N,Region,Year05,Year10,Year11,Year12,Year13 1,Центральный,4341,3761,3613,3651,3570 2,Северо-Западный,3192,3088,2866,2877,2796 3,Южный федеральный,1409,1446,1436,1394,1321 4,Северо-Кавказский,496,390,397,395,374 5,Приволжский,3162,2883,2857,2854,2849 6,Уральский,1681,1860,1834,1665,1624 7,Сибирский,2575,2218,2142,2077,1941 8,Дальневосточный,871,870,821,765,713 Таблицы в формате CSV можно прочесть как с помощью стандартных средств языка R, так и с помощью пакета readr, который входит в набор пакетов tidyverse. Мы будем использовать последние, а стандартные средства языка оставим на самостоятельное изучение. Для чтения таблиц с разделителем в readr имеется несколько функций: read_csv() читает файлы с разделителем запятой read_csv2() читайт файоы с разделителем точкой-с-запятой (может быть особенно актуально для русских файлов) read_tsv() читает файлы с разделителем табуляцией или пробелом read_delim() читает файлы с произвольным разделителем (указывается в качестве параметра) Вышеуказанный файл сохранен с разделителем запятой, поэтому мы можем прочесть его посредством первой функции из списка: library(readr) (okruga = read_csv(&#39;data/okruga.csv&#39;)) ## Parsed with column specification: ## cols( ## `№` = col_double(), ## Регион = col_character(), ## `2005` = col_double(), ## `2010` = col_double(), ## `2011` = col_double(), ## `2012` = col_double(), ## `2013` = col_double() ## ) ## # A tibble: 8 x 7 ## `№` Регион `2005` `2010` `2011` `2012` `2013` ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 Центральный 4341 3761 3613 3651 3570 ## 2 2 Северо-Западный 3192 3088 2866 2877 2796 ## 3 3 Южный федеральный 1409 1446 1436 1394 1321 ## 4 4 Северо-Кавказский 496 390 397 395 374 ## 5 5 Приволжский 3162 2883 2857 2854 2849 ## 6 6 Уральский 1681 1860 1834 1665 1624 ## 7 7 Сибирский 2575 2218 2142 2077 1941 ## 8 8 Дальневосточный 871 870 821 765 713 Как видно, функции пакета readr выдают диагностическую информацию о том, к какому типу были приведены столбцы таблицы при чтении. Помимо этого, первая строка была использована в качестве заголовочной. 3.3.2.2 Файлы с фиксированной шириной столбца В файлах с фиксированной шириной на каждый столбец резервируется определенное количество символов. При этом данные выравниваются по правому краю, а короткие строки отбиваются слева пробелами. Такой формат часто используется в численных моделях (например, метеорологических) для представления входных данных или результатов расчетов. Например, файл ниже содержит данные об энергии ветра (\\(Вт/м^2\\)) на высотах 50 и 110 м по точкам вдоль побережья Черного моря: 1 43.500000 28.000000 111.05298 178.41447 2 43.500000 28.500000 187.38620 301.05331 3 44.000000 28.500000 168.82031 271.22421 4 44.500000 28.500000 157.22586 252.59746 5 44.500000 29.000000 189.46452 304.39597 6 45.000000 29.000000 170.40709 273.77536 7 45.000000 29.500000 198.92389 319.58777 8 45.500000 29.500000 188.64406 303.07242 9 46.000000 30.000000 180.10541 289.35379 10 46.000000 30.500000 207.91818 334.03564 Для чтения таких файлов в readr есть функции: read_fwf() читает файлы с фиксированной шириной столбца, позволяя задавать ширины столбцов (через fwf_widths()) или начальные позиции каждого столбца (через fwf_positions()) read_table() читает наиболее распространенный вариант файла с фиксированной шириной столбца, в котором колонки разделены пробелами. Позиции столбцов определяются автоматически, что очень удобно. Прочитаем вышеприведенный файл с данными о ветровой энергии: (wenergy = read_table(&#39;data/wind_energy.txt&#39;, col_names = c(&#39;id&#39;, &#39;lat&#39;, &#39;lon&#39;, &#39;energy50&#39;, &#39;energy110&#39;))) ## Parsed with column specification: ## cols( ## id = col_double(), ## lat = col_double(), ## lon = col_double(), ## energy50 = col_double(), ## energy110 = col_double() ## ) ## # A tibble: 92 x 5 ## id lat lon energy50 energy110 ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 43.5 28 111. 178. ## 2 2 43.5 28.5 187. 301. ## 3 3 44 28.5 169. 271. ## 4 4 44.5 28.5 157. 253. ## 5 5 44.5 29 189. 304. ## 6 6 45 29 170. 274. ## 7 7 45 29.5 199. 320. ## 8 8 45.5 29.5 189. 303. ## 9 9 46 30 180. 289. ## 10 10 46 30.5 208. 334. ## # … with 82 more rows 3.3.3 Таблицы Microsoft Excel Для чтения таблиц Microsoft Excel, так же как и для текcтовых файлов, существуют множество пакетов, таких как xlsx, openxlsx и readxl. D настоящем курсе мы будем пользоваться пакетом readxl, поскольку он не имеет внешних зависимостей, а его функции концептуально идентичны функциям пакета readr. Прочтем данные о лесовосстановлении (в тысяч га), полученные из регионального ежегодника Росстата за 2017 год. Эта таблица содержит колонку с названием субъекта и еще 8 колонок с данными по годам. Поскольку в таблице есть пропущенные значения, необходимо определить типы столбцов (в противном случае они могут быть определены как текстовые): library(readxl) (reforest = read_excel(&#39;data/reforest.xlsx&#39;, col_types = c(&#39;text&#39;, rep(&#39;numeric&#39;, 8)))) ## # A tibble: 89 x 9 ## Region `2005` `2010` `2011` `2012` `2013` `2014` `2015` `2016` ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Российская Федерация 812. 812. 860 842. 872. 863 803. 840. ## 2 Центральный федераль… 52.6 62.7 60.9 60.3 70.9 71.2 72.6 77 ## 3 Белгородская область 0.4 0.1 0.3 0.3 0.4 0.4 0.2 0.2 ## 4 Брянская область 2.9 2.8 3 3.2 3.5 3.3 3.1 3 ## 5 Владимирская область 4.4 5.3 5.7 6 7.1 5.9 6 4.9 ## 6 Воронежская область 1.1 1.1 1.8 3 2.7 2.7 2.6 2.3 ## 7 Ивановская область 2.1 1.6 2.2 3.1 4 4.8 4.6 4.2 ## 8 Калужская область 2.2 2.3 2.3 2.5 2.4 3.1 3.2 3.2 ## 9 Костромская область 10 25.2 11 11.8 15.3 13.6 15.1 16.4 ## 10 Курская область 0.5 0.3 0.4 0.6 0.6 0.6 0.5 0.4 ## # … with 79 more rows 3.3.4 Параметры Функции пакетов readr и readxl имеют идентичный набор параметров, позволяющих управлять процедурой чтения данных (многоточие используется вместо перечисления параметров): skip = n позволяет пропустить первые n строк таблицы (например, если в них содержатся какие-то комментарии) col_names = FALSE позволяет не интерпретировать первую строку как заголовочную (вместо этого она будет читаться как строка с данными) col_names = c(...) позволяет задать имена столбцов (удобно, если в файле они длинные) col_types = cols(...) позволяет задать типы столбцов (необходимо, если функция неправильно определяет их сама) na = '-' позволяет указать символ, который используется для указания пропущенных значений (в данном случае указан прочерк-дефис) locale = locale(...) управляет локалью (в том числе позволяет указать кодировку файла) Стандартной кодировкой для представления текста в UNIX-подобных системах (Ubuntu, macOS и т.д.) является UTF-8 (Unicode), в русскоязычных версиях Windows — CP1251 (Windows-1251). Текстовый файл CSV, созданный в разных операционных системах, будет по умолчанию сохраняться в соответствующей кодировке, если вы не указали ее явным образом. Если при загрузке таблицы в R вы видите вместо текста нечитаемые символы — кракозябры — то, скорее всего, вы читаете файл не в той кодировке, в которой он был сохранен. Если вы не знаете, что такое кодировка и Юникод, то вам сюда По умолчанию файлы читаются в той кодировке, которая соответствует операционной системе, на которой запущен R. Если файл создан в другой кодировке, придется указать ее при чтении. Например, вы пользуетесь macOS (UTF-8), а ваш коллега — Windows (CP1251), то для чтения созданного им файла вам, скорее всего, понадобится указать что-то вроде locale = locale(encoding = 'CP1251') 3.4 Просмотр Для просмотра фрейма данных в консоли RStudio вы можете использовать несколько опций. Пусть наш фрейм данных называется reforest. Тогда: print(reforest) — выводит фрейм в консоль целиком (можно написать просто tab в консоли). head(reforest, n) — отбирает первые \\(n\\) строк фрейма tail(reforest, n) — отбирает последние \\(n\\) строк фрейма По умолчанию для функций head() и tail() \\(n=6\\). Обычно этот параметр опускают, поскольку нужно просмотреть только первые несколько строк и шести вполне достаточно. Если вы напечатаете в консоли head(reforest) или tail(reforest), то для выбранных строк будет вызвана функция print(), аналогично выводу всего фрейма: # ПРОСМОТР ТАБЛИЦЫ print(reforest) ## # A tibble: 89 x 9 ## Region `2005` `2010` `2011` `2012` `2013` `2014` `2015` `2016` ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Российская Федерация 812. 812. 860 842. 872. 863 803. 840. ## 2 Центральный федераль… 52.6 62.7 60.9 60.3 70.9 71.2 72.6 77 ## 3 Белгородская область 0.4 0.1 0.3 0.3 0.4 0.4 0.2 0.2 ## 4 Брянская область 2.9 2.8 3 3.2 3.5 3.3 3.1 3 ## 5 Владимирская область 4.4 5.3 5.7 6 7.1 5.9 6 4.9 ## 6 Воронежская область 1.1 1.1 1.8 3 2.7 2.7 2.6 2.3 ## 7 Ивановская область 2.1 1.6 2.2 3.1 4 4.8 4.6 4.2 ## 8 Калужская область 2.2 2.3 2.3 2.5 2.4 3.1 3.2 3.2 ## 9 Костромская область 10 25.2 11 11.8 15.3 13.6 15.1 16.4 ## 10 Курская область 0.5 0.3 0.4 0.6 0.6 0.6 0.5 0.4 ## # … with 79 more rows head(reforest) ## # A tibble: 6 x 9 ## Region `2005` `2010` `2011` `2012` `2013` `2014` `2015` `2016` ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Российская Федерация 812. 812. 860 842. 872. 863 803. 840. ## 2 Центральный федеральн… 52.6 62.7 60.9 60.3 70.9 71.2 72.6 77 ## 3 Белгородская область 0.4 0.1 0.3 0.3 0.4 0.4 0.2 0.2 ## 4 Брянская область 2.9 2.8 3 3.2 3.5 3.3 3.1 3 ## 5 Владимирская область 4.4 5.3 5.7 6 7.1 5.9 6 4.9 ## 6 Воронежская область 1.1 1.1 1.8 3 2.7 2.7 2.6 2.3 tail(reforest) ## # A tibble: 6 x 9 ## Region `2005` `2010` `2011` `2012` `2013` `2014` `2015` `2016` ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Хабаровский край 107. 70.2 68.7 67.2 58.4 50.5 59.6 60.3 ## 2 Амурская область 33.3 29.8 32.2 33.6 35.5 37.7 28.5 27.7 ## 3 Магаданская область 2.7 2.6 2.6 2.8 3 2.5 0.4 NA ## 4 Сахалинская область 13.1 12.7 12.5 4.6 4.7 4.9 4.7 4.1 ## 5 Еврейская автономная … 2.9 NA 2.6 2.5 2.3 NA NA 2.4 ## 6 Чукотский автономный … 0.3 NA NA NA NA NA NA NA RStudio предоставляет графический интерфейс для просмотра таблиц, в котором таблицу можно сортировать и фильтровать. Чтобы его активировать, надо вызвать функцию View(): View(tab) Поскольку функции head() и tail() возвращают строки с хвоста или начала фрейма данных, их можно и подать на вход функции View(): View(head(reforest, 3)) Как правило, не следует оставлять вызовы функции View() в тексте законченной программы. Это приведет к тому, что при запуске будут открываться новые вкладки с просмотром таблиц, что может раздражать пользователя (в том числе и вас самих). Используйте View() для вывода окончательного результата в конце программы или при отладке программы. Все вызовы View() в программе можно легко закомментировать или раскомментировать, выполнив поиск с заменой 'View(' на '# View(' и наоборот. 3.5 Столбцы, строки и ячейки 3.5.1 Названия Столбцы, строки и ячейк представляют собой основные структурные элементы фрейма данных или тиббла. Перед тем как мы поднимемся на уровень выше и рассмотрим обобщенные операции преобразования таблиц, необходимо посмотреть, как извлекать структурные элементы таблиц. Столбцы и строки таблицы имеют названия, которые можно читать и записывать с помощью функций colnames() и rownames(): # Чтение названий столбцов и строк colnames(okruga) ## [1] &quot;№&quot; &quot;Регион&quot; &quot;2005&quot; &quot;2010&quot; &quot;2011&quot; &quot;2012&quot; &quot;2013&quot; rownames(okruga) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; # Замена названий столбцов и строк colnames(okruga) &lt;- c(&quot;N&quot;, &quot;Region&quot;, &quot;Year05&quot;, &quot;Year10&quot;, &quot;Year11&quot;, &quot;Year12&quot;, &quot;Year13&quot;) print(okruga) ## # A tibble: 8 x 7 ## N Region Year05 Year10 Year11 Year12 Year13 ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 Центральный 4341 3761 3613 3651 3570 ## 2 2 Северо-Западный 3192 3088 2866 2877 2796 ## 3 3 Южный федеральный 1409 1446 1436 1394 1321 ## 4 4 Северо-Кавказский 496 390 397 395 374 ## 5 5 Приволжский 3162 2883 2857 2854 2849 ## 6 6 Уральский 1681 1860 1834 1665 1624 ## 7 7 Сибирский 2575 2218 2142 2077 1941 ## 8 8 Дальневосточный 871 870 821 765 713 Названия строк редко заменяются, поскольку с точки зрения реляционной алгебры большого смысла они не имеют. 3.5.2 Обращение к столбцам К столбцу можно обращаться по номеру и названию (с помощью оператора $ или в кавычках внутри скобок). Если вы указываете в квадратных скобках номер без запятой, он трактуется именно как номер столбца, а не строки. Тип возвращаемого значения зависит от синтаксиса: обращение через $ возвращает вектор; обращение в скобках с запятой к одному столбцу возвращает вектор; обращение в скобках с запятой к нескольким столбцам возвращает фрейм данных; обращение в скобках без запятой возвращает фрейм данных. Несколько примеров: # Один столбец - результат зависит от запятой okruga$Year05 # столбец в виде вектора okruga[, &quot;Year05&quot;] # столбец в виде вектора okruga[, 2] # столбец в виде вектора okruga[&quot;Year05&quot;] # столбец в виде фрейма данных/тиббла okruga[2] # столбец в виде фрейма данных/тиббла # Несколько столбцов - всегда фрейм данных/тиббл okruga[, c(1, 4)] okruga[, c(&quot;Region&quot;, &quot;Year11&quot;)] okruga[c(&quot;Region&quot;, &quot;Year11&quot;)] okruga[c(1, 4)] 3.5.3 Обращение к строкам Обращаться к строкам можно по их номерам. В этом случае в качестве индекса можно передать номер (номера) интересующих строк, либо вектор логических значений, в котором интересующие строки помечены как TRUE, а остальные — FALSE (в этом случае длина вектора должна равняться количеству строк в таблице): okruga[5, ] # Одна строка okruga[2:4, ] # Несколько строк okruga[okruga$Year10 &gt; 2000, ] # Несколько строк через TRUE/FALSE В отличие от работы со столбцами, выбор строк всегда возвращает таблицу (фрейм или тиббл). 3.5.4 Обращение к ячейкам Чтобы выбрать конкретные ячейки в таблице, необходимо задать оба измерения: okruga[2:3, c(&quot;Year11&quot;, &quot;Year12&quot;)] ## # A tibble: 2 x 2 ## Year11 Year12 ## &lt;dbl&gt; &lt;dbl&gt; ## 1 2866 2877 ## 2 1436 1394 Обратите внимание на то, что при этом возвращаются все комбинации строк и столбцов. То есть, нельзя выбрать ячейки 2,\"Year11\" и 3,\"Year2\" — вместе с ними также будут выбраны ячейки 3,\"Year11\" и 2,\"Year2\". Впрочем, подобные задачи возникают довольно редко 3.6 Преобразования 3.6.1 Грамматика манипуляций Если проанализировать наиболее типичные манипуляции, которые осуществляются над таблицами, то их окажется совсем немного. К таким манипуляциям относятся выбор переменных, фильтрация строк, сортировка, вычисление новых столбцов, агрегирующие статистики и группировка. Все эти задачи можно решать стандартными средствами R (и мы увидим, как это делается). Однако некоторые из них достаточно громоздки в реализации (например, группировка). К счастью, экосистема R предлагает готовые средства, позволяющие справляться с подобными задачами простым и элегантным путем. Эти средства предоставляет пакет dplyr (произносится как deep liar — ‘диплáйер’), входящий в набор инструментов tidyverse. В основе конецепции dplyr лежит понятие о грамматике табличных манипуляций, которая включает в себя ограниченное число наиболее используемых операций, а также ряд вспомогательных функций. Основные функции пакета dplyr представлены в таблице ниже: Функция Назначение select() Выбор переменных по их названиям filter() Выбор строк по заданному критерию (запросу) arrange() Упорядочение по указанным переменным mutate() Вычисление новых переменных (мутирование) summarise() Агрегирование значений переменных group_by() Группировка строк (для последующего агрегирования) Как можно видеть, этих функций совсем немного. Дополнительно к ним пакет dplyr содержит еще множество вспомогательных функций, которые применяются при выполнении основных манипуляций. Рассмотрим применение этих функций на примере работы с таблицей по восстановлению лесного фонда в регионах России. Для начала переименуем столбцы с годами, чтобы их названия начинались с буквы y: old_names = colnames(reforest) colnames(reforest) = c(old_names[1], paste(&#39;y&#39;, old_names[2:9], sep = &#39;&#39;)) Начнем с выбора нужных переменных, используя select(). Оставим только название региона и данные за 2010 и 2015 гг: library(dplyr) (rdf = select(reforest, Region, y2010, y2015)) ## # A tibble: 89 x 3 ## Region y2010 y2015 ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Российская Федерация 812. 803. ## 2 Центральный федеральный округ 62.7 72.6 ## 3 Белгородская область 0.1 0.2 ## 4 Брянская область 2.8 3.1 ## 5 Владимирская область 5.3 6 ## 6 Воронежская область 1.1 2.6 ## 7 Ивановская область 1.6 4.6 ## 8 Калужская область 2.3 3.2 ## 9 Костромская область 25.2 15.1 ## 10 Курская область 0.3 0.5 ## # … with 79 more rows Ту же самую задачу можно решить от противного — указать со знаком - те столбцы, которые надо убрать: (rdf = select(reforest, -y2005, -y2011:-y2014, -y2016)) ## # A tibble: 89 x 3 ## Region y2010 y2015 ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Российская Федерация 812. 803. ## 2 Центральный федеральный округ 62.7 72.6 ## 3 Белгородская область 0.1 0.2 ## 4 Брянская область 2.8 3.1 ## 5 Владимирская область 5.3 6 ## 6 Воронежская область 1.1 2.6 ## 7 Ивановская область 1.6 4.6 ## 8 Калужская область 2.3 3.2 ## 9 Костромская область 25.2 15.1 ## 10 Курская область 0.3 0.5 ## # … with 79 more rows Обратите внимание на то, что можно указывать еще и диапазоны названий столбцов, если они идут друг за другом. Названия столбцов в функциях dplyr указываются без кавычек, что позволяет сделат код проще и читаемее. Этот прием называется квотацией, с ним мы познакомимся подробнее в следующей лекции. Чтобы осуществить фильтрацию, необходимо задать условие, накладываемое на строки. Текущая таблица содержит данные по субъектам, федеральным округам и России в целом. Поскольку данные по округам и стране являются избыточными (их можно получить путем агрегирования данных по субъектам), выполним фильтрацию таблицы, убрав строки, в которых содержатся слова Федерация и федеральный округ. Для этого используем функцию str_detect() из пакета stringr, который также входит в tidyverse: flt = !stringr::str_detect(rdf$Region, &#39;Федерация|федеральный округ&#39;) # готовим фильтр для строк (regdf = filter(rdf, flt)) # применяем фильтр ## # A tibble: 80 x 3 ## Region y2010 y2015 ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Белгородская область 0.1 0.2 ## 2 Брянская область 2.8 3.1 ## 3 Владимирская область 5.3 6 ## 4 Воронежская область 1.1 2.6 ## 5 Ивановская область 1.6 4.6 ## 6 Калужская область 2.3 3.2 ## 7 Костромская область 25.2 15.1 ## 8 Курская область 0.3 0.5 ## 9 Липецкая область 0.4 1.1 ## 10 Московская область 2.7 8.9 ## # … with 70 more rows Условие можно прописать непосредственно при вызове filter(). Например, выберем регионы, в которых объем лесовосстановительных работ в 2015 году был более 50 тыс. га: filter(regdf, y2015 &gt; 50) ## # A tibble: 4 x 3 ## Region y2010 y2015 ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Архангельская область 39.4 57.6 ## 2 Красноярский край 49 50.4 ## 3 Иркутская область 80.4 117. ## 4 Хабаровский край 70.2 59.6 Для сортировки таблицы посредством arrange() необходимо указать столбцы, по которым будет осуществлено упорядочение строк. Чаще всего это один столбец, например y2015: arrange(regdf, y2015) # по возрастанию ## # A tibble: 80 x 3 ## Region y2010 y2015 ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Орловская область 0 0.1 ## 2 Астраханская область 0.1 0.1 ## 3 Кабардино-Балкарская Республика 0.1 0.1 ## 4 Карачаево-Черкесская Республика 0.2 0.1 ## 5 Республика Северная Осетия – Алания NA 0.1 ## 6 Ставропольский край 0.4 0.1 ## 7 Белгородская область 0.1 0.2 ## 8 Тульская область 0.1 0.2 ## 9 Магаданская область 2.6 0.4 ## 10 Курская область 0.3 0.5 ## # … with 70 more rows arrange(regdf, desc(y2015)) # по убыванию ## # A tibble: 80 x 3 ## Region y2010 y2015 ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Иркутская область 80.4 117. ## 2 Хабаровский край 70.2 59.6 ## 3 Архангельская область 39.4 57.6 ## 4 Красноярский край 49 50.4 ## 5 Вологодская область 32.3 49 ## 6 Республика Коми 33.3 36.7 ## 7 Пермский край 22.9 32.5 ## 8 Кировская область 26 31.1 ## 9 Амурская область 29.8 28.5 ## 10 Томская область 9.3 25.6 ## # … with 70 more rows Добавление новых переменных (столбцов) осуществляется посредством mutate(). Например, определим, как изменился объем лесовосстановительных работ в 2015 году по сравнению с 2010 годом: (regdf = mutate(regdf, delta = y2015 - y2010)) ## # A tibble: 80 x 4 ## Region y2010 y2015 delta ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Белгородская область 0.1 0.2 0.1 ## 2 Брянская область 2.8 3.1 0.3 ## 3 Владимирская область 5.3 6 0.7 ## 4 Воронежская область 1.1 2.6 1.5 ## 5 Ивановская область 1.6 4.6 3.00 ## 6 Калужская область 2.3 3.2 0.9 ## 7 Костромская область 25.2 15.1 -10.1 ## 8 Курская область 0.3 0.5 0.2 ## 9 Липецкая область 0.4 1.1 0.7 ## 10 Московская область 2.7 8.9 6.2 ## # … with 70 more rows Существует редко используемая разновидность мутирования, при которой сохраняются только столбцы, указанные в параметрах. Она называется transmute() — по сути это комбинация mutate() и select(). Если вы хотите просто сохранить какой-то из столбцов, то укажите его через оператор равенства: transmute(regdf, Region = Region, delta = y2015 - y2010) # сохраняем только Region и delta ## # A tibble: 80 x 2 ## Region delta ## &lt;chr&gt; &lt;dbl&gt; ## 1 Белгородская область 0.1 ## 2 Брянская область 0.3 ## 3 Владимирская область 0.7 ## 4 Воронежская область 1.5 ## 5 Ивановская область 3.00 ## 6 Калужская область 0.9 ## 7 Костромская область -10.1 ## 8 Курская область 0.2 ## 9 Липецкая область 0.7 ## 10 Московская область 6.2 ## # … with 70 more rows Вы можете выполнять агрегирование данных и вычислять суммы, средние значения и т.д. используя summarise(). После того как мы избавились от избыточных данных в таблице, мы всегда можем получить их через агрегирование. Например, посчитаем суммарный, минимальный и максимальный объем лесовосстановительных работ по всей стране: summarise(regdf, sumforest = sum(y2015, na.rm = TRUE), minforest = min(y2015, na.rm = TRUE), maxforest = max(y2015, na.rm = TRUE)) ## # A tibble: 1 x 3 ## sumforest minforest maxforest ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 801. 0.1 117. Как правило, summarise() используется в паре с агрегирующими функциями, которые берут вектор значений и возвращают одно значение. К таким функциям относятся стандартные операции типа min(), max(), mean(), sum() и т.д. В пакете dplyr также имеются полезные агрегирующие функции: n() вычисляет количество элементов. n_distinct() вычисляет количество уникальных элементов. first(x), last(x) и nth(x, n) извлекают, соответственно, первый, последний и n-ный элемент (они бывают особенно удобны, если вы сортируете строки по какому-то критерию). Достаточно часто данные надо агрегировать не по всей таблице, а по группам измерений. В этом случае сначала делается группировка, затем агрегирование данных в каждой группе. Предположим, что нам нужно найти регион с наибольшим объемом лесовосставновительных работ в каждом Федеральном округе. Для этого нам потребуется: Дополнить каждую строку региона информацией о принадлежности к федеральному округу Сгруппировать субъекты по федеральным округам — Отсортировать каждую группу по убыванию значения поля Взять первую строку в каждой группе Объединить строки в одну таблицу Для начала вернемся на этап, когда мы избавлялись от федеральных округов в таблице. Поскольку в исходной таблице данные были упорядочены по округам, эту информацию можно использовать для создания нового столбца с названием округа каждого субъекта. В этом нам поможет функция fill() из пакета tidyr: flt2 = stringr::str_detect(rdf$Region, &#39;федеральный округ&#39;) # ищем округа (rdf2 = mutate(rdf, okrug = if_else(flt2, Region, NULL))) # перенесем названия округов в новый столбец ## # A tibble: 89 x 4 ## Region y2010 y2015 okrug ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Российская Федерация 812. 803. &lt;NA&gt; ## 2 Центральный федеральный округ 62.7 72.6 Центральный федеральный округ ## 3 Белгородская область 0.1 0.2 &lt;NA&gt; ## 4 Брянская область 2.8 3.1 &lt;NA&gt; ## 5 Владимирская область 5.3 6 &lt;NA&gt; ## 6 Воронежская область 1.1 2.6 &lt;NA&gt; ## 7 Ивановская область 1.6 4.6 &lt;NA&gt; ## 8 Калужская область 2.3 3.2 &lt;NA&gt; ## 9 Костромская область 25.2 15.1 &lt;NA&gt; ## 10 Курская область 0.3 0.5 &lt;NA&gt; ## # … with 79 more rows (rdf2 = tidyr::fill(rdf2, okrug)) # заполним все пустые строчки предыдущим значением ## # A tibble: 89 x 4 ## Region y2010 y2015 okrug ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Российская Федерация 812. 803. &lt;NA&gt; ## 2 Центральный федеральный округ 62.7 72.6 Центральный федеральный округ ## 3 Белгородская область 0.1 0.2 Центральный федеральный округ ## 4 Брянская область 2.8 3.1 Центральный федеральный округ ## 5 Владимирская область 5.3 6 Центральный федеральный округ ## 6 Воронежская область 1.1 2.6 Центральный федеральный округ ## 7 Ивановская область 1.6 4.6 Центральный федеральный округ ## 8 Калужская область 2.3 3.2 Центральный федеральный округ ## 9 Костромская область 25.2 15.1 Центральный федеральный округ ## 10 Курская область 0.3 0.5 Центральный федеральный округ ## # … with 79 more rows (regdf = filter(rdf2, flt)) # оставим только регионы ## # A tibble: 80 x 4 ## Region y2010 y2015 okrug ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Белгородская область 0.1 0.2 Центральный федеральный округ ## 2 Брянская область 2.8 3.1 Центральный федеральный округ ## 3 Владимирская область 5.3 6 Центральный федеральный округ ## 4 Воронежская область 1.1 2.6 Центральный федеральный округ ## 5 Ивановская область 1.6 4.6 Центральный федеральный округ ## 6 Калужская область 2.3 3.2 Центральный федеральный округ ## 7 Костромская область 25.2 15.1 Центральный федеральный округ ## 8 Курская область 0.3 0.5 Центральный федеральный округ ## 9 Липецкая область 0.4 1.1 Центральный федеральный округ ## 10 Московская область 2.7 8.9 Центральный федеральный округ ## # … with 70 more rows Теперь мы можем определить регион с максимальным объемом лесовосстановительных работ в каждом Федеральном округе, используя вспомогательную функцию row_number() которая возвращает номер для каждой строки таблицы: regdf_gr = group_by(regdf, okrug) regdf_arr = arrange(regdf_gr, desc(y2015)) (regdf_res = filter(regdf_arr, row_number() == 1)) ## # A tibble: 8 x 4 ## # Groups: okrug [8] ## Region y2010 y2015 okrug ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Иркутская область 80.4 117. Сибирский федеральный округ ## 2 Хабаровский край 70.2 59.6 Дальневосточный федеральный округ ## 3 Архангельская область 39.4 57.6 Северо-Западный федеральный округ ## 4 Пермский край 22.9 32.5 Приволжский федеральный округ ## 5 Свердловская область 25.6 24.4 Уральский федеральный округ ## 6 Костромская область 25.2 15.1 Центральный федеральный округ ## 7 Волгоградская область 1.8 0.9 Южный федеральный округ ## 8 Чеченская Республика 0.9 0.7 Северо-Кавказский федеральный округ group_by() часто используется в паре с summarise(). Например мы можем получить суммарный объем лесовосстановительных работ по каждому федеральному округу: regdf_gr = group_by(regdf, okrug) summarise(regdf_gr, total = sum(y2015, na.rm = TRUE)) ## # A tibble: 8 x 2 ## okrug total ## &lt;chr&gt; &lt;dbl&gt; ## 1 Дальневосточный федеральный округ 108. ## 2 Приволжский федеральный округ 110. ## 3 Северо-Западный федеральный округ 194. ## 4 Северо-Кавказский федеральный округ 1.1 ## 5 Сибирский федеральный округ 259. ## 6 Уральский федеральный округ 52.9 ## 7 Центральный федеральный округ 72.7 ## 8 Южный федеральный округ 3.3 Использование dplyr целым обладает рядом преимуществ по сравнению с применением стандартных средств R: вызов функций с говорящими названиями операции более понятными; код выглядит более чистым и легко читаемым за счет отсутствия обращений к фреймам данных через квадратные скобки, доллары и «закавыченные» названия переменных; код с использованием функций dplyr часто оказывается короче, чем его традиционные аналоги; операции dplyr можно выстраивать в конвейеры с помощью пайп-оператора %&gt;%. Последнюю возможность мы рассмотрим в следующем параграфе. 3.6.2 Конвейер манипуляций В предыдущем параграфе было показано как найти регион-лидер в каждой группе по выбранному показателю. При этом, несмотря на то что интерес представляет только конечный результат, нам пришлось шесть раз осуществить запись промежуточного результата в соответствующую переменную. Чтобы избежать подобного многословия в программах, в R реализована возможность организации конвейера манипуляций (pipeline) посредством использования пайп-оператора %&gt;%. Пайп-оператор %&gt;% предназначен для компактной и наглядной записи последовательностей обработки данных. Работает он следующим образом: x %&gt;% f эквивалентно f(x) x %&gt;% f(y) эквивалентно f(x, y) x %&gt;% f %&gt;% g %&gt;% h эквивалентно h(g(f(x))) Коротко говоря, пайп оператор берет результат вычисления выражения слева и подставляет его в качестве первого аргумента в выражение справа. С помощью этого оператора вышеприведенный код по нахождению региона-лидера можно записать так: regdf = rdf %&gt;% mutate(okrug = if_else(flt2, Region, NULL)) %&gt;% tidyr::fill(okrug) %&gt;% filter(flt) leaders = regdf %&gt;% group_by(okrug) %&gt;% arrange(desc(y2015)) %&gt;% filter(row_number() == 1) print(leaders) ## # A tibble: 8 x 4 ## # Groups: okrug [8] ## Region y2010 y2015 okrug ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Иркутская область 80.4 117. Сибирский федеральный округ ## 2 Хабаровский край 70.2 59.6 Дальневосточный федеральный округ ## 3 Архангельская область 39.4 57.6 Северо-Западный федеральный округ ## 4 Пермский край 22.9 32.5 Приволжский федеральный округ ## 5 Свердловская область 25.6 24.4 Уральский федеральный округ ## 6 Костромская область 25.2 15.1 Центральный федеральный округ ## 7 Волгоградская область 1.8 0.9 Южный федеральный округ ## 8 Чеченская Республика 0.9 0.7 Северо-Кавказский федеральный округ Если бы мы попытались написать те же последовательности операций одним выражением в традиционной «матрешечной» парадигме, это выглядело так: regdf = filter( tidyr::fill( mutate( rdf, okrug = if_else(flt2, Region, NULL) ), okrug ), flt ) result = filter( arrange( group_by( regdf, okrug ), desc(y2015) ), row_number() == 1 ) Выглядит несколько устрашающе. К тому же, читать такой код приходится задом наперед (изнутри наружу), чтобы понять последовательность действий. Таким образом, организация конвейера манипуляций с использованием пайп-оператора позволяет: упорядочить операции по обработке данных слева направо (в противоположность направлению изнутри наружу); избежать вложенных вызовов функций (матрёшки); минимизировать количество переменных для храненния промежуточных результатов; упростить добавление новых операций по обработке данных в любое место последовательности. Пайп-оператор %&gt;% можно быстро набрать в RStudio, нажав клавиатурное сочетание Ctrl + Shift + M (Cmd + Shift + M на помпьютерах Mac) 3.6.3 Преобразование структуры Одни и те же данные можно предствить в табличной форме по-разному. Одна форма будет удобной для ручного заполнения таблицы. Другая форма будет удобной для программной обработки и анализа. Большинство же остальных форм не будут оптимальными ни для того, ни для другого. Наш курс посвящен автоматизированной обработке данных на языке R, поэтомы мы должны определить, какая форма таблицы удобна для этих целей. В экосистеме R такие данные принято называть «аккуратными», или по-английски tidy data. Аккуратные таблицы отвечают следующим требованиям: Каждый столбец представляет переменную Каждая строка представляет измерение Каждая ячейка представляет значение С некоторой долей условности можно говорить, что это третья нормальная форма реляционного отношения. Таблицы, с которыми мы работали до настоящего момента в этой главе, не отвечают данным требованиям. В частности, данные по лесовосстановлению содержат столбцы, в которых приведены данные за соответствующие года. Это одна переменная, разбитая на несколько столбцов. При этом год измерения является второй переменной. Такая форма удобна для заполнения и визуального анализа, но неудобна для программной обработки. Предположим, что нам надо найти все регионы, у которых в промежутке между 2012 и 2015 годами лесовосстановительные работы хотя бы в один год не производились (их объем был равен нулю). В текущей форме таблицы нам придется сделать 4 условия — по одному на каждый год-столбец. Это при том, что мы должны быть уверены, что все промежуточные года в таблице присутствуют. Приведя таблицу к аккуратному виду, мы можем решить задачу более компактно, отправив всего 2 запроса: один на год измерения и второй на величину показателя. Приведение таблицы к аккуратному виду можно сделать, используя функции из пакета tidyr. Основных функций в этом пакете всего две2: pivot_longer() берет несколько колонок и преобразует их к виду «ключ—значение»: широкие таблицы становятся длинными. pivot_wider() берет две колонки, соответствующие ключу и значению, и распределяет их на множество колонок: длинные таблицы становятся широкими. Помимо этого, есть еще 2 полезных функции, которые позволяют «распиливать» или «склеивать» колонки: separate() разделяет колонку на несколько колонок, используя заданный символ-разделитель или позицию. unite() скливает несколько колонок, используя заданный символ-разделитель. Функция pivot_longer() имеет четыре основных параметра: data — входная таблица (фрейм данных или тиббл) cols — перечисление столбцов, которые необходимо подвергнуть преобразованию names_to — имя нового столбца, который будет хранить ключи (бывшие названия столбцов) values_to — имя нового столбца, который будет хранить значения Рассмотрим на примере таблицы reforest приведение к аккуратному виду: library(tidyr) (reforest_tidy = reforest %&gt;% pivot_longer(cols = y2005:y2016, names_to = &#39;year&#39;, values_to = &#39;value&#39;)) ## # A tibble: 712 x 3 ## Region year value ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Российская Федерация y2005 812. ## 2 Российская Федерация y2010 812. ## 3 Российская Федерация y2011 860 ## 4 Российская Федерация y2012 842. ## 5 Российская Федерация y2013 872. ## 6 Российская Федерация y2014 863 ## 7 Российская Федерация y2015 803. ## 8 Российская Федерация y2016 840. ## 9 Центральный федеральный округ y2005 52.6 ## 10 Центральный федеральный округ y2010 62.7 ## # … with 702 more rows Обратите внимание на то, что параметры names_to и values_to надо передавать как строки, поскольку они содержат еще не существующие объекты. Полученный результат еще не вполне пригоден для анализа, поскольку в переменной year мы имеем строковые значения, начинающиеся с y. Чтобы избавиться от этого префикса, можно при вызове pivot_longer() указать параметр names_prefix. Поскольку по умолчанию ключи конвертируются в строковый столбец, а год — это целочисленное значение, следует дополнительно указать параметр names_ptypes. Помимо этого, конвертации подвергаются все столбцы, кроме Region — это означает, что можно пойти от обратного в параметре cols. Резюмируя перечисленные соображения, вышеприведенный вызов можно оптимизировать следующим образом: (reforest_tidy2 = reforest %&gt;% pivot_longer(cols = -Region, names_to = &#39;year&#39;, names_prefix = &#39;y&#39;, names_ptypes = list(year = integer()), values_to = &#39;value&#39;)) ## # A tibble: 712 x 3 ## Region year value ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Российская Федерация 2005 812. ## 2 Российская Федерация 2010 812. ## 3 Российская Федерация 2011 860 ## 4 Российская Федерация 2012 842. ## 5 Российская Федерация 2013 872. ## 6 Российская Федерация 2014 863 ## 7 Российская Федерация 2015 803. ## 8 Российская Федерация 2016 840. ## 9 Центральный федеральный округ 2005 52.6 ## 10 Центральный федеральный округ 2010 62.7 ## # … with 702 more rows Если по какой-то причине вам уже досталась таблица, в которой в ячейках сцеплены несколько сущностей, разделить их можно с помощью функции separate(). Вышеприведенный тиббл reforest_tidy можно “довести до ума” последовательным вызовом separate(), select() и mutate(): (reforest_tidy = reforest_tidy %&gt;% separate(year, c(&#39;y&#39;, &#39;year&#39;), 1) %&gt;% select(-y) %&gt;% mutate(year = as.integer(year))) ## # A tibble: 712 x 3 ## Region year value ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Российская Федерация 2005 812. ## 2 Российская Федерация 2010 812. ## 3 Российская Федерация 2011 860 ## 4 Российская Федерация 2012 842. ## 5 Российская Федерация 2013 872. ## 6 Российская Федерация 2014 863 ## 7 Российская Федерация 2015 803. ## 8 Российская Федерация 2016 840. ## 9 Центральный федеральный округ 2005 52.6 ## 10 Центральный федеральный округ 2010 62.7 ## # … with 702 more rows Теперь можно выполнять любые запросы, комбинирующие год измерения и величину показателя. Найдем субъекты, в которых с 2012 по 2015 год не производились лесовосстановительные работы: reforest_tidy %&gt;% filter(year &gt; 2011 &amp; year &lt; 2016 &amp; value == 0) ## # A tibble: 2 x 3 ## Region year value ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Орловская область 2013 0 ## 2 Республика Адыгея 2014 0 “Длинная” форма данных удобна для программного анализа, но может быть неудобна для ручного редактирования, визуальной оценки или передачи в другие программы, ожидающие на входе данные в “широком” формате. В этих случаях будет полезна функция pivot_wider(), которая по своему действию противоположна pivot_longer(). Данная функция имеет три основных параметра: data — входная таблица (фрейм данных или тиббл) names_from — имя переменной, из которой будут браться названия столбцов values_from — имя переменной, из которой будут браться значения в ячейках Преобразуем ранее удлиненную таблицу к “широкому” виду: (reforest = reforest_tidy %&gt;% pivot_wider(names_from = year, values_from = value)) ## # A tibble: 89 x 9 ## Region `2005` `2010` `2011` `2012` `2013` `2014` `2015` `2016` ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Российская Федерация 812. 812. 860 842. 872. 863 803. 840. ## 2 Центральный федераль… 52.6 62.7 60.9 60.3 70.9 71.2 72.6 77 ## 3 Белгородская область 0.4 0.1 0.3 0.3 0.4 0.4 0.2 0.2 ## 4 Брянская область 2.9 2.8 3 3.2 3.5 3.3 3.1 3 ## 5 Владимирская область 4.4 5.3 5.7 6 7.1 5.9 6 4.9 ## 6 Воронежская область 1.1 1.1 1.8 3 2.7 2.7 2.6 2.3 ## 7 Ивановская область 2.1 1.6 2.2 3.1 4 4.8 4.6 4.2 ## 8 Калужская область 2.2 2.3 2.3 2.5 2.4 3.1 3.2 3.2 ## 9 Костромская область 10 25.2 11 11.8 15.3 13.6 15.1 16.4 ## 10 Курская область 0.5 0.3 0.4 0.6 0.6 0.6 0.5 0.4 ## # … with 79 more rows Обратите внимание на то, что параметры names_from и values_from можно задавать как имена переменных, а не как строки. В качестве примера операции с широкой таблицей вычислим разности по сравнению с предыдущим годом: diffs = reforest %&gt;% select(`2011`:`2016`) - reforest %&gt;% select(`2010`:`2015`) diffs %&gt;% mutate(Region = reforest$Region) %&gt;% select(Region, `2011`:`2016`) %&gt;% head() # Посмотрим шапку таблицы ## Region 2011 2012 2013 2014 2015 2016 ## 1 Российская Федерация 48.5 -18.3 30.6 -9.3 -60.1 37.0 ## 2 Центральный федеральный округ -1.8 -0.6 10.6 0.3 1.4 4.4 ## 3 Белгородская область 0.2 0.0 0.1 0.0 -0.2 0.0 ## 4 Брянская область 0.2 0.2 0.3 -0.2 -0.2 -0.1 ## 5 Владимирская область 0.4 0.3 1.1 -1.2 0.1 -1.1 ## 6 Воронежская область 0.7 1.2 -0.3 0.0 -0.1 -0.3 3.7 Соединение Данные, с которыми мы работаем, часто распределены по нескольким таблицам. Если возникает задача их совместного использования (сравнения, вычисления производных показателей), таблицы необходимо соединить. В процессе соединения в обеих таблицах находятся строки, соответствующие одному и тому же измерению (например, региону). После этого столбцы второй таблицы пристыковываются к столбцам первой таблицы, а строки — к соответствующим строкам (мутирующее соединение), либо же происходит фильтрация строк первой таблицы на основе нахождения соответствующих строк во второй таблице (фильтрующее соединение). Чтобы найти соответствие, в обеих таблицах должен быть по крайней мере один столбец, идентифицирующий каждую строку. В первой таблице он называется первичным ключом (primary key), во второй таблице — внешним ключом (foreign key). Для выполнения соедининия в пакете dplyr имеется несколько функций. Мутирующее соединение: inner_join(x, y, by = ) возвращает все строки из x, для которых имеются соответствующие строки в y, а также все столбцы из x и y. left_join(x, y, by = ) возвращает все строки из x, а также все столбцы из x и y. Строки в x, для которых не найдены соответствия в y, будут иметь значения NA в присоединенных столбцах right_join(x, y, by = ) возвращает все строки из y, а также все столбцы из x и y. Строки в y, для которых не найдены соответствия в x, будут иметь значения NA в присоединенных столбцах full_join(x, y, by = ) возвращает все строки и колонки из x и y. В строках, для которых не найдено соответствие ячейки присоединяемых стольков будут заполнены значениями NA Фильтрующее соединение: semi_join(x, y, by = ) возвращает все строки из x, для которых имеются соответствующие строки в y, а также все столбцы из x anti_join(x, y, by = ) возвращает все строки из x, для которыхне найдены соответствующие строки в y, а также все столбцы из x Рассмотрим соединение таблиц на примере данных по лесовосстановлению и заготовкам древесины. Наша задача — оценить количество гектаров восстанавливаемой лесной площади (в га) на тысячу кубометров лесозаготовок (и таким образом оценить эффективность лесовосстановительных мероприятий). Подгрузим таблицу по лесозаготовкам: (timber = read_excel(&#39;data/timber.xlsx&#39;, col_types = c(&#39;text&#39;, rep(&#39;numeric&#39;, 8))) %&gt;% filter(!stringr::str_detect(Регион, &#39;Федерация|федеральный округ&#39;))) ## # A tibble: 75 x 9 ## Регион `2010` `2011` `2012` `2013` `2014` `2015` `2016` Место ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Белгородская область 30.4 39.6 27.7 37.4 34.1 45.6 30.4 60 ## 2 Брянская область 614. 616. 824. 850. 793. 739. 750. 27 ## 3 Владимирская область 1078 1335 1236 1142 1165 1272 1252 20 ## 4 Воронежская область 73.6 69.5 68.6 47.9 81.1 86.6 53.5 58 ## 5 Ивановская область 130. 140. 200. 199. 231. 326. 421. 38 ## 6 Калужская область 274. 244. 192. 198. 183 145. 204 44 ## 7 Костромская область 3000 3332 2797 2692 2564 2186 2515 14 ## 8 Курская область 22.8 55.4 49.7 50.1 65.9 74.6 80.7 55 ## 9 Липецкая область 163. 139 49.7 42.6 50.1 73.1 87.8 53 ## 10 Московская область 126. 265. 299. 108. 15.6 NA NA 74 ## # … with 65 more rows Приведем ее к аккуратному виду, который соответствует виду таблицы по лесовосстановлению: (timber_tidy = timber %&gt;% gather(year, harvest, `2010`:`2016`) %&gt;% transmute(Region = Регион, year = as.numeric(year), harvest = harvest)) ## # A tibble: 525 x 3 ## Region year harvest ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Белгородская область 2010 30.4 ## 2 Брянская область 2010 614. ## 3 Владимирская область 2010 1078 ## 4 Воронежская область 2010 73.6 ## 5 Ивановская область 2010 130. ## 6 Калужская область 2010 274. ## 7 Костромская область 2010 3000 ## 8 Курская область 2010 22.8 ## 9 Липецкая область 2010 163. ## 10 Московская область 2010 126. ## # … with 515 more rows Теперь нам осталось присоединить данные по лесозаготовкам к таблице по лесовосстановлению, используя имя региона (Region) и год (year) в качестве ключевых полей. Для этого мы используем функцию inner_join(), поскольку нас интересует сравнение по тем годам, для которых имеются данные в обеих таблицах: (compare = reforest_tidy %&gt;% inner_join(timber_tidy, by = c(&quot;Region&quot; = &quot;Region&quot;, &quot;year&quot; = &quot;year&quot;))) ## # A tibble: 511 x 4 ## Region year value harvest ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Белгородская область 2010 0.1 30.4 ## 2 Белгородская область 2011 0.3 39.6 ## 3 Белгородская область 2012 0.3 27.7 ## 4 Белгородская область 2013 0.4 37.4 ## 5 Белгородская область 2014 0.4 34.1 ## 6 Белгородская область 2015 0.2 45.6 ## 7 Белгородская область 2016 0.2 30.4 ## 8 Брянская область 2010 2.8 614. ## 9 Брянская область 2011 3 616. ## 10 Брянская область 2012 3.2 824. ## # … with 501 more rows Наконец, вычислим искомое отношние и упорядочим регионы по году (возрастание) и отношению (убывание): (compare = compare %&gt;% mutate(ratio = 1000 * value / harvest) %&gt;% select(Region, year, ratio, value, harvest) %&gt;% arrange(year, desc(ratio))) ## # A tibble: 511 x 5 ## Region year ratio value harvest ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Ставропольский край 2010 182. 0.4 2.2 ## 2 Ростовская область 2010 149. 1.5 10.1 ## 3 Магаданская область 2010 118. 2.6 22 ## 4 Сахалинская область 2010 63.8 12.7 199. ## 5 Республика Саха (Якутия) 2010 63.3 58 917. ## 6 Республика Тыва 2010 61.8 4.4 71.2 ## 7 Мурманская область 2010 52.2 3 57.5 ## 8 Волгоградская область 2010 48.4 1.8 37.2 ## 9 Камчатский край 2010 38.9 5.2 134. ## 10 Амурская область 2010 38.5 29.8 773. ## # … with 501 more rows Из этой таблицы видно, что площадь восстанавливаемых лесов далеко не всегда пропорциональна объему заготовок необработанной древесины. 3.8 Запись Запись файлов в текстовом формате можно осуществить посредством функций из пакета readr, таких как write_delim(), write_csv() и write_tsv(). Базовый синтаксис их предельно прост: write_csv(compare, &quot;data/output/timber_compare.csv&quot;) Для записи таблиц Microsoft Excel можно использовать возможности пакета writexl: library(writexl) write_xlsx(compare, &quot;data/output/timber_compare.xlsx&quot;) Каждая из этих функций содержит ряд дополнительных параметров, позволяющих управлять внешним видом выгружаемых таблиц. Более подробно с ними вы можете ознакомиться, вызвав справку для соответствующей функции. 3.9 Рекомендации по подготовке таблиц для чтения в R Несмотря на то, что каких-то четких правил подготовки таблиц для программной обработки не существует, можно дать несколько полезных рекомендаций по данному поводу: В первой строке таблицы должны располагаться названия столбцов. Во второй строке таблицы должны начинаться данные. Не допускайте многострочных заголовков. В названиях столбцов недопустимы объединенные ячейки, покрывающие несколько столбцов. Это может привести к неверному подсчету количества столбцов и, как следствие, некорректному чтению таблицы в целом. Названия столбцов должны состоять из латинских букв и цифр, начинаться с буквы и не содержать пробелов. Сложносочиненные названия выделяйте прописными буквами. Плохое название столбца: Валовый внутренний продукт за 2015 г.. Хорошее название столбца: GDP2015. Некоторые ошибки данных в таблицах (такие как неверные десятичные разделители), проще найти и исправить в табличном/текстовом редакторе, нежели после загрузки в R. Следование этим правилам значительно облегчит работу с табличными данными в среде R. 3.10 Краткий обзор Для просмотра презентации щелкните на ней один раз левой кнопкой мыши и листайте, используя кнопки на клавиатуре: Презентацию можно открыть в отдельном окне или вкладке браузере. Для этого щелкните по ней правой кнопкой мыши и выберите соответствующую команду. 3.11 Контрольные вопросы и упражнения 3.11.1 Вопросы Какая функция позволяет установить новый пакет в R? Как подключить пакет в текущую сессию R? Как вызвать функцию из пакета, не подключая его в текущей сессии R? Какие структуры данных используются для представления таблиц в среде R? Чем они отличаются друг от друга? Какая функция позволяет создавать тибблы по строкам, а не столбцам? Как загрузить в текущую сессию R набор данных из конкретного пакета? Под каким именем он будет доступен? Каковы основные принципы создания текстовых файлов с разделителем для хранения таблиц? Какой аббревиатурой они обозначаются? Чем отличаются файлы с фиксированной шириной столбца от файлов с разделителем? Какими спопообами можно указать границы колонок при чтении этих файлов? Перечислите функции из пакета readr, которые можно использовать для чтения текстовых файлов с табличными данными? Какой пакет позволяет читать данные в формате Microsoft Excel? Если прочитанный вами файл содержит нечитаемые символы, что это означает? Как решить проблему? Какие дополнительные параметры позволяют задавать функции чтения данных из пакетов readr и readxl, помимо имени файла? Перечислите основные возможности для отображения табличных данных в среде R? Можно ли заменять названия строк и столбцов таблицы? Если да, то какие функции для этого используются? Назовите возможные способы извлечения столбца (столбцов) из фрейма данных/тиббла. Какие из них приводят к получения вектора, а какие возвращают фрейм данных/тиббл? Как извлечь строки, удовлетворяющие некоторому критерию, используя стандартные средства R? Перечислите основные типы манипуляций над таблицами. Какой тип манипуляции всегда используется в сочетании с другими типами? Нужно ли заключать названия переменных в кавычки при использовании функций пакета dplyr? Какая функция dplyr позволяет выбирать нужные переменные? Как с помощью нее отобрать диапазон переменных? Можно ли пойти от обратного и исключить, а не выбрать переменные? Какая функция dplyr позволяет осуществлять фильтрацию строк? Как реализовать фильтрацию строк по нескольким условиям одновременно? Как найти строки, в которых встречаются заданные фрагменты текста? Какая функция позволяет это сделать? Назовите функцию dplyr, отвечающую за выполнение сортировки таблицы. Как с помощью нее упорядочить данные по нескольким столбцам? Сделать порядок сортировки по убыванию? Что такое мутирование и трансмутирование таблицы? Какая функция dplyr отвечает за добавление новых переменных? Можно ли с помощью нее добавить несколько переменных сразу? Как оставить только вновь создаваемые переменные? С помощью какой функции можно вычислить обобщающие статистики по всем строкам или группам строк? Как с помощью dplyr получить количество элементов и количество уникальных элементов в каждой группе? Как с помощью dplyr получить первый, последний и n-ный элемент в каждой группе? Что такое конвейер манипуляций и для чего он используется в R? Опишите приципы действия пайп-оператора. С помощью какого клавиатурного сочетания его можно быстро ввести в RStudio? Опишите требования, которым должны отвечать аккуратные табличные данные. Какой пакет R позволяет преборазовывать данные в такую форму? Какие две основных операции над таблицами позволяют добиться длинного и широкого вида таблицы? Можно ли говорить о том, что для всех задач удобна какая-то одна из этих двух форм? Как работают функции pivot_longer() и pivot_wider()? Что такое соединение таблиц? В каких случаях оно бывает необходимо? Какие разновидности соединения реализованы в dplyr? Каким требованиям должны отвечать таблицы для того чтобы их соединение было возможным? Что такое первичный и внешний ключ в операции соединения таблиц? Какие возможности существуют для записи табличных данных в текстовые файлы? Перечислите пакеты и функции, такие возможности реализующие. Опишите общие рекомендации для подготовки таблиц к чтению средствами R. 3.11.2 Упражнения Таблица quakes из пакета datasets содержит магнитуду землетрясений в поле mag. Используя функции dplyr и пайп-оператор, создайте на ее основе таблицу с частотой (количеством штук) землетрясений каждой магнитуды. Подсказка: при выполнении агрегирования используйте функцию n(), которая возвращает количество строк в группе. Таблица storms из пакета dplyr содержит увлекательные данные трекинга тропических циклонов c 1975 по 2015 год. Используя функции dplyr и пайп-оператор, создайте таблицу в которой зафиксировано: название циклона, дата начала, дата окончания, продолжительность в днях, максимальная скорость ветра, минимальное давление. Отсортируйте циклоны сначала по максимальной скорости ветра (по убыванию), затем по давлению (по возрастанию). Оформите результат в виде одного конвейера манипуляций. Подсказка: перед выполнением агрегирования на основе существующих полей создайте новое поле, в котором хранится дата события, имеющая тип Date. Это позволит вам правильно вычислить продолжительность в днях. Чтобы создать строку для преобразования в дату, используйте функцию paste(), подставив в нее поля, составляющие даты, и укажите необходимый разделитель в параметре sep(). После агрегирования данных и перед сортировкой вызовите ungroup(), иначе вы будете сортировать внутри каждой группы, а вам нужно сортировать результаты группировки. Загрузите файл с данными по энергии ветра вдоль Черноморского побережья на высотах 50 и 100 метров, который был использован в этой лекции. Данный файл имеет формат фиксированной ширины столбца (см. параграф 3.3.2.2). Произведите чтение данного файла и приведите его с помощью tidyr к аккуратному виду, разделив высоту и величину энергии на отдельные столбцы. Используя возможности dplyr, рассчитайте фрейм данных со средними значениями энергии на каждой высоте. Загрузите файл CSV с данными по населению федеральных округов России, который был использован в этой лекции. Прочтите данную таблицу, приведите ее с помощью tidyr к аккуратному виду (федеральный округ — год — население), а также вычислите в виде дополнительного столбца долю (в %), которую каждый округ занимает в общем населении России на каждый год (получится федеральный округ — год — население — доля). Оформите результат в виде одного конвейера манипуляций. Подсказка: используйте группировку таблицы по году и вычислите поле с долей путем деления поля населения на сумму по полю населения. Самсонов Т.Е. Визуализация и анализ географических данных на языке R. М.: Географический факультет МГУ, 2020. DOI: 10.5281/zenodo.901911 Ранее вместо pivot_longer() и pivot_wider() использовались функции gather() и spread() соответственно. Новые функции имеют более очевидный синтаксис и более широкие возможности, поэтому использование gather() и spread() начиная с версии 1.0.0 пакета tidyr более не рекомендуется.↩︎ "],
["tech.html", "Глава 4 Техники программирования 4.1 Функциональное программирование 4.2 Метапрограммирование 4.3 Краткий обзор 4.4 Контрольные вопросы и упражнения", " Глава 4 Техники программирования В настоящей главе мы кратко познакомимся с функциональным программированием и метапрограммированием, которые являются одними из основных техник программирования на R. 4.1 Функциональное программирование 4.1.1 Функции Функции в R можно использовать для структурирования кода на логически завершенные, автономные фрагменты кода, каждый из которых выполняет конкретную задачу. Синтаксис функции выглядит следующим образом: functionName = function(parameter1, parameter2, ...){ ... return(result) ... last_value = ... } Функция создается c помощью ключевого слова function, за которым в круглых скобках заключается произвольное количество параметров (столько, сколько вам нужно: от нуля и более). С помощью этих параметров вы сможете передавать внутрь функции значения переменных. Созданной функции необходимо дать имя, используя оператор присвоения &lt;- или =. Возврат значения функции осуществляется двумя способами: Если не указано иное, то будет возвращен результат вычисления последнего выражения, выполненного внутри функции (last_value в примере выше) Результат можно вернуть принудительно в любом месте функции, передав его в выражение return(). Выражение return() работает аналогично ключевому слову break в циклах: оно прерывает выполнение функции и осуществляет выход из нее. Как правило, return() используется, если возврат значения надо сделать где-то посередине или в начале функции. Однако я реккомендую использовать его всегда, поскольку это помогает читателю вашей функции быстро определить, что же именно возвращается из функции Как правило, функции оказываются полезны, если: Вы дублируете один и тот же код в разных частях программы Ваш код становится слишком длинным, при этом присутствует очевидная этапность решения задачи, позволяющая разбить программу на автономные блоки У вас есть фрагмент кода, который выполняет вспомогательную (второстепенную функцию), и не относится непосредственно к основной логике программы. Предположим, у нас есть линия, заданная координатами четырех точек, и нам надо вычислить длины каждого из трех отрезков. Без использования функции мы запишем это так: x = rnorm(4) y = rnorm(4) d12 = sqrt((x[1] - x[2]) ^ 2 + (y[1] - y[2]) ^ 2) d23 = sqrt((x[2] - x[3]) ^ 2 + (y[2] - y[3]) ^ 2) d31 = sqrt((x[3] - x[4]) ^ 2 + (y[3] - y[4]) ^ 2) cat(d12, d23, d31) ## 2.181091 1.196925 2.499278 В правой части этих выражений стоит один и тот же код, который я скопировал и вставил, а далее заменил названия переменных. Это плохо сразу по двум причинам: дублирование фрагментов программы и возрастание вероятности опечаток в скопированой копии. Улучшить код можно, введя функцию вычисления расстояний: distance = function(x1, y1, x2, y2) { sqrt((x1 - x2) ^ 2 + (y1 - y2) ^ 2) } d12 = distance(x[1], y[1], x[2], y[2]) d23 = distance(x[2], y[2], x[3], y[3]) d31 = distance(x[3], y[3], x[4], y[4]) cat(d12, d23, d31) ## 2.181091 1.196925 2.499278 Функция всегда возвращает один объект: значение, вектор, список и т.д. Например, мы можем сделать функцию следующего уровня, рассчитывающая сразу все расстояния для множества точек: distances = function(x, y) { n = length(x) distance(x[1:(n-1)], y[1:(n-1)], x[2:n], y[2:n]) } distances(x, y) ## [1] 2.181091 1.196925 2.499278 Можно пойти еще дальше, и сделать функцию, выполняющую вычисление длины линии, заданной координатами: line_length = function(x, y) { sum(distances(x, y)) } line_length(x, y) ## [1] 5.877294 Обратите внимание на то, как мы используем одну ранее написанную функцию при создании другой функции! Это весьма распространенная практика: одна и та же функция может быть как самостоятельно полезной (вызываться непосредственно в программе полтьзователя), так и применяться для решения задач внутри других функций. При этом иногда даже относительно простые фрагменты кода имеет смысл оформлять в виде функций, так как это может улучшить читаемость программы и пояснить смысл выполняемых операций. Так, например, line_length(x, y) в более явном виде обозначает операцию вычисления длины по координатам, нежели sum(distances(x, y)). В то же время, здесь важно не переусердствовать и оформлять короткие фрагменты кода в виде функций только если они будут применяться вами неоднократно. Если вам нужно вернуть из функции несколько объектов, имеющих разный тип или смысл, заключите их в список и дайте каждому элементу списка “говорящее” имя. Например, помимо периметра, мы можем вернуть также извилистость линии (отношение длины линии к длине отрезка, соединяющего ее первую и последнюю точку): line_params = function(x, y) { n = length(x) l = line_length(x, y) s = l / distance(x[1], y[1], x[n], y[n]) list(length = l, sinuosity = s) } result = line_params(x, y) result$length ## [1] 5.877294 result$sinuosity ## [1] 1.501007 4.1.2 Функционалы Данные (в том числе географические) практически всегда носят множественный характер и организованы в определенные структуры (см. главу 2). Эта особенность данных выдвигает логичное желание иметь процедуры, которые можно применять к полному набору данных, а не к его отдельным компонентам. Это и есть процедуры векторизованных вычислений. Предположим, вам необходимо что-то вычислить для каждой строки таблицы, при этом порядок вычисления зависит от содержимого ячеек данной строки. Вы можете организовать подобные вычисления с помощью циклов, однако в R существуют специальные функции семейста apply, которые позволяют решать подобные задачи более элегантно и с высокой скоростью: Функция Назначение apply() применить функцию ко всем строкам или столбцам матрицы lapply() применить функцию к каждому компоненту вектора или списка и получить результат также в виде списка (l — list) sapply() применить функцию к каждому компоненту вектора или списка и получить результат в виде вектора (s — simplify) vapply() аналогична vapply, но требует явного задания типа данных возвращаемого вектора, за счет чего работает быстрее (v — velocity) mapply() применить функцию к каждому компоненту нескольких векторов или списков и вернуть результат в виде списка (m — multivariate) rapply() применить функцию рекурсивно ко всем элементам переданного списка и вернуть результат в аналогичной структур (r — recursive) tapply() применить функцию ко всем компонентам вектора или списка, сгруппировав их по значению переданного фактора Функции семейства apply, принимающие на вход списки, могут работать и с фреймами данных. В этом случае фрейм внутри функции будет преобразован с помощью функции as.list() в список, элементами которого являются столбцы (переменные) входного фрейма данных. Данные при этом не потеряются, их типы тоже не изменятся. Базовая функция apply() имеет следующие аргументы: X — массив любой размерности (включая вектор) MARGIN — измерения по которым необходимо вести вычисления. Для матрицы 1 означает строку, 2 означает столбец, c(1, 2) будет означать, что вычисления производятся по всем комбинациям строк и столбцов FUN — функция, которая будет применяться к каждому элементу указанных измерений ... — список аргументов, которые надо передать в функцию FUN (в этом случае массив должен передаваться обязательно в первый аргумент) Другие функции семейства apply в приложении к фреймам данных будут работать со столбцами (переменными), интерпретируя их как элементы списка. Наиболее часто из них используются lapply(), sapply() и vapply(). В отличие от apply(), они уже не принимаеют номера измерений и работают только с элементами переданного списка. Рассмотрим применение функций данного семейства на примере анализа основных социально-экономических характеристик столиц субъектов Северо-Западного округа за 2015 год: # Функционалы library(tidyverse) ## ── Attaching packages ─────────── tidyverse 1.3.0 ── ## ✓ ggplot2 3.2.1 ✓ stringr 1.4.0 ## ✓ purrr 0.3.3 ✓ forcats 0.4.0 ## ── Conflicts ────────────── tidyverse_conflicts() ── ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() library(readxl) (df = read_excel(&quot;data/sevzap.xlsx&quot;, col_types = c(&#39;text&#39;, rep(&#39;numeric&#39;, 17)))) ## # A tibble: 10 x 18 ## city pop birth death labor salary livspace doctors hosp assets business ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Петр… 277. 13 12.3 72.3 36268. 24.4 75 17 2.47e5 15856 ## 2 Сыкт… 259. 14.5 10.4 84.1 39790 22.8 79.5 17 2.17e5 10068 ## 3 Арха… 358. 11.8 11.6 97.9 40303. 22.7 82.3 19 2.79e5 13016 ## 4 Нарь… 24.5 18.1 7.6 12.7 69884. 23.6 65.2 2 1.05e5 704 ## 5 Воло… 313. 16.2 11.4 91 31483 24.7 60.9 18 8.27e5 21931 ## 6 Кали… 460. 13.3 13.4 126. 34142 27.7 69.8 25 3.27e5 38013 ## 7 Мурм… 302. 12.4 11.9 96.9 53240. 23.8 68.8 15 7.24e5 16041 ## 8 Вели… 222. 13.8 13.8 74.1 32377. 24.1 78.9 14 1.59e5 9583 ## 9 Псков 208. 13.2 13.7 59.6 27405. 25 59 13 1.31e5 8752 ## 10 Санк… 5226. 13.6 11.9 2055. 44187 23.6 73.8 112 4.10e6 374999 ## # … with 7 more variables: minerals &lt;dbl&gt;, manufact &lt;dbl&gt;, engaswat &lt;dbl&gt;, ## # construct &lt;dbl&gt;, apart &lt;dbl&gt;, retail &lt;dbl&gt;, invest &lt;dbl&gt; В данной таблице каждый столбец представляет независимую переменную со своими единицами измерения, поэтому ее необходимо оставить в “широкой” форме, не преобразуя в длинную. Используя apply, можно быстро получить максимальные значения каждой переменной: apply(df[-1], 2, max) ## pop birth death labor salary livspace doctors hosp ## 5225.7 18.1 13.8 2055.3 69883.5 27.7 82.3 112.0 ## assets business minerals manufact engaswat construct apart retail ## 4102243.8 374999.0 NA 1978634.0 173292.0 397229.0 3031.0 1144607.0 ## invest ## 521293.0 Что равносильно вызову sapply: sapply(df[-1], max) ## pop birth death labor salary livspace doctors hosp ## 5225.7 18.1 13.8 2055.3 69883.5 27.7 82.3 112.0 ## assets business minerals manufact engaswat construct apart retail ## 4102243.8 374999.0 NA 1978634.0 173292.0 397229.0 3031.0 1144607.0 ## invest ## 521293.0 В качестве функции можно использовать не только стандартные, но и пользовательские функции. Например, нам может быть интересно не максимальное значение показателя, а его отношение к среднему значению среди всех городов. Здесь уже одной функцией не обойдешься, так как нужно каждый столбец поделить на среднее значение по нему. Для этого определим небольшую пользовательскую функцию непосредственно при вызове sapply(): (normalized = sapply(df[-1], function(X) { round(X / mean(X, na.rm = TRUE), 2) })) ## pop birth death labor salary livspace doctors hosp assets business ## [1,] 0.36 0.93 1.04 0.26 0.89 1.01 1.05 0.67 0.35 0.31 ## [2,] 0.34 1.04 0.88 0.30 0.97 0.94 1.11 0.67 0.30 0.20 ## [3,] 0.47 0.84 0.98 0.35 0.99 0.94 1.15 0.75 0.39 0.26 ## [4,] 0.03 1.29 0.64 0.05 1.71 0.97 0.91 0.08 0.15 0.01 ## [5,] 0.41 1.16 0.97 0.33 0.77 1.02 0.85 0.71 1.16 0.43 ## [6,] 0.60 0.95 1.14 0.46 0.83 1.14 0.98 0.99 0.46 0.75 ## [7,] 0.39 0.89 1.01 0.35 1.30 0.98 0.96 0.60 1.02 0.32 ## [8,] 0.29 0.99 1.17 0.27 0.79 0.99 1.11 0.56 0.22 0.19 ## [9,] 0.27 0.94 1.16 0.22 0.67 1.03 0.83 0.52 0.18 0.17 ## [10,] 6.83 0.97 1.01 7.42 1.08 0.97 1.03 4.44 5.76 7.37 ## minerals manufact engaswat construct apart retail invest ## [1,] 0.06 0.05 0.52 0.13 0.45 0.23 0.11 ## [2,] 0.00 0.28 0.43 0.09 0.31 0.21 0.14 ## [3,] 0.00 0.06 0.49 0.09 0.17 0.17 0.15 ## [4,] 4.12 0.05 0.03 0.08 0.05 0.02 0.52 ## [5,] NA 0.15 0.63 0.09 0.52 0.23 0.13 ## [6,] 0.82 0.83 0.68 0.28 1.24 0.38 0.53 ## [7,] NA 0.23 0.42 0.07 0.02 0.29 0.75 ## [8,] NA 0.42 0.45 0.08 0.32 0.17 0.30 ## [9,] NA 0.08 0.22 0.04 0.27 0.17 0.10 ## [10,] 1.00 7.87 6.13 9.05 6.65 8.13 7.28 Полученный объект является матрицей. Таким образом, можно видеть, что функционалы бывают полезны не только для агрегирования таблиц, но и для преобразования данных, когда структура таблицы остается прежней. В приведенном выше коде мы сознательно исключили первый столбец, поскольку он является текстовым. Можно сделать более мощную и универсальную функцию, которая будет нормировать все числовые столбцы таблицы, а текстовые оставлять в оригинале. Для этого проверку типа данных надо внести внутрь функции. Поскольку код функции при этом вырастает, целесообразно определить ее заранее. Поскольку в этом случае часть векторов будет символьной, а не числовой, необходимо применять функцию lapply(), которая вернет список из векторов, а не матрицу и таким образом сохранит типы каждого столбца: normalize = function(X) { if (is.numeric(X)) round(X / mean(X, na.rm = TRUE), 2) else X } (normalized_df = df %&gt;% lapply(normalize) %&gt;% as_tibble()) ## # A tibble: 10 x 18 ## city pop birth death labor salary livspace doctors hosp assets business ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Петр… 0.36 0.93 1.04 0.26 0.89 1.01 1.05 0.67 0.35 0.31 ## 2 Сыкт… 0.34 1.04 0.88 0.3 0.97 0.94 1.11 0.67 0.3 0.2 ## 3 Арха… 0.47 0.84 0.98 0.35 0.99 0.94 1.15 0.75 0.39 0.26 ## 4 Нарь… 0.03 1.29 0.64 0.05 1.71 0.97 0.91 0.08 0.15 0.01 ## 5 Воло… 0.41 1.16 0.97 0.33 0.77 1.02 0.85 0.71 1.16 0.43 ## 6 Кали… 0.6 0.95 1.14 0.46 0.83 1.14 0.98 0.99 0.46 0.75 ## 7 Мурм… 0.39 0.89 1.01 0.35 1.3 0.98 0.96 0.6 1.02 0.32 ## 8 Вели… 0.290 0.99 1.17 0.27 0.79 0.99 1.11 0.56 0.22 0.19 ## 9 Псков 0.27 0.94 1.16 0.22 0.67 1.03 0.83 0.52 0.18 0.17 ## 10 Санк… 6.83 0.97 1.01 7.42 1.08 0.97 1.03 4.44 5.76 7.37 ## # … with 7 more variables: minerals &lt;dbl&gt;, manufact &lt;dbl&gt;, engaswat &lt;dbl&gt;, ## # construct &lt;dbl&gt;, apart &lt;dbl&gt;, retail &lt;dbl&gt;, invest &lt;dbl&gt; В качестве альтернативы функциям apply можно также воспользоваться вычислениями посредством функций семейства map из пакета purrr (еще один пакет из tidyverse). Эти функции работают аналогично sapply(): map() возвращает список. map_lgl() возвращает вектор логических значений. map_int() возвращает вектор целочисленных значений. map_dbl() возвращает вектор чисел с плавающей точкой. map_chr() возвращает вектор строк. Например, вышеприведенные операции можно осуществить средствами purrr вот так: map_dbl(df[-1], max) ## pop birth death labor salary livspace doctors hosp ## 5225.7 18.1 13.8 2055.3 69883.5 27.7 82.3 112.0 ## assets business minerals manufact engaswat construct apart retail ## 4102243.8 374999.0 NA 1978634.0 173292.0 397229.0 3031.0 1144607.0 ## invest ## 521293.0 df %&gt;% map(normalize) %&gt;% as_tibble() ## # A tibble: 10 x 18 ## city pop birth death labor salary livspace doctors hosp assets business ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Петр… 0.36 0.93 1.04 0.26 0.89 1.01 1.05 0.67 0.35 0.31 ## 2 Сыкт… 0.34 1.04 0.88 0.3 0.97 0.94 1.11 0.67 0.3 0.2 ## 3 Арха… 0.47 0.84 0.98 0.35 0.99 0.94 1.15 0.75 0.39 0.26 ## 4 Нарь… 0.03 1.29 0.64 0.05 1.71 0.97 0.91 0.08 0.15 0.01 ## 5 Воло… 0.41 1.16 0.97 0.33 0.77 1.02 0.85 0.71 1.16 0.43 ## 6 Кали… 0.6 0.95 1.14 0.46 0.83 1.14 0.98 0.99 0.46 0.75 ## 7 Мурм… 0.39 0.89 1.01 0.35 1.3 0.98 0.96 0.6 1.02 0.32 ## 8 Вели… 0.290 0.99 1.17 0.27 0.79 0.99 1.11 0.56 0.22 0.19 ## 9 Псков 0.27 0.94 1.16 0.22 0.67 1.03 0.83 0.52 0.18 0.17 ## 10 Санк… 6.83 0.97 1.01 7.42 1.08 0.97 1.03 4.44 5.76 7.37 ## # … with 7 more variables: minerals &lt;dbl&gt;, manufact &lt;dbl&gt;, engaswat &lt;dbl&gt;, ## # construct &lt;dbl&gt;, apart &lt;dbl&gt;, retail &lt;dbl&gt;, invest &lt;dbl&gt; 4.2 Метапрограммирование Метапрограммирование — это техника программирования, при которой программный код может генерировать другой код. Широкая поддержка и интенсивное использование метапрограммирования – одна из удивительных черт R, которая ставит его особняком на фоне многих других языков, включая Python. Метапрограммирование позволяет во многих случаях сделать код более компактным и подойти к решению задачи элегантным путем. Вы уже сталкивались с метапрограммированием, когда работали с функциями dplyr. Например, сравните следующие два способа извлечь столбец из фрейма данных: df[&quot;salary&quot;] ## # A tibble: 10 x 1 ## salary ## &lt;dbl&gt; ## 1 36268. ## 2 39790 ## 3 40303. ## 4 69884. ## 5 31483 ## 6 34142 ## 7 53240. ## 8 32377. ## 9 27405. ## 10 44187 select(df, salary) ## # A tibble: 10 x 1 ## salary ## &lt;dbl&gt; ## 1 36268. ## 2 39790 ## 3 40303. ## 4 69884. ## 5 31483 ## 6 34142 ## 7 53240. ## 8 32377. ## 9 27405. ## 10 44187 В обоих случаях мы получили один и тот же результат. В первом случае было указано название столбца в кавычках. Во втором мы передали название столбца без кавычек, точно так же как было передано название фрейма данных. Однако фрейм данных с названием df был создан перед вызовом select. Вас не смущает, что объекта salary в нашем скрипте не существует, а мы его передаем в качестве аргумента функции? Мы ведь не создавали такой переменной в программе. Как же функция догадывается о том, что его надо интерпретировать не как переменную, а как название столбца? Для начала разберемся с тем, что происходит в программном коде: select() представляет собой вызов (call) функции df и salary представляют собой символы, обозначающие объекты в программе. \"salary\" представляет собой константу R — это функциональный язык программирования. Любая программа на R состоит из вызовов функций, которые применяются к символам и константам. Привычные нам арифметические операции на самом деле тоже являются вызовами функций. Это выглядит довольно неожиданно: a = 78 # стандартная запись `=`(a, 78) # функциональная запись a + 4 # стандартная запись ## [1] 82 `+`(a, 4) # функциональная запись ## [1] 82 df[&#39;salary&#39;] # стандартная запись ## # A tibble: 10 x 1 ## salary ## &lt;dbl&gt; ## 1 36268. ## 2 39790 ## 3 40303. ## 4 69884. ## 5 31483 ## 6 34142 ## 7 53240. ## 8 32377. ## 9 27405. ## 10 44187 `[`(df, &#39;salary&#39;) # функциональная запись ## # A tibble: 10 x 1 ## salary ## &lt;dbl&gt; ## 1 36268. ## 2 39790 ## 3 40303. ## 4 69884. ## 5 31483 ## 6 34142 ## 7 53240. ## 8 32377. ## 9 27405. ## 10 44187 Таким образом, бинарный оператор в R представляет собой вызов функции с двумя аргументами. Программный код a + 4 с точки зрения R является выражением (expression). Выражение может состоять вообще из одного символа, то есть a — это тоже выражение. Когда интерпретатор доходит до выражения a + 4, он выполняет следующее: Оценка (evaluation) выражения a. Результатом оценки является константа 78 Вызов (call) функции +, которая складывает константы 78 и 4 Не все символы и выражения в программе необходимо оценивать. Некоторые из них необходимо квотировать, то есть использовать в качестве имени объекта. Квотацию можно условно рассматривать как простановку кавычек вокруг выражения. Для обозначения квотации в явном виде используются обратные кавычки: ` Мы уже сталкивались с квотацией при вызове функции сложения: `+`(a, 4). В данном случае квотация была нужна чтобы + интерпретировался как имя функции. Явная квотация бывает необходима, когда объекты R имеют недопустимые имена, например начинаются с цифры или содержат пробелы. Для начала рассмотрим искусственный пример: `f + 17` = 87 # создаем объект с именем f + 17 f + 17 # ошибка: переменной f не существует ## [1] 5.5 `f + 17` # обращаемся к объекту путем явной квотации ## [1] 87 Теперь более жизнеспособный пример: данные о населении федеральных округов: library(readr) (okruga = read_csv(&#39;data/okruga.csv&#39;)) ## Parsed with column specification: ## cols( ## `№` = col_double(), ## Регион = col_character(), ## `2005` = col_double(), ## `2010` = col_double(), ## `2011` = col_double(), ## `2012` = col_double(), ## `2013` = col_double() ## ) ## # A tibble: 8 x 7 ## `№` Регион `2005` `2010` `2011` `2012` `2013` ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 Центральный 4341 3761 3613 3651 3570 ## 2 2 Северо-Западный 3192 3088 2866 2877 2796 ## 3 3 Южный федеральный 1409 1446 1436 1394 1321 ## 4 4 Северо-Кавказский 496 390 397 395 374 ## 5 5 Приволжский 3162 2883 2857 2854 2849 ## 6 6 Уральский 1681 1860 1834 1665 1624 ## 7 7 Сибирский 2575 2218 2142 2077 1941 ## 8 8 Дальневосточный 871 870 821 765 713 Обратите внимание на обратные кавычки вокруг названий столбцов. Они проставлены потому что числа в среде R по умолчанию оцениваются, и не могут использоваться в качестве символов для объектов. Чтобы разрешить это, используется принудительная квотация. Как мы уже знаем, чтобы обратиться к такому объекту, надо использовать обратные кавычки: okruga$2010 # ошибка: 2010 - константа, которая оценивается ## Error: &lt;text&gt;:1:8: неожиданная числовая константа ## 1: okruga$2010 ## ^ okruga$`2010` # правильно: `2010` -- символ, полученный путем квотации ## [1] 3761 3088 1446 390 2883 1860 2218 870 Теперь вернемся к примеру с использованием функции select(). Данная функция оценивает первый аргумент (фрейм данных) и квотирует все оставшиеся аргументы, которые отвечают за названия столбцов. Это позволяет избежать использования кавычек и использовать символы для наименования объектов. Чтобы понять, использует ли функция оценку или квотацию ее аргументов, необходимо ознакомиться с ее справкой. Когда функция применяет квотацию аргументов, говорят что осуществляется нестандартная оценка (NSE – non-standard evaluation). Если аргументы функции оцениваются, то происходит стандартная оценка (SE – standard evaluation) Иногда бывает необходимо использовать строковые названия столбцов (например, если они записаны у вас в переменные). В таком случае можно использовать функцию select_() (с подчеркиванием в конце), которая будет выполнять оценку ее аргументов вместо квотации: f1 = &#39;salary&#39; f2 = &#39;birth&#39; select_(df, f1, f2) # ОК ## # A tibble: 10 x 2 ## salary birth ## &lt;dbl&gt; &lt;dbl&gt; ## 1 36268. 13 ## 2 39790 14.5 ## 3 40303. 11.8 ## 4 69884. 18.1 ## 5 31483 16.2 ## 6 34142 13.3 ## 7 53240. 12.4 ## 8 32377. 13.8 ## 9 27405. 13.2 ## 10 44187 13.6 select_(df, salary, birth) # ошибка: функция пыьтается оценить несуществующие объекты salary и birth ## Error in compat_lazy_dots(.dots, caller_env(), ...): объект &#39;salary&#39; не найден Однако кавычки в данном случае усложняют внешний вид программы и затрудняют написание ее текста. Если вы передаете константы в качестве аргументов, они будут работать в обоих случаях: select(df, &#39;salary&#39;, &#39;birth&#39;) ## # A tibble: 10 x 2 ## salary birth ## &lt;dbl&gt; &lt;dbl&gt; ## 1 36268. 13 ## 2 39790 14.5 ## 3 40303. 11.8 ## 4 69884. 18.1 ## 5 31483 16.2 ## 6 34142 13.3 ## 7 53240. 12.4 ## 8 32377. 13.8 ## 9 27405. 13.2 ## 10 44187 13.6 select_(df, &#39;salary&#39;, &#39;birth&#39;) ## # A tibble: 10 x 2 ## salary birth ## &lt;dbl&gt; &lt;dbl&gt; ## 1 36268. 13 ## 2 39790 14.5 ## 3 40303. 11.8 ## 4 69884. 18.1 ## 5 31483 16.2 ## 6 34142 13.3 ## 7 53240. 12.4 ## 8 32377. 13.8 ## 9 27405. 13.2 ## 10 44187 13.6 Функции dplyr имеют парные к ним функции с символом подчеркивания на конце, которые производят оценку, а не квотацию аргументов. Иногда выражения бывает необходимо создать, а оценивать уже потом. Для этого существуеют объекты выражений, которые создаются с помощью функции expression(): (d = expression(b^2 - 4*a)) # создаем выражение ## expression(b^2 - 4 * a) a = 2 b = 7 eval(d) # оцениваем значение выражения ## [1] 41 Все символы в объекте выражения по умолчанию квотируются и выражение хранится в статичном виде до тех пор пока не будет произведена его оценка (подстановка значений переменных вместо их символов). Выражения используются в формулах, используемых для статистического анализа в R 4.3 Краткий обзор 4.4 Контрольные вопросы и упражнения 4.4.1 Вопросы Что такое функция? Какое ключевое слово ипользуется для создания функции? В каких случаях целесообразно применение функций? Сколько аргументов может принимать функция? Можно ли из одной функции вызывать другую функцию? Как осуществить принудительный выход из функции с возвратом результата? Что необходимо сделать, если надо передать несколько объектов из функции? Для чего нужны функционалы семейства apply? В каких задачах они бывают полезны? Перечислите функции семейства apply, назовите их отличия и сферы применения. Какая функция семейства apply позволяет обабатывать заданные измерения? Какой объект первым передается в функцию, подставляемую в параметр FUN, если применяется lapply к фрейму данных? Назовите аналоги функций apply из пакета purrr Что такое метапрограммирование? Из каких объектов состоят выражения в R? Что из себя по на самом деле представляют бинарные операторы в R? Как обратиться к объекту, символ которого не является допустимым именем переменной? Что такое оценка и квотация выражения? Для чего они используются? Как понять, будет ли используемая вами функция квотрировать или оценивать ее аргументы? Как называются функции dplyr, осуществляющие оценку, а не квотацию аргументов? Как создать и оценить объект выражения в R? 4.4.2 Упражнения Напишите функцию is_leap(year), которая определяет, является ли указанный год високосным. Протестируйте ее в вашем скрипте, используя чтение года из консолии Подсказка: високосным считается год, кратный 400, либо кратный 4, но не кратный 100. Функция Тоблера показывает зависимость скорости пешего маршрута (в км/ч) от угла наклона на местности. Предположим, в вашем распоряжении имеется матрица профиля рельефа, в которой в одном столбце указано расстояние от начала маршрута, а во втором — абсолютная отметка точки. Напишите функцию hiking_time(profile), которая вычисляет время прохождения маршрута на основе переданной ей матрицы. Используйте для тестирования функции маршрут из 10 точек с шагом в 1 км и случайным разбросом высот в диапазоне от 500 до 1000 метров (равномерное распределение). Подсказка: угол наклона на каждом участке считается постоянным. Для вычисления экспоненты используйте встроенную функцию exp(). Создайте на основе данных по Москве с сайта pogodaiklimat таблицу Excel с повторяемостью различных направлений ветра. Не преобразовывая структуру данных, вычислите на ее основе с помощью lapply() преобладающее направление для каждого месяца. Представьте результат как фрейм данных. В текущей лекции мы работали с данными по характеристикам центров субъектов СЗФО. Напишите функцию get_extremes(df), которая определяет названия переменных, по которым каждая строчка фрейма данных (в нашем случае — город) занимает максимальное и минимальное положение относительно среднего значения по всем городам. Например, Петрозаводск имеет максимальный рейтинг по показателю doctors (1.05) — количество врачей на 10000 чел и минимальный по показателю manufact (0.05) — продукции обрабатывающей промышленность (в млн руб). Результирующая таблица должна содержать первое по счету поле, а также поля minvar и maxvar: Region minvar maxvar Петрозаводск doctors manufact ... ... Подсказка: для начала вам надо нормировать значения всех переменных с помощью lapply(). Затем нужно определить номер столбца, имеющего максимальное и минимальное значений для каждой строки таблицы. Используйте для этого функции which.min() и which.max() возвращающие индекс максимального и минимального элемента вектора, в комбинации с функцией colnames(), возвращающей названия переменных. Применяйте функцию apply(), которая умеет ходить по строкам. Самсонов Т.Е. Визуализация и анализ географических данных на языке R. М.: Географический факультет МГУ, lubridate::year(Sys.Date()). DOI: 10.5281/zenodo.901911 "]
]
