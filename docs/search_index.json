[
["interpolation-deterministic.html", "Глава 13 Детерминистическая интерполяция 13.1 Введение 13.2 Построение сетки 13.3 Интерполяционные методы 13.4 Аппроксимационные методы 13.5 Контрольные вопросы и упражнения", " Глава 13 Детерминистическая интерполяция Программный код главы В лекции рассмотрены детерминистические методы восстановления непрерывных поверхностей по данным в точках. Детерминистичекие методы интерполяции производят интерполяцию значений на основе заданной аналитической зависимости между значением в точке и значениями в пунктах с исходными данными. Это отличает их от методов геостатистических, где эта зависимость находится статистическим путем. Геостатистические методы будут рассмотрены далее. 13.1 Введение Интерполяция в общем случае — это способ нахождения промежуточных значений величины по имеющемуся дискретному набору известных значений. В географии обычно имеют дело с двумерным случаем интерполяции — когда измерения проведены в некоторых географических локациях, и по ним нужно восстановить непрерывную картину поля распределения величины. В общем случае неизвестно, как ведет себя исследуемое явление между точками, поэтому существует бесчисленное множество вариантов интерполяции. Методы которые производят интерполяцию на основе заданной аналитической зависимости, называют детерминистическими. Параметры этой зависимости могут быть как априори заданы пользователем, так и определяться автоматически одним из методов оптимизации — в частности, по методу наименьших квадратов. Например, мы можем сказать, что между соседними точками показатель меняется линейным образом (здесь нужно еще указать, что мы понимаем под соседством). Такие методы достаточно просты в использовании и интерпретации. В то же время, они не учитывают статистических особенностей поведения величины между точками, которое определяется ее автокорреляционными свойствами. Методы интерполяции, которые учитывают простраственную автокорреляцию, называют геостатистическими. Они более сложны в использовании, но потенцально могут дать более достоверные результаты. В этом модуле мы познакомимся со следующими детерминистическими методами интерполяции. Метод ближайшего соседа (nearest neighbor) Метод интерполяции на основе триангуляции Метод обратно взвешенных расстояний (ОВР) Метод радиальных базисных функций (РБФ) Метод иерархических базисных сплайнов (ИБС) Интерполяцию будем рассматривать на примере данных по количеству осадков на метеостанциях в северной Италии (долина реки По и окружающие горы). Станции распределены в пространстве нерегулярно, что позволит визуально оценить чувстительность методов к этому фактору. Прежде чем исследовать распределение показателя, необходимо проанализировать географический контекст. В этой части модуля мы воспользуемся уже известными функциями чтобы создать карту с общегеографической основой и нанести на нее пункты метеонаблюдений. library(sf) library(sp) library(dismo) library(akima) # библиотека для интерполяции на основе триангуляции library(rgdal) library(gstat) # библиотека для геостатистической интерполяции, построения трендов и IDW library(raster) library(plotly) library(maptools) library(lattice) library(deldir) # библиотека для построения триангуляции Делоне и диаграммы Вороного library(fields) # радиальные базисные функции (сплайны минимальной кривизны) library(MBA) # иерархические базисные сплайны # Убираем экспоненциальное представление больших чисел options(scipen=999) # Читаем слои картографической основы cities = st_read(&quot;Italy_Cities.gpkg&quot;) # Города ## Reading layer `Italy_Cities&#39; from data source `/Users/tsamsonov/GitHub/r-geo-course/data/Italy_Cities.gpkg&#39; using driver `GPKG&#39; ## Simple feature collection with 8 features and 37 fields ## geometry type: POINT ## dimension: XY ## bbox: xmin: 368910.4 ymin: 4930119 xmax: 686026 ymax: 5115936 ## epsg (SRID): 32632 ## proj4string: +proj=utm +zone=32 +datum=WGS84 +units=m +no_defs rivers = st_read(&quot;Italy_Rivers.gpkg&quot;) # Реки ## Reading layer `Italy_Rivers&#39; from data source `/Users/tsamsonov/GitHub/r-geo-course/data/Italy_Rivers.gpkg&#39; using driver `GPKG&#39; ## Simple feature collection with 23 features and 10 fields ## geometry type: MULTILINESTRING ## dimension: XY ## bbox: xmin: 332178.5 ymin: 4922880 xmax: 758033.3 ymax: 5121416 ## epsg (SRID): 32632 ## proj4string: +proj=utm +zone=32 +datum=WGS84 +units=m +no_defs lakes = st_read(&quot;Italy_Lakes.gpkg&quot;) # Озера ## Reading layer `Italy_Lakes&#39; from data source `/Users/tsamsonov/GitHub/r-geo-course/data/Italy_Lakes.gpkg&#39; using driver `GPKG&#39; ## Simple feature collection with 6 features and 13 fields ## geometry type: POLYGON ## dimension: XY ## bbox: xmin: 460686.2 ymin: 4938750 xmax: 757443.7 ymax: 5113557 ## epsg (SRID): 32632 ## proj4string: +proj=utm +zone=32 +datum=WGS84 +units=m +no_defs # Читаем ЦМР — цифровую модель рельефа на регулярной сетке dem = raster(&quot;gtopo.tif&quot;) # Читаем данные об осадках rainfall=read.table(&quot;Rainfall.dat&quot;, header = TRUE) # Создаем точечные объекты по координатам на основе таблицы coords = cbind(rainfall$x, rainfall$y) pts = SpatialPointsDataFrame(coords, rainfall) # Цветовая шкала для осадков rain.colors = colorRampPalette(c(&quot;white&quot;, &quot;dodgerblue&quot;, &quot;dodgerblue4&quot;)) # Шкала количества осадков и соответствющее число цветов rain.levels = seq(0,80,by=10) rain.ncolors = length(rain.levels)-1 # Цветовая шкала для рельефа dem.colors=colorRampPalette(c(&quot;darkolivegreen4&quot;,&quot;lightyellow&quot;,&quot;orange&quot;, &quot;firebrick&quot;)) # Шкала высот для рельефа dem.levels = c(0,50,100,200,500,1000,1500,2000,2500,3000,3500,4000,5000) dem.ncolors = length(dem.levels) - 1 # Шкала подписей высот для легенды рельефа dem.labels = c(0,200,500,1000,1500,2000,2500,3000,3500,4000,5000) par(mfrow = c(1,1)) # Настраиваем параметры легенды args = list(at = dem.labels, cex.axis = 0.7) # Рисуем рельеф гипсометрическим способом plot(dem, breaks = dem.levels, col = dem.colors(dem.ncolors), legend.width = 1.5, legend.shrink = 1.0, axis.args = args) # Наносим горизонтали contour(dem, levels = dem.levels, add = TRUE, col = rgb(0, 0, 0, 0.5)) # Наносим элементы картографической основы plot(rivers, col = &quot;midnightblue&quot;, add = TRUE) plot(lakes, border = &quot;midnightblue&quot;, col = &quot;lightblue&quot;, add = TRUE) # Наносим точки с данными plot(pts, pch = 20, cex = 0.75, add = TRUE) # Наносим города поверх точек, чтобы они не потерялись plot(cities %&gt;% st_geometry(), pch = 21, bg = rgb(1, 1, 1, 0.7), cex = 0.8, add = TRUE) # Наносим подписи городов text(st_coordinates(cities)[,1], st_coordinates(cities)[,2], cities$name, pos = 4, col = &quot;black&quot;) 13.2 Построение сетки Любопытным свойством пакетов R, отвечающих за интерполяцию данных, является их индифферентность относительно того, в каких точках эта интерполяция будет производиться. Это может быть как регулярная растровая сетка, так и множество точек в совершенно произвольных конфигурациях. Подобная гибкость делает процесс интерполяции данных чуть более сложным, чем в ГИС-пакетах, однако способствует полному и глубокому пониманию происходящего. Вы своими руками задаете пункты, в которых следует интерполировать значения. Мы воспользуемся замечательной функцией spsample() из пакета sp, чтобы создать регулярную сетку для интерполяции данных. В целях наглядности для начала сделаем сетку с шагом \\(10\\) км. Первый аргумент spsample() задает географический охват (экстент), в пределах которого необходимо произвести размещение точек, параметр type = отвечает за тип семплирования (spatial sampling): # ПОСТРОЕНИЕ СЕТКИ ДЛЯ ИНТЕРПОЛЯЦИИ pts.grid = spsample(pts, type = &#39;regular&#39;, cellsize = 10000) plot(pts, pch = 20, cex = 0.75) plot(pts.grid, pch = &#39;+&#39;, cex = 0.75, add = TRUE) Получившееся представление можно уже назвать сеточной моделью. Каждая точка является узлом сетки, и в ней можно произвести интерполяцию показателя. Если мы хотим использовать результат как поверхность, необходимо сеточную модель превратить в растровую (пиксельную). Тогда каждый узел сетки станет центром соответствующей ячейки растра (пиксела), и вся интерполируемая площадь будет покрыта пикселами без пустых мест. В пределах каждого пиксела величина будет считаться постоянной. Ее значение будет интерполировано в центре пиксела. Создадим и визуализируем сетку пикселов: pixels.grid = SpatialPixels(pts.grid) plot(pts, pch = 20, cex = 0.75) plot(pixels.grid, add = TRUE, col = &quot;black&quot;) Можно видеть, что и сетка узлов, и сетка пикселов не выровнены идеально относительно охвата исходных данных. Часть точек не попадает в пределы построенной сетки. Это связано с тем, что размеры прямоугольника, ограничивающего множество точек, не кратны выбранному разрешению растра (\\(10 000\\) м). При этом размещать точки “с запасом”, т.е. за пределами ограничивающего прямоугольника, смысла нет, так как далеко не все методы интерполяции позволяют восстанавливать данные за пределами области данных. Проблема, однако, не столько критична, если вы выбираете достаточно подробное (малое) разрешение растра, что мы и сделаем. Зададим его равным \\(1 000\\) м. pts.grid = spsample(pts, type = &#39;regular&#39;, cellsize = 1000) pixels.grid = SpatialPixels(pts.grid) # извлечем координаты точек в соответствующие столбцы, они нам пригодятся: coords.grid = data.frame(coordinates(pts.grid)) names(coords.grid) = c(&quot;x&quot;, &quot;y&quot;) # получим также ограничивающий прямоугольник вокруг точек: box = bbox(pts) envelope = extent(pts) %&gt;% as.vector() 13.3 Интерполяционные методы 13.3.1 Метод ближайшего соседа (nearest neighbour) Данный метод является простейшим по сути подходом к интерполяции. В его основе лежит построение диаграммы Вороного исходного множества точек. Считается, что в пределах каждой ячейки диаграммы значение показателя постоянно и равно значению в центре ячейки. Далее поверх диаграммы накладывается сетка интерполируемых точек и снимаются соответствующие значения: # МЕТОД БЛИЖАЙШЕГО СОСЕДА (NEAREST NEIGHBOR) voronoi.sp = voronoi(pts, ext = envelope) plot(voronoi.sp) plot(pts, pch = 19, cex = 0.5, add = TRUE) # Диаграмма Вороного является дополнением триангуляции Делоне: edges = deldir(pts$x, pts$y, rw = envelope) %&gt;% triang.list() plot(edges, border = &#39;blue&#39;, lwd = 0.5, add = TRUE) Как видите, нам пришлось несколько потрудиться чтобы соорудить пространственный слой вручную. Давайте посмотрим, как выглядит результат, с помощью lattice: # Список с дополнительным элементом графика — точками layout = list(&quot;sp.points&quot;, pts, pch = 20, col = &quot;black&quot;) spplot(voronoi.sp, zcol = &quot;rain_24&quot;, at = rain.levels, col.regions = rain.colors(rain.ncolors), sp.layout = layout) Если есть задача конвертировать это в растр, то надо сформировать новый растр и “перенести” на него информацию с полигонов: # Создаем растр raster.out = raster(pixels.grid) # Снимаем в него значения полигонов rnn = rasterize(voronoi.sp, raster.out, field = &quot;rain_24&quot;) # Визуализируем: plot(rnn, breaks = rain.levels, col=rain.colors(rain.ncolors)) plot(pts, pch=16, cex=0.5, col = &quot;black&quot;, add = TRUE) Видно, что полученная поверхность уже пиксельная. Для наглядности визуализирем ее в трехмерном виде. Для этого используем замечательный пакет plotly, предоставляющий интерфейс к одноименной библиотеке. Функция plot_ly(), отвечающая за построение графиков в этом пакете, требует для визуализации поверхности предоставить три компоненты: x - вектор координат ячеек по оси \\(Х\\) y - вектор координат ячеек по оси \\(Y\\) z - матрицу значений, имеющую размеры \\(length(x) \\times length(y)\\) Поверхность будет раскрашиваться в различные цвета в зависимости от значений z, для управления цветами можно определить параметр colors, который должен иметь тип colorRamp: rain.colors3d = colorRamp(c(&quot;white&quot;, &quot;dodgerblue&quot;, &quot;dodgerblue4&quot;)) x = unique(pts.grid@coords[,1]) # Получим координаты столбцов y = unique(pts.grid@coords[,2]) # Получим координаты строк z = as.matrix(rnn) # Получим высоты в виде матрицы p = plot_ly(x = x, y = y, z = z, type = &quot;surface&quot;, colors = rain.colors3d) layout(p, scene = list(aspectratio = list(x = 1, y = 1, z = 0.3) )) Понятное дело, что такая ступенчатая форма поверхности вряд ли соответствует реальному распределению показателя, который меняется в пространстве неперывным образом. Можно сказать, что это первое приближение пространственного распределения. 13.3.2 Интерполяция на основе триангуляции Интерполяция на основе триангуляции — метод интерполяции, результатом которого вляется уже не ступенчатая поверхность, а аппроксимированная треугольными гранями — наподобие того как объекты представлены в системах трехмерного моделирования и компьютерных играх. Каждый треугольник определяет наклонный участок поверхности между тремя соседними точками. С построенных треугольников уже далее снимаются значения в заданных точках. Для этого обычно используется линейная интерполяции, результатом которой является угловатая “граненая” поверхность. Также возможно применение бикубической интерполяции, или метода Акимы, который позволяет сгладить поверхность за счет применения полиномов 5-й степени. # ИНТЕРПОЛЯЦИЯ НА ОСНОВЕ ТРИАНГУЛЯЦИИ (TRIANGULATION) # Интерполятор на основе триангуляции требует, чтобы результирующие точки имели тип SpatialPointsDataFrame: pts.grid.df = SpatialPointsDataFrame(pts.grid, data = coords.grid) # Интерполируем. Параметр linear говорит о том, что показатель будет меняться вдоль ребер триангуляции линейно: z.linear = interpp(x = pts, z = &quot;rain_24&quot;, xo = pts.grid.df, linear = TRUE) # Переносим результат на сетку пикселей: px.linear = SpatialPixelsDataFrame(pts.grid.df, data = as.data.frame(z.linear$z)) # Создаем объект типа raster, который можно визуализировать в привычном виде: r.linear = raster(px.linear) # Смотрим как выглядит результат plot(r.linear, breaks = rain.levels, col=rain.colors(rain.ncolors)) contour(r.linear, levels = rain.levels, add = TRUE) plot(edges, pch = 19, lwd = 0.5, lty = 3, cex = 0.5, add = TRUE) plot(pts, pch = 20, cex = 0.5, add = TRUE) Обратите внимание, что все изломы (повороты) изолиний происходят на ребрах триангуляции, а внутри треугольников изолинии проходят параллельно друг другу. Каждый треугольник представляет собой фрагмент наклонной плоскости. Такой метод интерполяции, по сути, является самым простым и “честным” подходом, который близок к тому как горизонтали интерполируются вручную. Рассмотрим поверхность в 3D: z = as.matrix(r.linear) p = plot_ly(x = x, y = y, z = z, type = &quot;surface&quot;, colors = rain.colors3d) layout(p, scene = list(aspectratio = list(x = 1, y = 1, z = 0.3) )) Линейная интерполяция на треугольниках, как можно видеть, выглядит достаточно угловато, хотя и существенно более правдоподобна, нежели ступенчатая поверхность, полученная методом ближайшего соседа. Более гладкий результат можно получить, используя не линейный, а бикубический метод интерполяции на треугольниках. Для этого следует указать параметр linear = FALSE. Помимо этого, параметр extrap = TRUE говорит о том, что можно производить экстраполяцию за пределами выпуклой оболочки точек (такая возможность недоступна в линейном случае) # Интерполируем z.spline = interpp(x = pts, z = &quot;rain_24&quot;, xo = pts.grid.df, linear = FALSE, extrap = TRUE) # Переносим результат на сетку пикселей: px.spline = SpatialPixelsDataFrame(pts.grid.df, data = as.data.frame(z.spline$rain_24)) # Создаем объект типа raster: r.spline = raster(px.spline) # Визуализируем результат: plot(r.spline, breaks = rain.levels, col=rain.colors(rain.ncolors)) contour(r.spline, levels = rain.levels, add = TRUE) plot(edges, pch = 19, lwd = 0.5, lty = 3, cex = 0.5, add = TRUE) plot(pts, pch = 20, cex = 0.5, add = TRUE) Полученные изолинии отличаются более плавным и естественным рисунком. Тем не менее, использование триангуляции все еще заметно по фестончатым изгибам изолиний на ребрах. Смотрим наглядное представление поверхности в 3D: z = as.matrix(r.spline) p = plot_ly(x = x, y = y, z = z, type = &quot;surface&quot;, colors = rain.colors3d) layout(p, scene = list(aspectratio = list(x = 1, y = 1, z = 0.3) )) Можно видеть, что в данном случае получена уже гладкая поверхность, плотно натянутая на ребра триангуляции. 13.3.3 Метод обратно взвешенных расстояний (IDW) В данном методе значение показателя в произвольной точке получается как средневзвешенная сумма значений в исходных точках. Веса определяются обратно пропорционально расстоянию: чем дальше исходная точка удалена, тем меньший вес она будет иметь в оценке. Метод реализуется в R с помощью функции idw() из пакета gstat. Основным параметром метода является степень idp =, которая указывает, насколько быстро в зависимости от расстояния будет убывать вес исходной точки. По умолчанию idp = 2. При больших значениях степени (3, 4, 5, …) поверхность становится более платообразной, при меньших — островершинной. Функция idw() принимает 4 параметра: Формула, указывающая название зависимой переменной и независимых переменных Исходные точки Результирующие точки Степень весовой функции idp Формулы полезны в тех случаях, когда известно (или делается предположение), что исследуемый показатель функционально связан с другой величиной. В этом случае запись Z ~ x означает, что сначала будет построена линейная регрессия \\(Z(x)\\) и на основе нее получена грубая оценка показателя в каждой результирующей точке. Интерполяции же будут подвергаться случайные остатки между исходными величинами в точках и теми, что получены по регрессии. Эти остатки добавляются в результирующих точках к оценке, полученной по регрессии. С этой техникой мы познакомимся подробнее в следующем модуле при рассмотрении универсального кригинга. А пока что мы воспользуемся стандартной записью вида Z ~ 1, которая означает, что интерполироваться будет непосредственно исходная величина. В качестве Z надо указать название столбца, содержащего значения показателя. Этот столбец должен находиться в слое с исходными точками, который передается в параметр locations =. Сетка новых точек передается в параметр newdata. Рассмотрим, как меняется вид поверхности при разных значениях idp. Оператор ‘@’ позволяет извлекать слоты из классов S4. К таким классам относятся объекты типа Spatial*, которые мы активно используем в настоящей лекции. Атрибуты в таких объектах хранятся в слоте @data, а координаты — в слоте @coords # МЕТОД ОБРАТНО ВЗЕШЕННЫХ РАССТОЯНИЙ (IDW --- INVERSE DISTANCE WEIGHTED) # Интерполируем количество осадков: z1 = idw(rain_24 ~ 1, locations = pts, newdata = pts.grid, idp = 2.0) z2 = idw(rain_24 ~ 1, locations = pts, newdata = pts.grid, idp = 3.0) z3 = idw(rain_24 ~ 1, locations = pts, newdata = pts.grid, idp = 4.0) z4 = idw(rain_24 ~ 1, locations = pts, newdata = pts.grid, idp = 5.0) # Переносим результат на сетку пикселей. px1 = SpatialPixelsDataFrame(z1, data = z1@data) px2 = SpatialPixelsDataFrame(z2, data = z2@data) px3 = SpatialPixelsDataFrame(z3, data = z3@data) px4 = SpatialPixelsDataFrame(z4, data = z4@data) # Создаем объект типа raster для визуализации r1 = raster(px1, values = px1$var1.pred) r2 = raster(px2, values = px2$var1.pred) r3 = raster(px3, values = px3$var1.pred) r4 = raster(px4, values = px4$var1.pred) # Смотрим как выглядит результат plot(r1, breaks = rain.levels, col=rain.colors(rain.ncolors)) contour(r1, levels = rain.levels, add = TRUE) plot(pts, pch = 20, cex = 0.5, add = TRUE) plot(r2, breaks = rain.levels, col=rain.colors(rain.ncolors)) contour(r2, levels = rain.levels, add = TRUE) plot(pts, pch = 20, cex = 0.5, add = TRUE) plot(r3, breaks = rain.levels, col=rain.colors(rain.ncolors)) contour(r3, levels = rain.levels, add = TRUE) plot(pts, pch = 20, cex = 0.5, add = TRUE) plot(r4, breaks = rain.levels, col=rain.colors(rain.ncolors)) contour(r4, levels = rain.levels, add = TRUE) plot(pts, pch = 20, cex = 0.5, add = TRUE) # Удобно также набор растровых данных визуализировать средствами lattice, превратив их в растровый стек: r = stack(r1, r2, r3, r4) spplot(r, at = rain.levels, col.regions = rain.colors(rain.ncolors), sp.layout = list(&quot;sp.points&quot;, pts, pch=20, cex=0.5, col=&#39;black&#39;) ) Видно, что метод ОВР формирует вокруг каждой исходной точки замкнутые изолинии, оконтуривающие вершины и впадины на поверхности. Этот эффект является основным недостатком метода и носит название эффекта “бычьих глаз”. Он вызван тем, что производная функции ОВР в каждой точке равняется нулю. При увеличении степени весовой функции происходит расширение зоны влияния каждой точки, поверхности вершин и впадин приобретают платообразный характер. Наглядное представление о характере поверхности, получаемой методом ОВР, дает трехмерная визуализация: z = as.matrix(r3) p = plot_ly(x = x, y = y, z = z, type = &quot;surface&quot;, colors = rain.colors3d) layout(p, scene = list(aspectratio = list(x = 1, y = 1, z = 0.3) )) Любопытным фактом является то, что при стремлении параметра idp к плюс-бесконечности получаемая поверхность становится все более похожей не результат интерполяции методом ближайшего соседа. А именно этот метод, как мы помним, дает ступенчатую платообразную поверхность. Это легко проверить на практике, задав достаточно большой параметр idp, например \\(30\\): z30 = idw(rain_24 ~ 1, locations = pts, newdata = pts.grid, idp = 30.0) ## [inverse distance weighted interpolation] px30 = SpatialPixelsDataFrame(z30, data = z30@data) r30 = raster(px30, values = px30$var1.pred) plot(r30, breaks = rain.levels, col=rain.colors(rain.ncolors)) contour(r30, levels = rain.levels, add = TRUE) plot(pts, pch = 20, cex = 0.5, add = TRUE) # Добавим границы ячеек диаграммы Вороного: plot(voronoi.sp, border = &quot;red&quot;, add = TRUE) # Рассмотрим поверхность в 3D: z = as.matrix(r30) p = plot_ly(x = x, y = y, z = z, type = &quot;surface&quot;, colors = rain.colors3d) layout(p, scene = list(aspectratio = list(x = 1, y = 1, z = 0.3) )) 13.3.4 Метод радиальных базисных функций (РБФ) В методе РБФ задается радиальная функция — некоторая монотонно возрастающая функция, в качестве аргумента которой выступает расстояние между точками. Для интерполируемой точки вычисляются расстояния от нее до каждой из исходных точек. На основе этих расстояний получают значения радиальной функции. Результат интерполяции получается как сумма значений радиальной функции с коэффициентами. Коэффициенты определяются исходя из условия прохождения поверхности через исходные точки путем решения системы линейных уравнений. Метод РБФ является одним из самых мощных и гибких широким возможностям выбора радиальной функции. Недостатком же его является то, что поверхность может выходить за пределы исходного диапазона значений. Существуют радиальные функции, обладающие особыми свойствами. В частности, в качестве радиальной функции можно использовать сплайны - функции, выполняющие некоторое дополнительное условие (условия) при одновременном выполнении условий интерполяции (прохождение через исходные точки). Одним из наиболее популярных сплайнов является сплайн минимальной кривизны (thin plate spline — TPS), который дает поверхность, обладающую максимально низкой кривизной между исходными точками. Это, кстати, не означает что поверхность плотно натянута на исходные точки (как в триангуляции). Скорее, в ней будут отсутствовать резкие скачки и понижения, что мы видели на поверхности, построенной методом ОВР. Задается такой сплайн с помощью радиальной функции \\(R(d) = d^2 * log(d^2)\\) На языке R сплайны минимальной кривизны реализованы в пакете fields. Сначала необходимо инициализировать процесс интерполяции с помощью функции Tps(), передав ей координаты исходных точек и значения показателя в них. Дополнительно при необходимости указывается параметр scale.type = 'unscaled', который означает, что не следует масштабировать координаты исходных точек так чтобы область определения стала квадратной: # РАДИАЛЬНЫЕ БАЗИСНЫЕ ФУНКЦИИ (RADIAL BASIS FUNCTIONS) pred = Tps(coords, pts$rain_24, scale.type = &#39;unscaled&#39;) # После этого можно интерполировать значения с помощью функции predict(): z.tps = predict(pred, coords.grid) # Результирующий объект является вектором, поэтому его нужно привести к типу data.frame перед перенесением на сетку пикселей: px.tps = SpatialPixelsDataFrame(pts.grid, data = data.frame(z.tps)) # Также добавим название показателя names(px.tps) = c(&quot;rain_24&quot;) # Преобразуем в растр r.tps = raster(px.tps, values = px.tps$rain_24) # Придется расширить шкалу, так как сплайновая поверхность выходит за пределы исходных значений: tps.breaks = seq(-10,90,by=10) tps.ncolors = length(tps.breaks) - 1 # Виузализируем результат: plot(r.tps, breaks = tps.breaks, col=rain.colors(tps.ncolors)) contour(r.tps, levels = seq(-10,90,by=10), add = TRUE) plot(pts, pch = 20, cex = 0.5, add = TRUE) Можно видеть, что по плавному характеру изолиний и отсутствию артефактов в виде “бычьих глаз” интерполяция методом РБФ существенно ближе к ожидаемому распределению показателя, а также удачно сглаживает неравномерность распределения исходных данных. Смотрим, как выглядит поверхность в 3D: z = as.matrix(r.spline) p = plot_ly(x = x, y = y, z = z, type = &quot;surface&quot;, colors = rain.colors3d) layout(p, scene = list(aspectratio = list(x = 1, y = 1, z = 0.3) )) 13.3.5 Метод иерархических базисных сплайнов (B-сплайнов) Если говорить просто — в методе иерархических базисных сплайнов (ИБС) поверхность формируется как совокупность профилей по осям \\(X\\) и \\(Y\\). Участок профиля, соединяющий 4 последовательных узла, представляет из себя кубический полином — базисный сплайн. Сплайны стыкуются гладко, то есть в любом узле поверхности существуют и первая и вторая производная. Каждый участок поверхности размером \\(4 \\times 4\\) ячейки представляет собой уже бикубическую поверхность. Высоты в ячейках получаются исходя из условия прохождения поверхности через исходные точки, а также минимизации суммы квадратов высот (поскольку существует бесконечное число различных поверхностей на сетке \\(4 \\times 4\\), которые проходят через заданную точку). Если хотя бы в один участок \\(4 \\times 4\\) попадает более одной точки, поверхность будет аппроксимирующей, так как каждая точка дает свой оптимум, минимизирующий сумму квадратов значений в узлах. При иерархическом подходе поверхность строится в несколько итераций с последовательным переходом на более детальное разрешение сетки. При этом на каждой последующей итерации аппроксимации подвергаются остатки между исходными значениями в точках и теми, которые получаются по бикубической поверхности. Если результирующее разрешение таково, что в окрестности \\(4 \\times 4\\) исходной точки нет других исходных точек, метод будет интерполирующим. Достоинством метода иерархических базисных сплайнов является то, что поверхность получается сразу для всех узлов, нет необходимости решать систему линейных уравнений для каждого узла сетки. Метод явяется локальным: исходные точки, удаленные от текущего узла ЦМР далее чем на 2 узла, не оказывают на нее влияние. В результате этого метод ИБС получается чрезвычайно быстрым и эффективным в вычислительном плане. Помимо этого, мультимасштабность метода позволяет эффективно использовать его при интерполяции данных, распределенных кластерным образом — например, данных профилирования. Метод иерархических базисных сплайнов доступен в пакете MBA. Чтобы использовать его, сначала необходимо подготовить исходные данные. Они должны представлять из себя матрицу из трех столбцов: X, Y, Показатель: # ИЕРАРХИЧЕСКИЕ БАЗИСНЫЕ СПЛАЙНЫ (HIERARCHICAL BASIS SPLINES) mba.data = cbind(pts$x, pts$y, pts$rain_24) Метод ИБС, так же как и РБФ, предполагает по умолчанию, что область определения должна быть квадратной. Если разброс координат по осям X и Y не одинаков, поверхность будет искусственно растянута или сжата. Чтобы этого не произошло, необходимо сначала рассчитать пропорции ЦМР. Ранее мы уже создали объект envelope, который хранит крайние координаты по X и Y: ratio = (envelope[2] - envelope[1])/(envelope[4] - envelope[3]) # После этих приготовлений можно осуществить интерполяцию pred = mba.points(mba.data, coords.grid, n = 1, m = ratio) # Далее извлечем полученные значения pred.z = data.frame(pred$xyz.est[,&quot;z&quot;]) # Перенесем результат на сетку пикселей: px.bspline = SpatialPixelsDataFrame(pts.grid, data = pred.z) # Вернем исходное название показателю: names(px.bspline) = c(&quot;rain_24&quot;) # Построим растр для визуализации результатов r.bspline = raster(px.bspline, values = px.bspline$rain_24) # Смотрим, что получилось: plot(r.bspline, breaks = seq(-10,90,by=10), col=rain.colors(10)) contour(r.bspline, levels = seq(-10,90,by=10), add = TRUE) plot(pts, pch = 20, cex = 0.5, add = TRUE) Можно видеть, что метод иерерхических базисных сплайнов обеспечивает некий оптимум представления поверхности. С одной стороны, он, как и метод РБФ, дает гладкую и достаточно генерализованную поверхность. С другой стороны, на участках с плотным размещением исходных данных метод ИБС раскрывает локальные нюансы поверхности, чего лишен метод РБФ, и что более типично для метода ОВР. Наконец, рассмотрим результат в трехмерном виде: z = as.matrix(r.bspline) p = plot_ly(x = x, y = y, z = z, type = &quot;surface&quot;, colors = rain.colors3d) layout(p, scene = list(aspectratio = list(x = 1, y = 1, z = 0.3) )) Итак, в настоящем модуле мы рассмотрели несколько распространенных методов детерминистической интерполяции поверхностей по данным в нерегулярно расположенных точках. В следующем модуле мы рассмотрим методы аппроксимации, которые могут быть полезны для работы с данными, обладающими высоким уровнем шума, а также для оценки пространственных трендов изменения показателя. 13.4 Аппроксимационные методы Аппроксимационные методы используются для выявления пространственных трендов - глобальных или локальных. В зависимости от этого они и классифицируются. Полученная поверхность в каждом узле показывает средневзвешенное (типичное) значение в заданной окрестности. Таким образом, задача аппроксимации — убрать детали и выявить основные закономерности протранственного распределения. При проведении аппроксимации условие прохождения поверхности через исходные точки не применяется. В случае глобального тренда окрестность аппроксимации включает весь набор исходных точек. Локальные аппроксимации учитывают только ближайшие точки, причем общепринятым является подход, в котором окрестность определяется не расстоянием, а заданным количеством ближайших точек (или их долей от общего числа). В этом случае в области сгущения исходных данных локальная аппроксимация будет строиться по меньшей окрестности, что позволит отразить нюансы изменения показателя. И в локальных и в глобальных аппроксимациях используются обычно полиномиальные поверхности степени от \\(0\\) до \\(3\\). Коэффициенты полиномов подбираются методом наименьших квадратов для минимизации отклонения поверхности от исходных точек в заданной окрестности. В случае если степень равна \\(0\\), поверхность представляет из себя константу, или горизонтальную плоскость. Для степени \\(1\\) возможно построение наклонной плоскости. Степени \\(2\\) и \\(3\\) соответствуют квадратичным и кубическим поверхностям. Степени большего порядка для построения трендов, как правило, не используются. 13.4.1 Глобальный тренд Построение поверхности глобального тренда можно осуществить с помощью геостатистического пакета gstat, с которым мы познакомимся в следующем модуле. Для этого необходимо сначала создать объект gstat, используя формулу (см. метод ОВР), исходные точки и степень аппроксимации. После этого аппроксимация осуществляется с попощью функции predict(). Дальнейшие действия совпадают со стандартным алгоритмом, который мы использовали ранее. # ГЛОБАЛЬНАЯ АППРОКСИМАЦИЯ (GLOBAL APPROXIMATION) # 1-я степень ------------------------------------------------------------- # Создаем объект gstat. Столбец, указываемый в параметре formula, должен содержаться # в наборе данных, который передается в параметр data: trend = gstat(formula = rain_24 ~ 1, data = pts, degree = 1) # Осуществляем аппроксимацию на заданную сетку точек: z = predict(trend, newdata = pts.grid) # Переносим результат на сетку пикселей: px = SpatialPixelsDataFrame(z, data = z@data) # Преобразуем в растр: r.trend1 = raster(px, values = px$var1.pred) # Визуализируем результат: plot(r.trend1, breaks = tps.breaks, col=rain.colors(tps.ncolors)) contour(r.trend1, levels = tps.breaks, add = TRUE) plot(pts, pch = 20, cex = 0.5, add = TRUE) # Теперь повторим все то же самое для степеней 2 и 3: # 2-я степень ------------------------------------------------------------- trend = gstat(formula = rain_24 ~ 1, data = pts, degree = 2) z = predict(trend, newdata = pts.grid) px = SpatialPixelsDataFrame(z, data = z@data) r.trend2 = raster(px, values = px$var1.pred) # Визуализируем: plot(r.trend2, breaks = tps.breaks, col=rain.colors(tps.ncolors)) contour(r.trend2, levels = tps.breaks, add = TRUE) plot(pts, pch = 20, cex = 0.5, add = TRUE) # 3-я степень ------------------------------------------------------------- trend = gstat(formula = rain_24 ~ 1, data = pts, degree = 3) z = predict(trend, newdata = pts.grid) px = SpatialPixelsDataFrame(z, data = z@data) r.trend3 = raster(px, values = px$var1.pred) # Визуализируем: plot(r.trend3, breaks = tps.breaks, col=rain.colors(tps.ncolors)) contour(r.trend3, levels = tps.breaks, add = TRUE) plot(pts, pch = 20, cex = 0.5, add = TRUE) Наконец, рассмотрим полученные поверхности в трехмерном виде: z = as.matrix(r.trend1) p = plot_ly(x = x, y = y, z = z, type = &quot;surface&quot;, colors = rain.colors3d) layout(p, scene = list(aspectratio = list(x = 1, y = 1, z = 0.3) )) z = as.matrix(r.trend2) p = plot_ly(x = x, y = y, z = z, type = &quot;surface&quot;, colors = rain.colors3d) layout(p, scene = list(aspectratio = list(x = 1, y = 1, z = 0.3) )) z = as.matrix(r.trend3) p = plot_ly(x = x, y = y, z = z, type = &quot;surface&quot;, colors = rain.colors3d) layout(p, scene = list(aspectratio = list(x = 1, y = 1, z = 0.3) )) 13.4.2 Локальный тренд Метод построения локальной регрессии изначально был разработан для построения кривых регрессии в случае когда зависимость между переменными ведет себя сложным образом и не может быть описана в терминах традиционной линейной и нелинейной регрессии — глобальных методов. В этом случае область значений независимой переменной \\(X\\) можно покрыть конечным числом отрезков, для каждого из которых далее находят регрессию традиционным методом — как правило, линейную или квадратичную. В классической постановке метод реализуется следующим образом. Пусть дано \\(N\\) точек с координатами \\(X\\) (независимая переменная) и \\(Y\\) (зависимая). Задается число \\(\\alpha\\), которое обозначет долю от общего количества точек, которую необходимо выбрать в окрестности каждой из N точек для построения регрессии. То есть для каждой точки \\(p(x)\\) из исходных данных выбираются \\(\\alpha N\\) ближайших к ней. Близость опеределяется как разность координат \\(X\\). Выбранные точки определяют окрестность \\(p(x)\\), в которой будет строиться локальная регрессия. Далее происходит определение параметров линейной или квадратической регрессии взвешенным методом наименьших квадратов. При использовании этого метода более близкие к \\(p(x)\\) точки оказывают большее влияние на коэффициенты регрессии. Построенная регрессия дает в точке \\(x\\) сглаженную оценку \\(p&#39;(x)\\) вместо исходной \\(p(x)\\). Процедура повторяется для каждой из \\(N\\) точек. Результирующая кривая соединяет точки \\(p&#39;(x)\\). При этом чем больше значение \\(\\alpha\\), тем более сглаженный вид будет иметь кривая регрессии. Метод получил название LOWESS (Locally weighted scatterplot smoothing). В дальнейшем эта аббревиатура была редуцирована до LOESS. В методе LOESS используются степени регрессии 0, 1, 2. Кубические и более высокие степени полиномов не применяются. При степени равной 0 метод носит название сглаживающего среднего. Вместо координат исходных точек для построения регрессии можно использовать и произвольные координаты \\(X\\). В этом случае кривая будет соединять точки, полученные локальной регрессионной оценкой в заданных координатах \\(X\\). Именно этот принцип используется в двумерном (и многомерном) случае. Пусть даны измерения показателя в \\(N\\) исходных точках и задано число \\(\\alpha\\) — сглаживающий параметр. Тогда аппроксимация показателя в каждом узле интерполяции получается путем построения поверхности тренда (см. выше) по \\(\\alpha N\\) ближайшим исходным точкам. Как и в одномерном случае, близкие точки будут оказывать более сильное влияние на коэффициенты регрессии, чем удаленные. Метод LOESS предоставляет широкие возможности настройки благодаря вариативности параметра сглаживания и степени регрессионного полинома. Рассмотрим применение метода LOESS на примере данных по осадкам. Поскольку это один из базовых методов регрессионного анализа, он входит в состав базового пакета stats. Для его использования нужно вначале инициализировать параметры локальной регрессии с помощью функции loess(). Параметры задаются в следующей форме: Формула, содержащая названия зависимой и независимых (координаты) переменной Набор данных, в котором содержатся значения переменных Степень полиннома (degree) Сглаживающий параметр (span) Необходимость нормализации координат (приведения к квадратной области определения) # ЛОКАЛЬНАЯ АППРОКСИМАЦИЯ (LOWESS) # 0-я степень ------------------------------------------------------------- local.trend = loess(rain_24 ~ x + y, pts, degree = 0, span = 0.07, normalize = FALSE) # Производим оценку в заданных точках z.local.trend = predict(local.trend, coords.grid) # Переводим результат на сетку пикселей px.local.trend = SpatialPixelsDataFrame(pts.grid, data = data.frame(z.local.trend)) # Задаем название показателя names(px.spline) = c(&quot;rain_24&quot;) # Преобразуем в растр для визуализации r.local.trend0 = raster(px.local.trend, values = px.spline$rain_24) # Визуализируем plot(r.local.trend0, breaks = rain.levels, col=rain.colors(rain.ncolors)) contour(r.local.trend0, levels = rain.levels, add = TRUE) plot(pts, pch = 20, cex = 0.5, add = TRUE) # Повторим аналогичные действия для степеней 1 и 2 # 1-я степень ------------------------------------------------------------- local.trend = loess(rain_24 ~ x + y, pts, degree = 1, span = 0.07, normalize = FALSE) z.local.trend = predict(local.trend, coords.grid) px.local.trend = SpatialPixelsDataFrame(pts.grid, data = data.frame(z.local.trend)) names(px.spline) = c(&quot;rain_24&quot;) r.local.trend1 = raster(px.local.trend, values = px.spline$rain_24) plot(r.local.trend1, breaks = rain.levels, col=rain.colors(rain.ncolors)) contour(r.local.trend1, levels = rain.levels, add = TRUE) plot(pts, pch = 20, cex = 0.5, add = TRUE) # 2-я степень ------------------------------------------------------------- local.trend = loess(rain_24 ~ x + y, pts, degree = 2, span = 0.07, normalize = FALSE) z.local.trend = predict(local.trend, coords.grid) px.local.trend = SpatialPixelsDataFrame(pts.grid, data = data.frame(z.local.trend)) names(px.spline) = c(&quot;rain_24&quot;) r.local.trend2 = raster(px.local.trend, values = px.spline$rain_24) plot(r.local.trend2, breaks = rain.levels, col=rain.colors(rain.ncolors)) contour(r.local.trend2, levels = rain.levels, add = TRUE) plot(pts, pch = 20, cex = 0.5, add = TRUE) Рассмотрим результаты в 3D: z = as.matrix(r.local.trend0) p = plot_ly(x = x, y = y, z = z, type = &quot;surface&quot;, colors = rain.colors3d) layout(p, scene = list(aspectratio = list(x = 1, y = 1, z = 0.3) )) z = as.matrix(r.local.trend1) p = plot_ly(x = x, y = y, z = z, type = &quot;surface&quot;, colors = rain.colors3d) layout(p, scene = list(aspectratio = list(x = 1, y = 1, z = 0.3) )) z = as.matrix(r.local.trend2) p = plot_ly(x = x, y = y, z = z, type = &quot;surface&quot;, colors = rain.colors3d) layout(p, scene = list(aspectratio = list(x = 1, y = 1, z = 0.3) )) Можно заметить, что с увеличением степени полинома поверхность все более точно аппроксимирует исходные данные — там, где достаточно большое количество исходных точек. В то же время, появляются нежелательные экстраполяции в приграничных областях, слабо обеспеченных измерениями, что можно наблюдать на последнем рисунке (степень = 2) в северо-западной части. Поэтому нельзя однозначно сказать, что более высокая степень обеспечивает лучшие результаты аппроксимации. Точность аппроксимации правильно регулировать не степенью полинома, а увеличением и уменьшением сглаживающего параметра альфа. Рассмотрим это на примере линейной аппроксимации при \\(\\alpha = 0.05, 0.1, 0.2\\): # degree = 1, span = 0.05 ------------------------------------------------- local.trend = loess(rain_24 ~ x + y, pts, degree = 1, span = 0.05, normalize = FALSE) z.local.trend = predict(local.trend, coords.grid) px.local.trend = SpatialPixelsDataFrame(pts.grid, data = data.frame(z.local.trend)) names(px.spline) = c(&quot;rain_24&quot;) r.local.trend.a05 = raster(px.local.trend, values = px.spline$rain_24) plot(r.local.trend.a05, breaks = rain.levels, col=rain.colors(rain.ncolors)) contour(r.local.trend.a05, levels = rain.levels, add = TRUE) plot(pts, pch = 20, cex = 0.5, add = TRUE) # degree = 1, span = 0.1 ------------------------------------------------- local.trend = loess(rain_24 ~ x + y, pts, degree = 1, span = 0.1, normalize = FALSE) z.local.trend = predict(local.trend, coords.grid) px.local.trend = SpatialPixelsDataFrame(pts.grid, data = data.frame(z.local.trend)) names(px.spline) = c(&quot;rain_24&quot;) r.local.trend.a10 = raster(px.local.trend, values = px.spline$rain_24) plot(r.local.trend.a10, breaks = rain.levels, col=rain.colors(rain.ncolors)) contour(r.local.trend.a10, levels = rain.levels, add = TRUE) plot(pts, pch = 20, cex = 0.5, add = TRUE) # degree = 1, span = 0.2 ------------------------------------------------- local.trend = loess(rain_24 ~ x + y, pts, degree = 1, span = 0.2, normalize = FALSE) z.local.trend = predict(local.trend, coords.grid) px.local.trend = SpatialPixelsDataFrame(pts.grid, data = data.frame(z.local.trend)) names(px.spline) = c(&quot;rain_24&quot;) r.local.trend.a20 = raster(px.local.trend, values = px.spline$rain_24) plot(r.local.trend.a20, breaks = rain.levels, col=rain.colors(rain.ncolors)) contour(r.local.trend.a20, levels = rain.levels, add = TRUE) plot(pts, pch = 20, cex = 0.5, add = TRUE) Сравниваем результаты в трехмерном виде: z = as.matrix(r.local.trend.a05) p = plot_ly(x = x, y = y, z = z, type = &quot;surface&quot;, colors = rain.colors3d) layout(p, scene = list(aspectratio = list(x = 1, y = 1, z = 0.3) )) z = as.matrix(r.local.trend.a10) p = plot_ly(x = x, y = y, z = z, type = &quot;surface&quot;, colors = rain.colors3d) layout(p, scene = list(aspectratio = list(x = 1, y = 1, z = 0.3) )) z = as.matrix(r.local.trend.a20) p = plot_ly(x = x, y = y, z = z, type = &quot;surface&quot;, colors = rain.colors3d) layout(p, scene = list(aspectratio = list(x = 1, y = 1, z = 0.3) )) 13.5 Контрольные вопросы и упражнения 13.5.1 Вопросы 13.5.2 Упражнения Самсонов Т.Е. Визуализация и анализ географических данных на языке R. М.: Географический факультет МГУ, 2017. DOI: 10.5281/zenodo.901911 "]
]
