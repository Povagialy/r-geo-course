[
["raster-analysis.html", "Глава 12 Пространственный анализ 2. Растровые методы Предварительные условия 12.1 Введение 12.2 Растровая алгебра 12.3 Извлечение данных 12.4 Контрольные вопросы и упражнения", " Глава 12 Пространственный анализ 2. Растровые методы Предварительные условия Для выполнения кода данной лекции вам понадобятся следующие пакеты: library(sf) library(sp) library(tmap) library(raster) library(mapview) library(mapedit) library(lattice) library(classInt) library(geosphere) library(tidyverse) 12.1 Введение Растровая модель данных представляет собой мощный инструмент абстракции пространственных распределений и выполнения пространственного анализа. На первый взгляд, растр обладает целым рядом ограничений по сравнению с векторной моделью: не позволяет оперировать отдельными объектами, их границами и так далее. Растровые карты и снимки мы часто оцифровываем, выделяя объекты, чтобы на основе них можно было что-то посчитать. Самые первые ГИС были исключительно растровыми, что сейчас воспринимается как архаизм. Однако за ширмой ограниченности растровой модели кроются огромные аналитические возможности. Растровая модель обладает внутренней топологией: ее ячейки соприкасаются друг с другом, что позволяет моделировать непрерывные в пространстве и динамические явления (при которых происходит перемещение вещества, энергии или информации в пространстве). Поскольку ячейки растра имеют одинаковый размер, к ним можно применять однотипные операции, которые будут давать предсказуемый результат вне зависимости от конкретной локации в пределах растра. Это также позволяет сделать обработку растра очень быстро. 12.2 Растровая алгебра Существует классификация операций растрового анализа, введенная американским профессором Даной Томлином, которая объединяет их под общим названием “алгебра карт” или “растровая алгебра”1. Предполагая, что обработке подвергается каждая ячейка растра, данная классификация разделяет все операции по охвату относительно текущей ячейки Локальные — анализируется одна ячейка растра или совпадающие в пространстве ячейки нескольких растров Фокальные — анализируются все ячейки в окрестности. Окрестность может быть как фиксированной, так и расширенной (expanded), когда ее размер управляется внешними факторами, например множеством объектов, до которых требуется вычислить расстояние. Информация по соседним ячейкам может быть как из исходного растра, так и из внешнего. Фокальные методы алгебры карт также называются методами анализа соседства. Зональные — анализируются все ячейки в пределах зон, определяемых извне (например, вторым растровым слоем). Глобальные — анализируются все ячейки растра. 12.2.1 Локальные операции Локальные операции связаны с алгебраическими преобразованиями значений в ячейках. Например, цифровую модель высот в футах можно перевести в цифровую модель высот в метрах. Для этого нужно значение в каждой ячейке умножить на \\(0.3048\\). В локальных операциях могут участвовать несколько растров. Например, если у нас есть растровые поверхности плотности населения за разные года, мы можем вычесть одну поверхность из другой, чтобы получить поверхность изменений плотности, выяснить где она увеличилась, уменьшилась или осталось прежней. К локальным операциям относится также оверлей растров, при котором получается взвешенная сумма значений по нескольким растрам. И в том и в другом случае анализируются ячейки с нескольких растров, которые совпадают в пространстве. В качестве примера определим мощность покровного оледенения в Антарктике и Гренландии, путем вычитание двух моделей ETOPO1, одна из которых показывает рельеф коренных пород (bedrock), а вторая — видимый рельеф поверхности (ice surface): # ЛОКАЛЬНЫЕ ОПЕРАЦИИ # Вычисление толщины покровного оледенения # Чтение данных bed = raster(&#39;etopo1_bed.tif&#39;) ice = raster(&#39;etopo1_ice.tif&#39;) countries = st_read(&#39;countries.gpkg&#39;) ## Reading layer `admin_0_map_units&#39; from data source `/Users/tsamsonov/GitHub/r-geo-course/data/countries.gpkg&#39; using driver `GPKG&#39; ## Simple feature collection with 183 features and 72 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: -180 ymin: -90 xmax: 180 ymax: 83.64513 ## epsg (SRID): 4326 ## proj4string: +proj=longlat +datum=WGS84 +no_defs borders = countries %&gt;% st_geometry() # отображение данных classes = classIntervals(values(bed), 20) brks = classes$brks nclass = length(brks) - 1 plot(bed, breaks = brks, col = gray.colors(nclass), main = &#39;ETOPO Bedrock&#39;, legend = F) plot(ice, breaks = brks, col = gray.colors(nclass), main = &#39;ETOPO Ice surface&#39;, legend = F) # вычисление разности ice.depth = ice - bed plot(ice.depth, col = cm.colors(255), main = &#39;Мощность покровного оледенения&#39;) plot(borders, border = &#39;black&#39;, lwd = 0.5, add = TRUE) # сделаем пустыми все ячейки, в которых толщина льда равна нулю ice.depth[ice.depth == 0] = NA plot(ice.depth, col = cm.colors(255), main = &#39;Мощность покровного оледенения&#39;) plot(borders, border = &#39;black&#39;, lwd = 0.5, add = TRUE) 12.2.2 Фокальные операции В фокальных операциях участвует не только сама ячейка или совпадающие с ней ячейки других растров, но также ячейки, находящиеся в некоторой окрестности (опять же, в одном или нескольких растрах одновременно). Данный вид анализа подразделяется на две категории: фокальный анализ с фиксированной окрестностью и с раширенной окрестностью. 12.2.2.1 Фиксированная окрестность В общем случае фиксированна окрестность может иметь различную форму, однако наиболее часто используется квадратная окрестность размером \\(3\\times3\\): Виды растровых окрестностей. Темной точкой выделена анализируемая ячейка Фокальные операции с фиксированной окрестностью — привычное дело в обработке изображений. Они работают по принципу “плавающего окна”. Выбранная окрестность (квадратная, круглая и т.д.) представляется в виде матрицы коэффициентов — так называемого ядра свёртки (convolution kernel). Далее эта матрица перемещается, позиционируясь последовательно над каждой ячейкой растра, и значение в этой ячейке заменяется на взвешенную сумму значений ячеек в окрестности, умноженных на соответствующие коэффициенты ядра свертки. Например, если ядро состоит из единиц, то будет посчитана обычная сумма. С помощью фокального анализа можно выполнить сглаживание изображения, которое убирает из него мелкие детали (высокочастотные составляющие яркостного сигнала). В качестве такого изображения может быть цифровая модель рельефа или космический снимок. Чтобы выполнить сглаживание, коэффициенты должны быть такими, чтобы получаемая взвешенная сумма осредняла значения в соседних ячейках. Самый простой вариант — это рассчитать среднее арифметическое. В этом случае коэффиценты ядра свертки будут равны \\(1/k\\), где \\(k\\) — количество ячеек в окрестности. Для матрицы \\(3\\times3\\) они будут равны, соответственно \\(1/9\\): # ФОКАЛЬНЫЕ ОПЕРАЦИИ # Вырежем кусок из ЦМР dem = crop(ice, extent(-120, -75, 10, 40)) spplot(dem) # Среднее wgt = matrix(c(1, 1, 1, 1, 1, 1, 1, 1, 1) / 9, nrow = 3) # на самом деле проще написать так: # wgt = matrix(1/9, 3, 3), но полная форма записана для наглядности # выполним обработку ЦМР с помощью фокального фильтра filtered = focal(dem, w = wgt) spplot(stack(dem, filtered), names.attr=c(&#39;Исходный рельеф&#39;, &#39;Сглаживание средним&#39;)) Более мягким эффектом сглаживания, который к тому же не нарушает дифференцируемость поверхности, является гауссово сглаживание. Коэффициенты в матрице Гаусса убывают от центральной ячейки к краям матрицы по закону Гаусса-Лапласа, что позволяет придать центральной ячейке более высокий вес по сравнению с ячейками, располагающимися на краю анализируемой окрестности: # Гауссово (параметр 0.5 - это стандартное отклонение в единицах измерения растра) wgt = focalWeight(dem, 0.5, &quot;Gauss&quot;) filtered = focal(dem, wgt) spplot(stack(dem, filtered), names.attr=c(&#39;Исходный рельеф&#39;, &#39;Гауссово сглаживание&#39;)) Еще одна интересная область применения фильтрации — это обнаружение границ (change detection). Границы на изображении возникают в тех местах, где его яркость резко меняет свое значение (в одном или нескольких каналах). Например, на фотографии контур лица может быть распознан по перепаду яркости между его изображением и фоном (если он имеет существенно отличный цвет). Поскольку перепад яркости соответствует экстремальным значениям производной поверхности (отрицательным или положительным), его также можно определить путем фокального анализа, а затем отсечь ячейки растра, в которых значение этой производной по модулю превышает заданный порог (то есть, имеет необходимый контраст). Рассмотрим, как можно выделить уступы континентального склона океана путем применения фильтра Собеля для выделения границ: # Матрица Собеля: wgt = matrix(c(1, 2, 1, 0, 0, 0, -1,-2,-1) / 4, nrow=3) filtered = focal(dem, wgt) # Это поверхность производных: plot(filtered, col = gray.colors(128), main = &#39;Производная поверхности&#39;) # Отберем все ячейки, обладающие высокими значениями производных faults = (filtered &lt; -1500) | (filtered &gt; 1500) faults[faults == 0] = NA # Визуализируем результат plot(dem, col = rev(rainbow(20)), main = &#39;Уступы континентального склона&#39;, legend = FALSE) plot(faults, col = &#39;black&#39;, legend = FALSE, add = TRUE) Еще один распространненый случай использования фокальных операций — это морфометрический анализ поверхностей. Квадратная окрестность \\(3\\times3\\) вокруг каждой ячейки формирует локальную поверхность, производные которой дают представление об уклоне, экспозиции и прочих морфометрических параметрах. Их можно вычислить с помощью функции terrain() из пакета raster: # Морфометрия рельефа — фиксированное соседство dem = raster(&#39;dem_fergana.tif&#39;) spplot(dem) # углы наклона slope = terrain(dem, opt = &#39;slope&#39;, unit = &#39;degrees&#39;) spplot(slope, col.regions = heat.colors(20), names.attr=c(&#39;Углы наклона&#39;)) # экспозиция aspect = terrain(dem, opt = &#39;aspect&#39;, unit = &#39;degrees&#39;) spplot(aspect, col.regions = rainbow(20), names.attr=c(&#39;Экспозиции склона&#39;)) Вычисление производных поверхности позволяет не только исследовать рельеф, но также строить его изображения. Например, хорошо знакомую всем по картам аналитическую отмыку рельефа (hillshade). Яркость поверхности в этом способе изображения зависит от угла между направлением на источник освещения (откуда светит Солнце) и нормалью к поверхности. Нормаль можно вычислить как напрямую через производные поверхности, так и восстановить на основе значений угла наклона и экспозиции в точке, что и используется в пакете raster. Обратите внимание на то, что для того чтобы повысить наглядность (контрастность) изображения, мы умножаем высоты рельефа на 20. Это стандартная практика для мелкомасштабных карт: # отмывка slope2 = terrain(dem * 20, opt = &#39;slope&#39;) aspect2 = terrain(dem * 20, opt = &#39;aspect&#39;) # параметры angle и direction функции hillShade определяют азимут и высоту источника освещения: hill = hillShade(slope2, aspect2, angle = 45, direction = 315) plot(hill, col = gray.colors(128), main = &#39;Отмывка рельефа&#39;) 12.2.2.2 Расширенная окрестность Расширенность окрестности означает, что она определяется не фиксированным шаблоном, а условием, которое должно выполниться для того, чтобы анализ в ячейке считался выполненным. Типичный пример анализа на основе расширенной окрестности — это операции, основанные на вычислении расстояний на растровой матрице, такие как аллокация, опреление кратчайшего пути на поверхности сопростивления, и собственно, само вычисление расстояние. В мелкомасштабных тематических атласах часто можно встретить карты доступности той или иной географической локации, которые в форме изолиний показывают время движения до ближайшего населенного пункта. Эти изолинии можно построить по растровой поверхности, в каждой ячейке которой зафиксировано расстояние до ближайшего населенного пункта. Рассмотрим построение аналогичной поверхности на примере доступности станций метро (по расстоянию). Для этого нам понадобится представить растр в виде матрицы точек, рассчитать для этих точек расстояния до ближайших станций метро и присвоить эти значения выходному растру: # Определение Евклидовых расстояний — расширенное соседство # Чтение данных roads = st_read(&quot;roads.gpkg&quot;) # Дороги ## Reading layer `roads&#39; from data source `/Users/tsamsonov/GitHub/r-geo-course/data/roads.gpkg&#39; using driver `GPKG&#39; ## Simple feature collection with 2213 features and 12 fields ## geometry type: MULTILINESTRING ## dimension: XY ## bbox: xmin: 410946.9 ymin: 6176676 xmax: 415890.8 ymax: 6181910 ## epsg (SRID): 32637 ## proj4string: +proj=utm +zone=37 +datum=WGS84 +units=m +no_defs poi = st_read(&quot;poi_point.gpkg&quot;) # Точки интереса ## Reading layer `poi_point&#39; from data source `/Users/tsamsonov/GitHub/r-geo-course/data/poi_point.gpkg&#39; using driver `GPKG&#39; ## Simple feature collection with 6623 features and 9 fields ## geometry type: POINT ## dimension: XY ## bbox: xmin: 410947.3 ymin: 6176678 xmax: 415889.9 ymax: 6181909 ## epsg (SRID): 32637 ## proj4string: +proj=utm +zone=37 +datum=WGS84 +units=m +no_defs rayons = st_read(&quot;boundary_polygon.gpkg&quot;) # Границы районов ## Reading layer `boundary_polygon&#39; from data source `/Users/tsamsonov/GitHub/r-geo-course/data/boundary_polygon.gpkg&#39; using driver `GPKG&#39; ## Simple feature collection with 11 features and 5 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: 410946.9 ymin: 6176676 xmax: 415890.8 ymax: 6181910 ## epsg (SRID): 32637 ## proj4string: +proj=utm +zone=37 +datum=WGS84 +units=m +no_defs stations = st_read(&quot;metro_stations.gpkg&quot;) # Станции метро ## Reading layer `metro_stations&#39; from data source `/Users/tsamsonov/GitHub/r-geo-course/data/metro_stations.gpkg&#39; using driver `GPKG&#39; ## Simple feature collection with 45 features and 3 fields ## geometry type: POINT ## dimension: XY ## bbox: xmin: 411007.5 ymin: 6176747 xmax: 415852.2 ymax: 6181892 ## epsg (SRID): 32637 ## proj4string: +proj=utm +zone=37 +datum=WGS84 +units=m +no_defs water = st_read(&quot;water_polygon.gpkg&quot;) # Водные объекты ## Reading layer `water_polygon&#39; from data source `/Users/tsamsonov/GitHub/r-geo-course/data/water_polygon.gpkg&#39; using driver `GPKG&#39; ## Simple feature collection with 8 features and 7 fields ## geometry type: POLYGON ## dimension: XY ## bbox: xmin: 411595.6 ymin: 6176676 xmax: 415890.8 ymax: 6180765 ## epsg (SRID): 32637 ## proj4string: +proj=utm +zone=37 +datum=WGS84 +units=m +no_defs # Создаем пустой растр с охватом, равным охвату станции r = raster(extent(stations), nrows = 200, ncols = 200) # Конвертируем ячейки в точки cells = r %&gt;% as(&quot;SpatialPoints&quot;) %&gt;% st_as_sf() %&gt;% st_set_crs(st_crs(stations)) # Вычисляем расстояния d = st_distance(stations, cells) # Находим минимальное расстояние для каждой точки и заполняем # полученными значениями текущее содержимое растра r[] = apply(d, 2, min) # Визуализируем результат plot(r, col = rev(heat.colors(100)), main = &#39;Расстояние до ближайшей станции метро&#39;) contour(r, lwd = 0.5, add= TRUE) plot(water, col = &#39;blue&#39;, border = &#39;darkblue&#39;, add = TRUE) plot(roads, lwd = 0.2, col = &#39;black&#39;, add = TRUE) plot(stations, pch = 20, col = &#39;black&#39;, add = TRUE) 12.2.3 Зональные операции Зональные операции связаны с агрегированием растровых данных по площадным зонам. В пределах каждой зоны вычисляется одна или несколько характеристик значений анализируемого растра: среднее, максимум и т.д. Как правило, зоны задаются в виде вспомогательного растрового или векторного набора данных. В случае растра каждая ячейка должна содержать идентификатор (номер) зоны, к которой она относится. Совокупность ячеек, имеющих одинаковый идентификатор, определяет территорию, которую покрывает зона с этим идентификатором. Если зоны представлены векторным набором пространственных объектов, то каждый объект (полигон) также должен иметь собственный идентификатор. Теоретически в одном наборе данных может быть несколько пространственно не связанных объектов, относящихся к одной зоне (например, зона экваториального климата состоит из трех ареалов). В этом случае агрегирование данных будет произведено сразу по трем полигонам. Таким образом, количество получаемых в результате зональной статистики значений определяется количеством зон, но может не совпадать с общим количеством полигонов, которыми эти зоны представлены. В качестве примера рассмотрим вычисление среднеклиматических параметров WorldClim в пределах различных типов земельного покрова (Land Cover), которые доступны в пакете tmap: temp = getData(&quot;worldclim&quot;, var = &quot;tmean&quot;, res = 10) / 10 spplot(temp) data(land, package = &#39;tmap&#39;) # таблица типов земельного покрова и их идентификаторов в растре (tbl = land@data@attributes) ## [[1]] ## ID COUNT cover ## 1 1 9140 Broadleaf Evergreen Forest ## 2 2 6660 Broadleaf Deciduous Forest ## 3 3 6124 Needleleaf Evergreen Forest ## 4 4 6622 Needleleaf Deciduous Forest ## 5 5 4134 Mixed Forest ## 6 6 16171 Tree Open ## 7 7 9341 Shrub ## 8 8 21377 Herbaceous ## 9 9 1893 Herbaceous with Sparse Tree/Shrub ## 10 10 12247 Sparse vegetation ## 11 11 11658 Cropland ## 12 12 598 Paddy field ## 13 13 5587 Cropland / Other Vegetation Mosaic ## 14 14 65 Mangrove ## 15 15 1492 Wetland ## 16 16 7436 Bare area,consolidated (gravel,rock) ## 17 17 7221 Bare area,unconsolidated (sand) ## 18 18 388 Urban ## 19 19 61986 Snow / Ice ## 20 20 393060 Water bodies ## ## [[2]] ## ID COUNT cover_cls ## 1 1 48851 Forest ## 2 2 32611 Other natural vegetation ## 3 3 17843 Cropland ## 4 4 1557 Wetland ## 5 5 26904 Bare area/Sparse vegetation ## 6 6 388 Urban ## 7 7 61986 Snow/ice ## 8 8 393060 Water pal = c(&quot;#003200&quot;, &quot;#3C9600&quot;, &quot;#006E00&quot;, &quot;#556E19&quot;, &quot;#00C800&quot;, &quot;#8CBE8C&quot;, &quot;#467864&quot;, &quot;#B4E664&quot;, &quot;#9BC832&quot;, &quot;#EBFF64&quot;, &quot;#F06432&quot;, &quot;#9132E6&quot;, &quot;#E664E6&quot;, &quot;#9B82E6&quot;, &quot;#B4FEF0&quot;, &quot;#646464&quot;, &quot;#C8C8C8&quot;, &quot;#FF0000&quot;, &quot;#FFFFFF&quot;, &quot;#5ADCDC&quot;) tm_shape(land) + tm_raster(&#39;cover&#39;, palette = pal) Оператор @ означает обращение к слоту объекта. Слоты представляют собой объекты, являющиеся внутри других объектов, являющихся экземплярами классов S4. Предварительно необходимо убедиться, что оба растра имеют совпадающий охват (экстент) и пространственное разрешение. Обратите внимание на то, что, поскольку растр земельного покрова категориальный, для его передискретизации необходимо использовать метод ближайшего соседа (Nearest Neighbor), который для каждого пиксела нового растра берет значение в ближайшем к нему пикселе исходного растра: temp ## class : RasterBrick ## dimensions : 900, 2160, 1944000, 12 (nrow, ncol, ncell, nlayers) ## resolution : 0.1666667, 0.1666667 (x, y) ## extent : -180, 180, -60, 90 (xmin, xmax, ymin, ymax) ## coord. ref. : +proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0 ## data source : in memory ## names : tmean1, tmean2, tmean3, tmean4, tmean5, tmean6, tmean7, tmean8, tmean9, tmean10, tmean11, tmean12 ## min values : -51.3, -47.3, -44.3, -35.7, -20.6, -11.6, -11.4, -11.0, -16.5, -28.4, -40.9, -48.7 ## max values : 33.8, 33.3, 33.3, 34.2, 36.0, 38.4, 39.2, 38.2, 35.8, 32.7, 32.8, 33.0 land$cover ## class : RasterLayer ## dimensions : 540, 1080, 583200 (nrow, ncol, ncell) ## resolution : 0.3333333, 0.3333333 (x, y) ## extent : -180, 180, -90, 90 (xmin, xmax, ymin, ymax) ## coord. ref. : +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 ## data source : in memory ## names : cover ## values : 1, 20 (min, max) ## attributes : ## ID COUNT cover ## from: 1 9140 Broadleaf Evergreen Forest ## to : 20 393060 Water bodies cover = crop(land$cover, temp) %&gt;% resample(temp, method = &#39;ngb&#39;) # используем &#39;ngb&#39;, поскольку растр категориальный cover ## class : RasterLayer ## dimensions : 900, 2160, 1944000 (nrow, ncol, ncell) ## resolution : 0.1666667, 0.1666667 (x, y) ## extent : -180, 180, -60, 90 (xmin, xmax, ymin, ymax) ## coord. ref. : +proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0 ## data source : in memory ## names : cover ## values : 1, 20 (min, max) Для вычисления средней температуры января в пределах каждой зоны земельного покрова воспользуемся функцией zonal() из пакета raster. Полученный объект является матрицей: mtemp = zonal(temp, cover, &#39;mean&#39;) head(mtemp) ## zone tmean1 tmean2 tmean3 tmean4 tmean5 tmean6 ## [1,] 1 23.5827993 23.8581831 24.167610 24.222293 23.955707 23.37165 ## [2,] 2 0.0913672 1.5741542 5.767354 10.923912 15.000011 17.86541 ## [3,] 3 -12.4481575 -10.7375807 -4.774234 2.224753 8.684161 14.24578 ## [4,] 4 -26.9791391 -23.7655126 -15.765014 -5.486585 3.929032 11.40341 ## [5,] 5 -15.6666767 -13.3130511 -6.763048 1.819655 8.937738 14.28106 ## [6,] 6 -1.1417342 0.3537656 4.237481 8.935712 13.113762 16.35017 ## tmean7 tmean8 tmean9 tmean10 tmean11 tmean12 ## [1,] 23.12691 23.56288 23.998604 24.145374 23.969222 23.6631879 ## [2,] 19.38950 18.91055 16.211209 11.663783 5.875100 1.6160002 ## [3,] 17.04757 15.32626 10.387099 3.482172 -4.608318 -10.0533663 ## [4,] 14.71551 12.30481 5.827517 -3.921658 -16.702145 -24.2449122 ## [5,] 16.89588 15.12667 9.806683 2.859728 -5.847463 -12.7180889 ## [6,] 17.92776 17.14772 14.448163 9.953790 3.999909 0.2581328 Чтобы далее работать с полученными значениями, целесообразно присоединить описания зон и превратить полученную матрицу в аккуратный фрейм данных: (mtemp_tidy = as_tibble(mtemp) %&gt;% left_join(tbl[[1]], by = c(&#39;zone&#39; = &#39;ID&#39;)) %&gt;% gather(month, tmean, tmean1:tmean12) %&gt;% separate(month, c(&#39;dummy&#39;, &#39;month&#39;), sep = 5) %&gt;% mutate(month = as.integer(month)) %&gt;% select(-COUNT, -dummy)) ## # A tibble: 240 x 4 ## zone cover month tmean ## &lt;dbl&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1 Broadleaf Evergreen Forest 1 23.6 ## 2 2 Broadleaf Deciduous Forest 1 0.0914 ## 3 3 Needleleaf Evergreen Forest 1 -12.4 ## 4 4 Needleleaf Deciduous Forest 1 -27.0 ## 5 5 Mixed Forest 1 -15.7 ## 6 6 Tree Open 1 -1.14 ## 7 7 Shrub 1 8.81 ## 8 8 Herbaceous 1 -7.54 ## 9 9 Herbaceous with Sparse Tree/Shrub 1 24.3 ## 10 10 Sparse vegetation 1 -9.51 ## # ... with 230 more rows ggplot(mtemp_tidy) + geom_line(aes(x = month, y = tmean, color = cover), size = 1) + scale_color_manual(values = pal) + scale_x_continuous(breaks = 1:12) Перед вычислением целесообразно разделить растр землепользования на северное и южное полушарие (т.к. ход температур в них противоположный): cover_north = crop(cover, extent(-180, 180, 0, 90)) cover_south = crop(cover, extent(-180, 180, -60, 0)) temp_north = crop(temp, extent(-180, 180, 0, 90)) temp_south = crop(temp, extent(-180, 180, -60, 0)) mtemp_north_tidy = zonal(temp_north, cover_north, &#39;mean&#39;) %&gt;% as_tibble() %&gt;% left_join(tbl[[1]], by = c(&#39;zone&#39; = &#39;ID&#39;)) %&gt;% gather(month, tmean, tmean1:tmean12) %&gt;% separate(month, c(&#39;dummy&#39;, &#39;month&#39;), sep = 5) %&gt;% mutate(month = as.integer(month), hemisphere = &#39;north&#39;) %&gt;% select(-COUNT, -dummy) mtemp_south_tidy = zonal(temp_south, cover_south, &#39;mean&#39;) %&gt;% as_tibble() %&gt;% left_join(tbl[[1]], by = c(&#39;zone&#39; = &#39;ID&#39;)) %&gt;% gather(month, tmean, tmean1:tmean12) %&gt;% separate(month, c(&#39;dummy&#39;, &#39;month&#39;), sep = 5) %&gt;% mutate(month = as.integer(month), hemisphere = &#39;south&#39;) %&gt;% select(-COUNT, -dummy) mtemp_tidy2 = bind_rows(mtemp_north_tidy, mtemp_south_tidy) ggplot(mtemp_tidy2) + geom_line(aes(x = month, y = tmean, color = cover), size = 1) + scale_color_manual(values = pal) + scale_x_continuous(breaks = 1:12) + facet_wrap(~hemisphere, ncol = 1) 12.2.4 Глобальные операции Глобальные операции охватывают все ячейки растра. По сути, можно говорить, что это частный случай зональной операции, когда зона одна и покрывает растр целиком. В пакете raster для расчета глобальных статистик можно использовать функцию cellStats(), передав ей название растра и агрегирующей функции: cellStats(temp_north, max) ## [1] 31.2 32.2 33.3 34.2 36.0 38.4 39.2 38.2 35.8 32.7 30.5 30.2 cellStats(temp_south, min) ## [1] -1.1 -1.6 -2.8 -5.3 -8.3 -11.5 -11.4 -11.0 -9.7 -8.0 -5.1 ## [12] -2.2 12.3 Извлечение данных Растровая модель данных обеспечивает сплошное покрытие территории (с дискретностью, определяемой размером ячейки). В то же время, достаточно часто требуется получить значения растра в заданных местоположениях. Местоположения могут быть как конкретными объектами (например, точками почвенных разрезов), так и абстрактными географическими локациями, для которых известны координаты. Для извлечения растровых данных можно воспользоваться функцией extract(). Получать данные можно как по координатам (записанным в фрейм данных), так и используя пространственные объекты класса Spatial. Например, узнаем мощность покровного оледенения в точке в центре Гренландии: coords = data.frame(x = -45, y = 70) z = raster::extract(ice.depth, coords) plot(bed, breaks = brks, col = gray.colors(nclass), legend = F) plot(ice.depth, col = cm.colors(255), add = TRUE) points(coords) text(coords, labels = z, pos = 4) Одна из наиболее распространенных задач по извлечению растровых данных — это построение профиля вдоль заданной линии. Воспользуемся интерактивным редактором для проведения линии профиля mp = mapview(temp$tmean6) profile = mapedit::drawFeatures(mp) temprof = raster::extract(temp$tmean6, as(profile, &#39;Spatial&#39;), along = TRUE, cellnumbers = TRUE) head(temprof[[1]]) ## cell tmean6 ## [1,] 252105 1.8 ## [2,] 254265 1.8 ## [3,] 256425 1.9 ## [4,] 258585 2.2 ## [5,] 260745 2.3 ## [6,] 262905 2.5 Для построения линии профиля далее нам необходимо преобразовать идентификаторы ячеек растра в расстояние от начала профиля: tempdf = temprof[[1]] %&gt;% as_tibble() %&gt;% bind_cols(xyFromCell(temp, .$cell) %&gt;% as_tibble()) %&gt;% mutate(dist = 0.001 * c(0, cumsum(geosphere::distGeo(select(., x, y))))) pts = profile %&gt;% st_cast(&#39;POINT&#39;) %&gt;% mutate(label = c(&#39;A&#39;, &#39;B&#39;)) tm_shape(temp) + tm_raster(&#39;tmean6&#39;, midpoint = 0, palette = &#39;-RdBu&#39;) + tm_shape(profile) + tm_lines() + tm_shape(pts) + tm_bubbles(size = 0.1) + tm_text(&#39;label&#39;, remove.overlap = TRUE, auto.placement = TRUE) + tm_layout(legend.position = c(&#39;left&#39;, &#39;bottom&#39;)) ggplot(tempdf, aes(x = dist, y = tmean6)) + geom_line() + geom_smooth(span = 0.1) + annotate(&#39;text&#39;, x = 0, y = 10, label = &#39;A&#39;) + annotate(&#39;text&#39;, x = max(tempdf$dist), y = 10, label = &#39;B&#39;) + ggtitle(&#39;Профиль среднемесячной температуры июня по линии A—B&#39;) 12.4 Контрольные вопросы и упражнения 12.4.1 Вопросы Дайте описание локальных, фокальных, зональных и глобальных операций растровой алгебры. Приведите примеры использования данных типов операций. Каким требованиям должна отвечать геометрия растров, участвующих в локальных и зональных операциях? В чем заключается отличие фокальных операций с фиксированной и расширенной окрестностью? Чем отличается геометрия растра до и после применения фокальной операции? Какая функция пакета raster реализует возможности фокальной обработки растров? Какой эффект оказывает сглаживающая фильтрация на значения растра? Какие виды производных морфометрических величин позволяет получать функция terrain() из пакета raster? Какие два растра необходимо рассчитать для построения аналитической отмывки средствами функции terrain()? Опишите последовательность действий, которую необходимо выполнить для построения растра Евклидовых расстояний от заданных объектов? Какой метод интерполяции необходимо использовать для передискретизации категориальных растров? В чем заключается принцип его действия? Какая функция пакета raster используется для выполнения зональных операций? Какой тип результата она возвращает? Опишите возможности функции extract() по извлечению информации из растровых данных. В какой формате можно задать анализируемые локации? Что будет результатом вызова этой функции в зависимости от формата входных данных? Опишите последовательность действий, которую необходимо выполнить для построения профиля растровой поверхности средствами R. Можно ли построить профиль по растру, имеющему привязку в географической системе координат (координаты выражены градусах)? Если да, то как добиться того, чтобы расстояния между точками профиля были посчитаны в метрических единицах? 12.4.2 Упражнения В пакете tmap содержится растровый каталог land, включающий в себя растр elevation. Используя пакет mapedit, оцифруйте произвольную линию и постройте средствами ggplot профиль рельефа вдоль этой линии. Индекс континентальности Хромова рассчитывается по формуле \\(K = (A - 5.4 \\sin \\phi)/A\\), где \\(A\\) — годовая амплитуда хода температуры, \\(\\phi\\) — широта точки. Используя данные WorldClim, рассчитайте растр индекса континентальности на территорию суши и нанесите его на карту средствами tmap. Подсказка: используйте функцию xyFromCell(), чтобы получить широты всех ячеек растра температур. Далее создайте новый растр и запишите в него широты в качестве значений. Растры минимальных и максимальных значений из стека растров можно получить, используя обычные статистические функции min() и max(). Постройте растр, который содержит расстояние до береговой линии. Используйте данные Natural Earth. Задайте грубое разрешение растра, чтобы расчеты не производились долго (100 x 50 ячеек будет достаточно). Где находится самая удаленная от берега точка на суше? А самая удаленная точка на океане? Постройте карту, которая отображает полученный растр и береговую линию. Рассчитайте морфометрические коэффициенты TPI, TRI и roughness для цифровой модели рельефа Ферганской долины, которая использовалась в текущей лекции. В чем их суть? Изучите справку к инструменту terrain(). Самсонов Т.Е. Визуализация и анализ географических данных на языке R. М.: Географический факультет МГУ, 2017. DOI: 10.5281/zenodo.901911 Tomlin, C Dana. 2012. GIS and Cartographic Modeling. Second edition. Redlands, California: ESRI Press↩ "]
]
