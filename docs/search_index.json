[
["stat-analysis.html", "Глава 7 Основы статистики в R 7.1 Предварительные требования 7.2 Введение 7.3 Одна переменная 7.4 Две переменных 7.5 Контрольные вопросы и упражнения", " Глава 7 Основы статистики в R 7.1 Предварительные требования Для работы по теме текущей лекции вам понадобятся пакеты из tidyverse. Помимо этого, мы будем работать с данными через интерфейс Google Sheets напрямую с использованием пакетов googledrive и googlesheets4. Также в лекции используется пакет ggrepel, позволяющий устранять конфликты подписей на графиках ggplot: library(tidyverse) library(googledrive) library(googlesheets4) library(ggrepel) Внимание: пакет googlesheets4 в настоящий момент не доступен на CRAN. Для его установки вам необходимо сначала стандартным путём установить пакет devtools, а затем вызвать в консоли команду devtools::install_github(\"tidyverse/googlesheets4\"). Эта команда устанавливает пакет из репозитория GitHub. 7.2 Введение Математическая статистика — раздел математики, посвящённый математическим методам систематизации, обработки и использования статистических данных для научных и практических выводов. Под статистическими данными обычно понимают числовую информацию, извлекаемую из результатов выборочных обследований, результаты серии неточных измерений и вообще любую систему количественных данных (Прохоров 2011). Статистический метод представляет собой важнейший инструмент исследования, применяющийся во всех без исключения областях науки и технологий. Математическая статистика тесно связана с теорией вероятностей – разделом математики, изучающим математические модели случайных явлений. В силу огромного разнообразия статистических методов и специфики их применения в разных приложения, в одной лекции нет возможности (и смысла) представить их в одной лекции. В связи с этим в настоящем разделе представляются основные инструменты статистики, такие как: простейшие приемы статистического описания (описательные статистики), проверка статистических гипотез, оценка плотности распределения, корреляция и регрессия. Помимо этого, в настоящем разделе большое внимание уделено построению специализированных графиков, отражающих особенности распределения величины: гистограмм, диаграмм размаха, линий регрессии и локальной регрессии, кривых и поверхностей плотности распределения. 7.2.1 Источники данных 7.2.1.1 База данных Gapminder В данной лекции мы будем работать с базой данных Gapminder, которая содержит уникальный набор показателей по странам мира, агрегированный из различных источников (многие показатели имеют ряды на несколько столетий!): База данных Gapminder Gapminder отлично подходит для знакомства со основами статистического анализа в R, поскольку эта база данных содержит показатели с разным видом распределения, которые сгруппированы по макрорегионам и континентам, и, разумеется, имеют между собой ряд взаимосвязей, совместное поведение которых можно изучать посредством корреляционного и регрессионного анализа. Данные Gapminder можно загружать в текстовом формате и формате Microsoft Excel, но куда интереснее делать это непосредственно онлайн через программный интерфейс Google Sheets. Для этого нам потребуется знать ключ каждой таблицы, которую мы загружаем. Ключ можно определить, нажав “лупу” для просмотра данных и скопировав его из адресной строки (см. выделение): Ключ таблицы Google Sheets из базы данных Gapminder 7.2.1.2 Пакет googlesheets Доступ к облачным таблицам — удобный способ работы с табличными данными, который позволяет избавиться от манипуляций с локальными файлами. Свои данные вы тоже можете хранить в таблицах Google. Если таблицы регулярно обновляются держателем данных, загрузка их из облачного хранилища будет гарантировать вам актуальность анализируемой информации. Ограниченем такого режима работы является то, что для доступа к данным вам нужен Интернет. Пакет googlesheets4 разработан профессором статистики Дженнифер Брайан для обеспечения онлайн-доступа к таблицам Google. С кратким руководством по использованию пакета вы можете ознакомиться тут. Данный пакет использует версию 4.x Google Sheets API (отсюда цифра 4 в навании) и рекомендуется к использованию вместо устаревшего пакета googlesheets. Пакет googlesheets4 работает в связке с пакетом googledrive, обеспечивающим общие методы доступа к Google Drive. Стандартная последовательность действий чтобы получить в текущей сессии таблицу с Google Drive, выглядит так: Подключить библиотеки googledrive и googlesheets4. Выполнить авторизацию пользователя путем вызова drive_auth(). При вызове этой функции откроется браузер на странице аутентификации Google. Вам необходимо будет войти в систему под своей учетной записью Google. Загрузить таблицу с помощью функции drive_get(), передав ей в качестве аргумента название таблицы (в этом случае она будет искаться на вашем диске Google) или идентификатор таблицы (этим способом можно выгрузить в среду R таблицу из любого открытого хранилища Google Drive). Если передается идентификатор таблицы, его необходимо обернуть в класс drive_id путем вызова функции as_id(). Рассмотрим как это работает на примере загрузки данных из хранилища Gapminder. 7.3 Одна переменная 7.3.1 Оценка распределения Для оценки распределения случайной величины можно использовать графические и статистические способы. Выявление типа распределения важно, поскольку статистические методы не универсальны, и во многих случаях предполагают, что изучаемая переменная подчиняется определенному закону распределения (как правило, нормальному). В качестве примера возьмем данные по ВВП на душу населения, они содержатся в таблице gapminder с ниже приведенным кодом library(googledrive) library(googlesheets4) (&#39;1cxtzRRN6ldjSGoDzFHkB8vqPavq1iOTMElGewQnmHgg&#39; %&gt;% ### ВВП на душу населения as_id() %&gt;% # преобразуем идентификатор в класс drive_id чтобы отличать его от пути drive_get() %&gt;% read_sheet() -&gt; gdpdf) # выгружаем данные по ВВП на душу населения и сохраняем в переменную incdf ## Using an auto-discovered, cached token. ## To suppress this message, modify your code or options to clearly consent to the use of a cached token. ## See gargle&#39;s &quot;Non-interactive auth&quot; vignette for more details: ## https://gargle.r-lib.org/articles/non-interactive-auth.html ## The googledrive package is using a cached token for iamste@yandex.ru. ## Using an auto-discovered, cached token. ## To suppress this message, modify your code or options to clearly consent to the use of a cached token. ## See gargle&#39;s &quot;Non-interactive auth&quot; vignette for more details: ## https://gargle.r-lib.org/articles/non-interactive-auth.html ## The googlesheets4 package is using a cached token for iamste@yandex.ru. ## # A tibble: 260 x 256 ## `GDP per capita… `1764` `1765` `1766` `1767` `1768` `1769` `1770` `1771` ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Abkhazia NA NA NA NA NA NA NA NA ## 2 Afghanistan NA NA NA NA NA NA NA NA ## 3 Akrotiri and Dh… NA NA NA NA NA NA NA NA ## 4 Albania NA NA NA NA NA NA NA NA ## 5 Algeria NA NA NA NA NA NA NA NA ## 6 American Samoa NA NA NA NA NA NA NA NA ## 7 Andorra NA NA NA NA NA NA NA NA ## 8 Angola NA NA NA NA NA NA NA NA ## 9 Anguilla NA NA NA NA NA NA NA NA ## 10 Antigua and Bar… NA NA NA NA NA NA NA NA ## # … with 250 more rows, and 247 more variables: `1772` &lt;dbl&gt;, ## # `1773` &lt;dbl&gt;, `1774` &lt;dbl&gt;, `1775` &lt;dbl&gt;, `1776` &lt;dbl&gt;, `1777` &lt;dbl&gt;, ## # `1778` &lt;dbl&gt;, `1779` &lt;dbl&gt;, `1780` &lt;dbl&gt;, `1781` &lt;dbl&gt;, `1782` &lt;dbl&gt;, ## # `1783` &lt;dbl&gt;, `1784` &lt;dbl&gt;, `1785` &lt;dbl&gt;, `1786` &lt;dbl&gt;, `1787` &lt;dbl&gt;, ## # `1788` &lt;dbl&gt;, `1789` &lt;dbl&gt;, `1790` &lt;dbl&gt;, `1791` &lt;dbl&gt;, `1792` &lt;dbl&gt;, ## # `1793` &lt;dbl&gt;, `1794` &lt;dbl&gt;, `1795` &lt;dbl&gt;, `1796` &lt;dbl&gt;, `1797` &lt;dbl&gt;, ## # `1798` &lt;dbl&gt;, `1799` &lt;dbl&gt;, `1800` &lt;dbl&gt;, `1801` &lt;dbl&gt;, `1802` &lt;dbl&gt;, ## # `1803` &lt;dbl&gt;, `1804` &lt;dbl&gt;, `1805` &lt;dbl&gt;, `1806` &lt;dbl&gt;, `1807` &lt;dbl&gt;, ## # `1808` &lt;dbl&gt;, `1809` &lt;dbl&gt;, `1810` &lt;dbl&gt;, `1811` &lt;dbl&gt;, `1812` &lt;dbl&gt;, ## # `1813` &lt;dbl&gt;, `1814` &lt;dbl&gt;, `1815` &lt;dbl&gt;, `1816` &lt;dbl&gt;, `1817` &lt;dbl&gt;, ## # `1818` &lt;dbl&gt;, `1819` &lt;dbl&gt;, `1820` &lt;dbl&gt;, `1821` &lt;dbl&gt;, `1822` &lt;dbl&gt;, ## # `1823` &lt;dbl&gt;, `1824` &lt;dbl&gt;, `1825` &lt;dbl&gt;, `1826` &lt;dbl&gt;, `1827` &lt;dbl&gt;, ## # `1828` &lt;dbl&gt;, `1829` &lt;dbl&gt;, `1830` &lt;dbl&gt;, `1831` &lt;dbl&gt;, `1832` &lt;dbl&gt;, ## # `1833` &lt;dbl&gt;, `1834` &lt;dbl&gt;, `1835` &lt;dbl&gt;, `1836` &lt;dbl&gt;, `1837` &lt;dbl&gt;, ## # `1838` &lt;dbl&gt;, `1839` &lt;dbl&gt;, `1840` &lt;dbl&gt;, `1841` &lt;dbl&gt;, `1842` &lt;dbl&gt;, ## # `1843` &lt;dbl&gt;, `1844` &lt;dbl&gt;, `1845` &lt;dbl&gt;, `1846` &lt;dbl&gt;, `1847` &lt;dbl&gt;, ## # `1848` &lt;dbl&gt;, `1849` &lt;dbl&gt;, `1850` &lt;dbl&gt;, `1851` &lt;dbl&gt;, `1852` &lt;dbl&gt;, ## # `1853` &lt;dbl&gt;, `1854` &lt;dbl&gt;, `1855` &lt;dbl&gt;, `1856` &lt;dbl&gt;, `1857` &lt;dbl&gt;, ## # `1858` &lt;dbl&gt;, `1859` &lt;dbl&gt;, `1860` &lt;dbl&gt;, `1861` &lt;dbl&gt;, `1862` &lt;dbl&gt;, ## # `1863` &lt;dbl&gt;, `1864` &lt;dbl&gt;, `1865` &lt;dbl&gt;, `1866` &lt;dbl&gt;, `1867` &lt;dbl&gt;, ## # `1868` &lt;dbl&gt;, `1869` &lt;dbl&gt;, `1870` &lt;dbl&gt;, `1871` &lt;dbl&gt;, … Для дальнейшей работы целесообразно привести данные к аккуратному виду, избавившись от множества столбцов с годом измерения. Сразу получим данные за 2015 год для анализа: (gdpdf_tidy = gdpdf %&gt;% gather(year, gdp, `1764`:`2018`) %&gt;% rename(Country = 1)) ## # A tibble: 66,300 x 3 ## Country year gdp ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Abkhazia 1764 NA ## 2 Afghanistan 1764 NA ## 3 Akrotiri and Dhekelia 1764 NA ## 4 Albania 1764 NA ## 5 Algeria 1764 NA ## 6 American Samoa 1764 NA ## 7 Andorra 1764 NA ## 8 Angola 1764 NA ## 9 Anguilla 1764 NA ## 10 Antigua and Barbuda 1764 NA ## # … with 66,290 more rows gdpdf15 = filter(gdpdf_tidy, year == 2015) Для визуальной проверки вида распределения можно использовать геометрию geom_histogram(): ggplot(gdpdf15, aes(x = gdp)) + geom_histogram() Изменить ширину кармана можно, используя параметр binwidth: ggplot(gdpdf15, aes(x = gdp)) + geom_histogram(binwidth = 5000, color = &#39;black&#39;, fill = &#39;steelblue&#39;, size = 0.2) Аналогично рассмотрим показатель ожидаемой продолжительности жизни: (&#39;1H3nzTwbn8z4lJ5gJ_WfDgCeGEXK3PVGcNjQ_U5og8eo&#39; %&gt;% # продолжительность жизни as_id() %&gt;% # преобразуем идентификатор в класс drive_id чтобы отличать его от пути drive_get() %&gt;% read_sheet() -&gt; lifedf) # выгружаем данные по ВВП на душу населения и сохраняем в переменную lifedf ## # A tibble: 260 x 218 ## `Life expectanc… `1800` `1801` `1802` `1803` `1804` `1805` `1806` `1807` ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Abkhazia NA NA NA NA NA NA NA NA ## 2 Afghanistan 28.2 28.2 28.2 28.2 28.2 28.2 28.2 28.1 ## 3 Akrotiri and Dh… NA NA NA NA NA NA NA NA ## 4 Albania 35.4 35.4 35.4 35.4 35.4 35.4 35.4 35.4 ## 5 Algeria 28.8 28.8 28.8 28.8 28.8 28.8 28.8 28.8 ## 6 American Samoa NA NA NA NA NA NA NA NA ## 7 Andorra NA NA NA NA NA NA NA NA ## 8 Angola 27.0 27.0 27.0 27.0 27.0 27.0 27.0 27.0 ## 9 Anguilla NA NA NA NA NA NA NA NA ## 10 Antigua and Bar… 33.5 33.5 33.5 33.5 33.5 33.5 33.5 33.5 ## # … with 250 more rows, and 209 more variables: `1808` &lt;dbl&gt;, ## # `1809` &lt;dbl&gt;, `1810` &lt;dbl&gt;, `1811` &lt;dbl&gt;, `1812` &lt;dbl&gt;, `1813` &lt;dbl&gt;, ## # `1814` &lt;dbl&gt;, `1815` &lt;dbl&gt;, `1816` &lt;dbl&gt;, `1817` &lt;dbl&gt;, `1818` &lt;dbl&gt;, ## # `1819` &lt;dbl&gt;, `1820` &lt;dbl&gt;, `1821` &lt;dbl&gt;, `1822` &lt;dbl&gt;, `1823` &lt;dbl&gt;, ## # `1824` &lt;dbl&gt;, `1825` &lt;dbl&gt;, `1826` &lt;dbl&gt;, `1827` &lt;dbl&gt;, `1828` &lt;dbl&gt;, ## # `1829` &lt;dbl&gt;, `1830` &lt;dbl&gt;, `1831` &lt;dbl&gt;, `1832` &lt;dbl&gt;, `1833` &lt;dbl&gt;, ## # `1834` &lt;dbl&gt;, `1835` &lt;dbl&gt;, `1836` &lt;dbl&gt;, `1837` &lt;dbl&gt;, `1838` &lt;dbl&gt;, ## # `1839` &lt;dbl&gt;, `1840` &lt;dbl&gt;, `1841` &lt;dbl&gt;, `1842` &lt;dbl&gt;, `1843` &lt;dbl&gt;, ## # `1844` &lt;dbl&gt;, `1845` &lt;dbl&gt;, `1846` &lt;dbl&gt;, `1847` &lt;dbl&gt;, `1848` &lt;dbl&gt;, ## # `1849` &lt;dbl&gt;, `1850` &lt;dbl&gt;, `1851` &lt;dbl&gt;, `1852` &lt;dbl&gt;, `1853` &lt;dbl&gt;, ## # `1854` &lt;dbl&gt;, `1855` &lt;dbl&gt;, `1856` &lt;dbl&gt;, `1857` &lt;dbl&gt;, `1858` &lt;dbl&gt;, ## # `1859` &lt;dbl&gt;, `1860` &lt;dbl&gt;, `1861` &lt;dbl&gt;, `1862` &lt;dbl&gt;, `1863` &lt;dbl&gt;, ## # `1864` &lt;dbl&gt;, `1865` &lt;dbl&gt;, `1866` &lt;dbl&gt;, `1867` &lt;dbl&gt;, `1868` &lt;dbl&gt;, ## # `1869` &lt;dbl&gt;, `1870` &lt;dbl&gt;, `1871` &lt;dbl&gt;, `1872` &lt;dbl&gt;, `1873` &lt;dbl&gt;, ## # `1874` &lt;dbl&gt;, `1875` &lt;dbl&gt;, `1876` &lt;dbl&gt;, `1877` &lt;dbl&gt;, `1878` &lt;dbl&gt;, ## # `1879` &lt;dbl&gt;, `1880` &lt;dbl&gt;, `1881` &lt;dbl&gt;, `1882` &lt;dbl&gt;, `1883` &lt;dbl&gt;, ## # `1884` &lt;dbl&gt;, `1885` &lt;dbl&gt;, `1886` &lt;dbl&gt;, `1887` &lt;dbl&gt;, `1888` &lt;dbl&gt;, ## # `1889` &lt;dbl&gt;, `1890` &lt;dbl&gt;, `1891` &lt;dbl&gt;, `1892` &lt;dbl&gt;, `1893` &lt;dbl&gt;, ## # `1894` &lt;dbl&gt;, `1895` &lt;dbl&gt;, `1896` &lt;dbl&gt;, `1897` &lt;dbl&gt;, `1898` &lt;dbl&gt;, ## # `1899` &lt;dbl&gt;, `1900` &lt;dbl&gt;, `1901` &lt;dbl&gt;, `1902` &lt;dbl&gt;, `1903` &lt;dbl&gt;, ## # `1904` &lt;dbl&gt;, `1905` &lt;dbl&gt;, `1906` &lt;dbl&gt;, `1907` &lt;dbl&gt;, … Преобразуем в аккуратный вид и строим гистограмму распределения: lifedf_tidy = lifedf %&gt;% gather(year, lifexp, `1800`:`2016`) %&gt;% rename(Country = 1) lifedf15 = filter(lifedf_tidy, year == 2015) ggplot(lifedf15, aes(x = lifexp)) + geom_histogram(binwidth = 2, color = &#39;black&#39;, fill = &#39;olivedrab&#39;, size = 0.2) Для графической оценки распределения удобно использовать не только гистограмму, но также метод ядерного сглаживания (kernel density), который позволяет строить аппроксимацию функции плотности вероятности. Условно говоря, ядро является функцией, которая позволяет распространить потенциал каждого элемента выборки на его ближайшую окрестность. Чем больше элементов выборки сконцентрировано вблизи данной точки, тем сильнее будет их совокупно наведенный потенциал в данной точке, и тем, соответственно, выше оценка плотности распределения, которая получается суперпозицией этих потенциалов. Математически операция ядерной оценки плотности в точке \\(x\\) определяется как: \\[ \\hat f_h (x) = \\frac{1}{nh}\\sum_{i=1}^{n}K\\Big(\\frac{x - x_i}{h}\\Big) \\] где \\(K\\) — ядерная функция, \\(h &gt; 0\\) — сглаживающий параметр, \\(x_i\\) — элементы выборки, \\(n\\) — размер выборки. Ядерная функция должна удовлетворять двум критериям: \\(K(x) \\geq 0\\), \\(\\int_{-\\infty}^{+\\infty} K(x) dx = 1\\). Отсюда ясно, что любая модель функции плотности распределения может быть использована в качестве ядра: равномерное, нормальное и т.д. Как правило, ядерная функция носит бесконечно убывающий характер: чем дальше мы находимся от точки, тем меньше ее вклад в плотность распределения. В ggplot за аппроксимацию плотности распределения методом ядерного сглаживания отвечает геометрия geom_density(): ggplot(gdpdf15, aes(x = gdp)) + geom_density(color = &#39;black&#39;, fill = &#39;steelblue&#39;, alpha = 0.5) ggplot(lifedf15, aes(x = lifexp)) + geom_density(color = &#39;black&#39;, fill = &#39;olivedrab&#39;, alpha = 0.5) Вы можете комбинировать гистограммы и оценку плотности распределения, но для этого гистограмма по оси Y должна отражать не фактическое количество элементов в каждом классе, а долю или плотность вероятности (y = stat(density)): ggplot(gdpdf15, aes(x = gdp)) + geom_histogram(aes(y = stat(density)), fill = &#39;grey&#39;, color = &#39;black&#39;, size = 0.1) + geom_density(color = &#39;black&#39;, fill = &#39;steelblue&#39;, alpha = 0.5) ggplot(lifedf15, aes(x = lifexp)) + geom_histogram(aes(y = stat(density)), fill = &#39;grey&#39;, color = &#39;black&#39;, size = 0.1) + geom_density(color = &#39;black&#39;, fill = &#39;olivedrab&#39;, alpha = 0.5) При построении гистограмм и оценке плотности распределения мы допустили ошибку: приняли, что все измерения являются равнозначными. Однако в данном случае это не так. Население Люксембурга и Пакистана отличается на два порядка — это означает, что Пакистан должен иметь соответственно больший вес при построении гистограммы. Для учета этой характеристики подгрузим из Gapminder данные по численности населения и присоединим их к нашим таблицам по ВВП и продолжительности жизни: &#39;1IbDM8z5XicMIXgr93FPwjgwoTTKMuyLfzU6cQrGZzH8&#39; %&gt;% # численность населения as_id() %&gt;% # преобразуем идентификатор в класс drive_id чтобы отличать его от пути drive_get() %&gt;% read_sheet() %&gt;% # первый лист pivot_longer(cols = `1800`:`2015`, names_to = &#39;year&#39;, values_to = &#39;pop&#39;) %&gt;% rename(Country = 1) -&gt; popdf_tidy (tab = gdpdf_tidy %&gt;% inner_join(lifedf_tidy) %&gt;% inner_join(popdf_tidy)) ## # A tibble: 19,359 x 5 ## Country year gdp lifexp pop ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Abkhazia 1800 NA NA NA ## 2 Afghanistan 1800 472. 28.2 3280000 ## 3 Akrotiri and Dhekelia 1800 NA NA NA ## 4 Albania 1800 601. 35.4 410445 ## 5 Algeria 1800 766. 28.8 2503218 ## 6 American Samoa 1800 674. NA 8170 ## 7 Andorra 1800 1260. NA 2654 ## 8 Angola 1800 360. 27.0 1567028 ## 9 Anguilla 1800 776. NA 2025 ## 10 Antigua and Barbuda 1800 538. 33.5 37000 ## # … with 19,349 more rows Теперь мы можем произвести взвешенную оценку плотности распределения: tab15 = filter(tab, year == 2015) %&gt;% drop_na() # все веса должны быть непустыми! ggplot(tab15, aes(x = gdp, y = stat(density), weight = pop/sum(pop))) + geom_histogram(binwidth = 5000, fill = &#39;grey&#39;, color = &#39;black&#39;, size = 0.1) + geom_density(color = &#39;black&#39;, fill = &#39;steelblue&#39;, alpha = 0.5) ggplot(tab15, aes(x = lifexp, y = stat(density), weight = pop/sum(pop))) + geom_histogram(binwidth = 2.5, fill = &#39;grey&#39;, color = &#39;black&#39;, size = 0.1) + geom_density(color = &#39;black&#39;, fill = &#39;olivedrab&#39;, alpha = 0.5) Графики плотности распределения удобны тем, что их, в отличие от гистограмм, удобно комбинировать на одном изображении, используя цвет для разделения по еще одной переменной. Например, мы можем оценить, как изменились мировые диспропорции в продолжительности жизни и доходов населения за последние 50 лет (обратите внимание на параметр fill = year в эстетике: tab85 = tab %&gt;% filter(year %in% c(1965, 2015)) %&gt;% drop_na() ggplot(tab85, aes(x = gdp, fill = year, weight = pop/sum(pop))) + geom_density(alpha = 0.5) ggplot(tab85, aes(x = lifexp, fill = year, weight = pop/sum(pop))) + geom_density(alpha = 0.5) 7.3.2 Описательные статистики Описательные статистики — это числовые характеристики, описывающие особенности статистического распределения изучаемой величины. К таким характеристикам относят выборочное среднее, медиану, минимум, максимум и ряд других величин. Можно вычислять эти характеристики для всей выборки, но для включения географического контекста мы стратифицируем ее по макрорегионам, которые используются в базе данных Gapminder. Подгрузим эту информацию (данные скачиваются отсюда): library(readxl) countries = read_excel(&#39;gapminder.xlsx&#39;, 2) %&gt;% select(Country = name, Region = eight_regions) %&gt;% mutate(Country = factor(Country, levels = Country[order(.$Region)])) ggplot(countries, aes(x = Country, y = 1, fill = Region)) + geom_col() + geom_text(aes(y = 0.5, label = Country), size = 3) + facet_wrap(~Region, scales = &quot;free&quot;, ncol = 4) + theme_bw()+ theme(panel.grid = element_blank(), axis.title.y = element_blank(), axis.text.y = element_blank(), axis.ticks.y = element_blank(), axis.title.x = element_blank(), axis.text.x = element_blank(), axis.ticks.x = element_blank()) + guides(fill=FALSE) + coord_flip() Присоединим эти данные к исходной таблице: (tabreg = tab %&gt;% left_join(countries) %&gt;% filter(year == 2015) %&gt;% drop_na()) ## # A tibble: 172 x 6 ## Country year gdp lifexp pop Region ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Afghanistan 2015 1418. 53.8 32526562 asia_west ## 2 Albania 2015 7343. 78 2896679 europe_east ## 3 Algeria 2015 6797. 76.4 39666519 africa_north ## 4 Angola 2015 6512. 59.6 25021974 africa_sub_saharan ## 5 Antigua and Barbuda 2015 14884. 76.4 91818 america_north ## 6 Argentina 2015 16640. 76.5 43416755 america_south ## 7 Armenia 2015 5561. 74.7 3017712 europe_east ## 8 Australia 2015 38085. 82.3 23968973 east_asia_pacific ## 9 Austria 2015 37811. 81.3 8544586 europe_west ## 10 Azerbaijan 2015 10475. 72.9 9753968 europe_east ## # … with 162 more rows Мы уже знакомы с функциями min(), max(), median(), mean(), sd(), которые дают значения соответствующих описательных статистик для векторов данных. Как представить их все одновременно? Для визуализации отличий в статистических параметрах исследуемой выборки удобно использовать тип графика, который называется boxplot (а по русски — диаграмма размаха, улей, или ящик с усами). В ggplot за него отвечает геометрия geom_boxplot(): ggplot(tabreg, aes(x = Region, y = gdp)) + geom_boxplot() + coord_flip() ggplot(tabreg, aes(x = Region, y = lifexp)) + geom_boxplot() + coord_flip() Данные графики наглядно показывают, что регионы отличаются по ряду статистических параметров исследуемой переменной: среднему значению, размаху вариации (разбросу значений), среднеквадратическому отклонению Эти статистики можно получить и в табличном виде: (tabreg %&gt;% group_by(Region) %&gt;% summarise(gdp_mean = mean(gdp), gdp_sd = sd(gdp), lifexp_mean = mean(lifexp), lifexp_sd = sd(lifexp))) ## # A tibble: 8 x 5 ## Region gdp_mean gdp_sd lifexp_mean lifexp_sd ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 africa_north 6897. 3386. 73 4.97 ## 2 africa_sub_saharan 3583. 4553. 62.3 5.31 ## 3 america_north 13835. 11451. 74.9 4.00 ## 4 america_south 10350. 4277. 75.1 3.50 ## 5 asia_west 16374. 20957. 73.7 6.51 ## 6 east_asia_pacific 14062. 16634. 72.4 6.68 ## 7 europe_east 13634. 7030. 75.9 2.86 ## 8 europe_west 33571. 11104. 81.5 1.24 7.3.3 Статистические тесты Прежде чем манипулировать вычисленными статистиками (говорить, что в Западной Европе ВВП на душу населения в 10 раз выше, чем в Южной Африке), необходимо убедиться, что их отличия являются статистически значимыми. На статистическую значимость влияет не только абсолютная разность средних, но также характер распределения и объем выборки — выборки малого объема не могут дать высокой статистической значимости. Для сравнения средних значений и дисперсий двух статистических выборок обычно используют тест Стьюдента и тест Фишера соответственно. Проведем тесты для сравнения средних по Европе и Южной Африке используя функцию t.test() (на самом деле это тест Уэлча, являющийся модификацией теста Стьюдента): t.test(tabreg %&gt;% filter(Region == &#39;africa_sub_saharan&#39;) %&gt;% pull(gdp), tabreg %&gt;% filter(Region == &#39;europe_west&#39;) %&gt;% pull(gdp)) ## ## Welch Two Sample t-test ## ## data: tabreg %&gt;% filter(Region == &quot;africa_sub_saharan&quot;) %&gt;% pull(gdp) and tabreg %&gt;% filter(Region == &quot;europe_west&quot;) %&gt;% pull(gdp) ## t = -11.384, df = 20.547, p-value = 2.487e-10 ## alternative hypothesis: true difference in means is not equal to 0 ## 95 percent confidence interval: ## -35473.63 -24502.15 ## sample estimates: ## mean of x mean of y ## 3583.326 33571.214 t.test(tabreg %&gt;% filter(Region == &#39;africa_sub_saharan&#39;) %&gt;% pull(lifexp), tabreg %&gt;% filter(Region == &#39;europe_west&#39;) %&gt;% pull(lifexp)) ## ## Welch Two Sample t-test ## ## data: tabreg %&gt;% filter(Region == &quot;africa_sub_saharan&quot;) %&gt;% pull(lifexp) and tabreg %&gt;% filter(Region == &quot;europe_west&quot;) %&gt;% pull(lifexp) ## t = -23.037, df = 55.262, p-value &lt; 2.2e-16 ## alternative hypothesis: true difference in means is not equal to 0 ## 95 percent confidence interval: ## -20.87392 -17.53317 ## sample estimates: ## mean of x mean of y ## 62.25435 81.45789 p-значения для данных тестов очень малы, что позволяет нам принять (не отвергать) гипотезу о неравенстве средних для Западной Европы и Южной Африки. Проверим, так ли значимы отличия в средних для Северной и Южной Америки: t.test(tabreg %&gt;% filter(Region == &#39;america_north&#39;) %&gt;% pull(gdp), tabreg %&gt;% filter(Region == &#39;america_south&#39;) %&gt;% pull(gdp)) ## ## Welch Two Sample t-test ## ## data: tabreg %&gt;% filter(Region == &quot;america_north&quot;) %&gt;% pull(gdp) and tabreg %&gt;% filter(Region == &quot;america_south&quot;) %&gt;% pull(gdp) ## t = 1.1742, df = 23.283, p-value = 0.2522 ## alternative hypothesis: true difference in means is not equal to 0 ## 95 percent confidence interval: ## -2650.736 9620.806 ## sample estimates: ## mean of x mean of y ## 13834.72 10349.69 t.test(tabreg %&gt;% filter(Region == &#39;america_north&#39;) %&gt;% pull(lifexp), tabreg %&gt;% filter(Region == &#39;america_south&#39;) %&gt;% pull(lifexp)) ## ## Welch Two Sample t-test ## ## data: tabreg %&gt;% filter(Region == &quot;america_north&quot;) %&gt;% pull(lifexp) and tabreg %&gt;% filter(Region == &quot;america_south&quot;) %&gt;% pull(lifexp) ## t = -0.20306, df = 25.802, p-value = 0.8407 ## alternative hypothesis: true difference in means is not equal to 0 ## 95 percent confidence interval: ## -3.121651 2.560540 ## sample estimates: ## mean of x mean of y ## 74.86111 75.14167 В данном случае, несмотря на то, что вычисленные значения средних отличаются, тест показывает очень высокие p-значения (0.25 и 0.84 соответственно), что не позволяет нам говорить о том, что эти отличия статистически значимы. Соответственно, делать на их основе какие-либо научные выводы нельзя. Аналогичным образом можно проверить статистическую значимость отличий в дисперсии (вариации значений) для разных регионов. Для этого используем функцию var.test() применительно к регионам Западной и Восточной Европы: var.test(tabreg %&gt;% filter(Region == &#39;europe_east&#39;) %&gt;% pull(gdp), tabreg %&gt;% filter(Region == &#39;europe_west&#39;) %&gt;% pull(gdp)) ## ## F test to compare two variances ## ## data: tabreg %&gt;% filter(Region == &quot;europe_east&quot;) %&gt;% pull(gdp) and tabreg %&gt;% filter(Region == &quot;europe_west&quot;) %&gt;% pull(gdp) ## F = 0.40087, num df = 22, denom df = 18, p-value = 0.0434 ## alternative hypothesis: true ratio of variances is not equal to 1 ## 95 percent confidence interval: ## 0.1585416 0.9726112 ## sample estimates: ## ratio of variances ## 0.4008741 var.test(tabreg %&gt;% filter(Region == &#39;europe_east&#39;) %&gt;% pull(lifexp), tabreg %&gt;% filter(Region == &#39;europe_west&#39;) %&gt;% pull(lifexp)) ## ## F test to compare two variances ## ## data: tabreg %&gt;% filter(Region == &quot;europe_east&quot;) %&gt;% pull(lifexp) and tabreg %&gt;% filter(Region == &quot;europe_west&quot;) %&gt;% pull(lifexp) ## F = 5.3246, num df = 22, denom df = 18, p-value = 0.0006859 ## alternative hypothesis: true ratio of variances is not equal to 1 ## 95 percent confidence interval: ## 2.105831 12.918723 ## sample estimates: ## ratio of variances ## 5.324617 Данный тест показывает, что отличия в вариации значений ВВП на душу населения для Западной и Восточной Европы носят пограничный характер (p = 0.04), и принимать их можно только если стоит относительно высокое пороговое значение p = 0.05. В то же время, вариация продолжительности жизни для Западной Европы существенной меньше, чем для Восточной и при данной выборке это отличие обладает высокой статистической значимостью (p = 0.0007). Соответственно, его можно принимать с уверенностью. 7.4 Две переменных Достаточно часто в задачах анализа данных возникает необходимость совместного изучения нескольких переменных. Данный раздел посвящен анализу двух переменных. 7.4.1 Оценка распределения 7.4.1.1 Диаграмма рассеяния Первичный анализ производится путем оценки совместного распределения переменных на плоскости (для двух переменных) путем построения диаграммы рассеяния. С этим графиком мы уже хорошо знакомы: ggplot(tabreg, aes(gdp, lifexp)) + geom_point() Очевидно, что в данном случае мы имеем с нелинейной зависимостью. Чтобы упростить задачу по дальнейшему анализу, можно попробовать перейти к логарифмической шкале по оси X: options(scipen = 999) ggplot(tabreg, aes(gdp, lifexp)) + geom_point() + scale_x_log10() На диаграмме рассеяния важно показать не только местоположение точек, но также их весовую значимость, которая в данном случае определяется численностью населения в стране. Введем соответствующую графическую переменную — размер точки: ggplot(tabreg, aes(gdp, lifexp, size = pop)) + geom_point(alpha = 0.5) + scale_x_log10() Еще сильнее повысить информативность диаграммы рассеяния можно, используя цвет точек для обозначения региона принадлежности. Это позволит понять связь между введенной нами географической стратификацией и распределением элементов выборки на диаграмме рассеяния: ggplot(tabreg, aes(gdp, lifexp, size = pop, color = Region)) + geom_point(alpha = 0.5) + scale_x_log10() + theme_bw() Использование цвета наглядно показывает, что африканские страны занимают нижнюю левую часть диаграммы рассеяния с малой величиной ВВП и низкой продолжительностью жизни. Целесообразно также добавить подписи крупнейших стран мира с населением более 100 млн чел, а также страны, занимающие экстремальные позиции по обеим осям, чтобы понять положение ключевых игроков на диаграмме: tablab = tabreg %&gt;% # табличка для подписей filter( pop &gt; 1e8 | gdp == min(gdp) | gdp == max(gdp) | lifexp == min(lifexp) | lifexp == max(lifexp) ) ggplot(tabreg, aes(gdp, lifexp, color = Region)) + geom_point(aes(size = pop), alpha = 0.5) + geom_text(data = tablab, aes(label = Country), check_overlap = TRUE, show.legend = FALSE) + # убрать текст из легенды scale_x_log10() + theme_bw() Устранение перекрытий подписей можно осуществить, используя геометрию geom_text_repel() из пакета ggrepel вместо стандартной geom_text() ggplot(tabreg, aes(gdp, lifexp, color = Region)) + geom_point(aes(size = pop), alpha = 0.5) + geom_text_repel(data = tablab, aes(label = Country), box.padding = 0.7, # зазор вокруг подписи segment.size = 0.2, # толщина линии выноски show.legend = FALSE) + # убрать текст из легенды scale_x_log10() + labs(label = element_blank()) + theme_bw() 7.4.1.2 Плотность распределения Плотность совместного распределения двух случайных величин представляет собой уже не кривую, а поверхность, которую можно построить с использованием геометрии geom_density_2d(). По умолчанию эта геометрия визуализируется в форме изолиний: ggplot(tabreg, aes(gdp, lifexp)) + geom_point(alpha = 0.5) + geom_density_2d()+ scale_x_log10() + theme_bw() Усилить наглядность представления можно, добавив вспомогательную растровую поверхность плотности распределения (по которой, собственно, и строятся изолинии). Обратите внимание, что для растра используется функция stat_density(): ggplot(tabreg, aes(gdp, lifexp)) + stat_density_2d(geom = &quot;raster&quot;, aes(fill = stat(density)), contour = FALSE) + geom_density_2d(color = &#39;black&#39;, size = 0.2) + geom_point(alpha = 0.5) + scale_fill_gradient(low = &quot;white&quot;, high = &quot;red&quot;) + scale_x_log10() + theme_bw() График двумерной плотности распределения показывает, что мода распределения, т.е. наиболее часто встречающийся случай, примерно соответствует странам с продолжительностью жизни 75 лет и ВВП на душу населения $10000. В некоторых случаях удобнее оказывается не аппроксимация непрерывной поверхности плотности распределения, а подсчет количества измерений по ячейкам регулярной сетки — квадратным или гексагональным. Такой подход бывает особенно полезен, когда точек измерений очень много и из-за их количества оказывается проблематично разглядеть области их концентрации. Агрегирование данных по ячейкам осуществляется путем применения геометрий geom_bin2d() и geom_hex(): ggplot(tabreg, aes(gdp, lifexp)) + geom_bin2d(bins = 10)+ geom_point(alpha = 0.5) + scale_fill_gradient(low = &quot;white&quot;, high = &quot;red&quot;) + scale_x_log10() + theme_bw() ggplot(tabreg, aes(gdp, lifexp)) + geom_hex(bins = 10) + geom_point(alpha = 0.5) + scale_fill_gradient(low = &quot;white&quot;, high = &quot;red&quot;) + scale_x_log10() + theme_bw() 7.4.2 Корреляция и регрессия Корреляционный анализ позволяет дать численную характеристику статистической связи между двумя случайными величинами, а регрессионный анализ — моделировать эту взаимосвязь посредством построения функции взаимосвязи зависимой и множества независимых переменных. 7.4.2.1 Корреляция Коэффициент корреляции — это числовая характеристика совместного распределения двух случайных величин, характеризующая их взаимосвязь. Наиболее часто в статистике употребляется выборочный коэффициент корреляции Пирсона, в котором перебираются все пары соответствующих друг другу значений из рядов \\(X = \\{x_i\\}\\) и \\(Y = \\{y_i\\}\\): \\[ r_{xy} = \\frac{\\sum_{i=1}^{n}(x_i - \\bar x)(y_i - \\bar y)}{\\sqrt{\\sum_{i=1}^{n}(x_i - \\bar x)^2} \\sqrt{\\sum_{i=1}^{n}(y_i - \\bar y)^2}}, \\] где \\(\\bar x\\) и \\(\\bar y\\) соответствуют выборочным средним для \\(X\\) и \\(Y\\). Важно помнить, что коэффициент корреляции Пирсона характеризует силу линейной связи между двумя величинами. Поэтому, если наблюдаемая нами картина взаимосвязи носит нелинейный характер, необходимо предварительно линеаризовать ее, то есть выполнить преобразование над переменными, приводящее к получению линейной зависимости. В нашем в случае изучения ВВП на душу населения и продолжительности жизни мы видели, что линеаризация возможна путем логарифмирования показателя ВВП. Для вычисления коэффициента корреляции Пирсона в R с оценкой уровня значимости используется функция cor.test(): cor.test(tabreg$gdp, tabreg$lifexp) ## ## Pearson&#39;s product-moment correlation ## ## data: tabreg$gdp and tabreg$lifexp ## t = 11.376, df = 170, p-value &lt; 0.00000000000000022 ## alternative hypothesis: true correlation is not equal to 0 ## 95 percent confidence interval: ## 0.5632175 0.7347928 ## sample estimates: ## cor ## 0.6574446 Результат теста в данном случае показывает, что коэффициент корреляции с вероятностью 0,95 находится в интервале от 0,56 до 0,73, и его математическое ожидание равно 0,66. Проверим, можно ли уточнить эту оценку, выполнив логарифмирование показателя ВВП: cor.test(log(tabreg$gdp), tabreg$lifexp) ## ## Pearson&#39;s product-moment correlation ## ## data: log(tabreg$gdp) and tabreg$lifexp ## t = 17.327, df = 170, p-value &lt; 0.00000000000000022 ## alternative hypothesis: true correlation is not equal to 0 ## 95 percent confidence interval: ## 0.7375973 0.8473619 ## sample estimates: ## cor ## 0.7990415 Видим, что логарифмирование показателя позволяет повысить значение коэффициента корреляции до 0,8. При этом доверительный интервал, заключающий в себя эту величину с вероятностью 0,95 существенно сузился: с 0,17 до 0,11. Очевидно, мы получили более корректную оценку взаимосвязи. 7.4.2.2 Регрессия Для построения статистической модели этой зависимости, позволяющей по значениям независимой переменной вычислять значения зависимой переменной, необходимо провести регрессионный анализ. В общем случае кривая регрессии обычно выражается линейной комбинацией набора функций: \\[ y(x) = β_0φ_0(x)+ β_1φ_1(x)+...+ β_mφ_m(x) \\] Наиболее часто используется полиномиальная регрессия, при которой \\[ y(x) = β_0+β_1x+...+ β_mx^m. \\] В этом случае основная задача регрессионного анализа сводится к поиску неизвестных коэффициентов \\(β_0,...,β_m\\), который осуществляется методом наименьших квадратов. Результатом этого поиска являются выборочные коэффициенты регрессии \\(\\hat β_0,...,\\hat β_m\\), которые дают оценку искомых параметров \\(β_0,...,β_m\\). В итоге эмпирическая линия регрессии определяется многочленом \\[ \\hat y(x)=\\hat β_0+\\hat β_1x+...+\\hat β_mx_m, \\] который и служит статистической оценкой неизвестной формы функциональной зависимости между исследуемыми величинами. Для представления моделей в R существует специальный объект, который называется формула. Формула имеет вид f ~ x + y + ..., что интерпретируется соответствующими функциями как \\(f = β_0 + β_1x + β_2y + \\dots\\) Обратите внимание на символ тильды (~) — он является отличительной особенностью формулы и интерпретируется как «зависит от». Вместо переменных в формуле вы можете использовать функции от переменных. Например log(f) ~ log(x) + sqrt(y) означает модель \\(\\log f = β_0 + β_1 \\log x + β_2 \\sqrt y\\). Если необходимо выполнить алгебраические преобразования переменных или задать конкретное значение свободного члена, то их необходимо заключить в специальную функцию I(): f ~ log(x) + I(y ^ 2) + I(0) будет означать модель вида \\(f = β_1 \\log x + β_2 y^2\\). Для краткой записи полиномиальной зависимости можно использовать вспомогательную функцию poly(), которая в качестве второго аргумента принимает степень многочлена. Т.е. f ~ poly(x, 3) означает модель вида \\(f = β_0 + β_1x + β_2x^2 + β_3x^3\\). Оценка параметров линейных моделей осуществляется с помощью функции lm(). В нашем случае модель носит простой характер: model = lm(lifexp ~ log(gdp), data = tabreg) coef(model) ## (Intercept) log(gdp) ## 25.129347 5.261476 Полученные данные говорят нам о том, что уравнение имеет вид \\(lifexp = 25.13 + 5.26 \\log(gdp)\\). Чтобы получить подробную сводку о качестве модели, мы можем вызвать summary(): summary(model) ## ## Call: ## lm(formula = lifexp ~ log(gdp), data = tabreg) ## ## Residuals: ## Min 1Q Median 3Q Max ## -18.4327 -1.9398 0.6394 3.1638 10.1937 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 25.1293 2.7178 9.246 &lt;0.0000000000000002 *** ## log(gdp) 5.2615 0.3037 17.327 &lt;0.0000000000000002 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 4.785 on 170 degrees of freedom ## Multiple R-squared: 0.6385, Adjusted R-squared: 0.6363 ## F-statistic: 300.2 on 1 and 170 DF, p-value: &lt; 0.00000000000000022 Результаты оценки говорят о том, что регрессия построена удовлетворительно. Коэффициент детерминации (квадрат коэффициента корреляции) равен 0,64. Для визуализации модели можно извлечь из нее значения используя функцию fitted(): df = tibble(lifexp = fitted(model), gdp = tabreg$gdp) ggplot(tabreg, aes(gdp, lifexp)) + geom_point(alpha = 0.5) + geom_line(data = df, aes(gdp, lifexp), color = &#39;red&#39;, size = 1) + theme_bw() Если вам нужно только построить линию регрессии, но не находить ее коэффициенты, то вы можете пропустить этап оценки параметров модели и вывести график линейной регрессии средствами ggplot, используя геометрию geom_smooth() с параметром method = lm: ggplot(tabreg, aes(gdp, lifexp)) + geom_point(alpha = 0.5) + geom_smooth(method = &#39;lm&#39;, color = &#39;red&#39;, size = 1) + scale_x_log10() + theme_bw() 7.4.2.3 Локальная регрессия Метод локальной регрессии изначально был разработан для построения кривых регрессии в случае когда зависимость между переменными ведет себя сложным образом и не может быть описана в терминах традиционной линейной и нелинейной регрессии — глобальных методов. В этом случае область значений независимой переменной \\(X\\) можно покрыть конечным числом отрезков, для каждого из которых далее находят регрессию традиционным методом — как правило, линейную или квадратичную. В классической постановке метод реализуется следующим образом. Пусть дано \\(N\\) точек с координатами \\(X\\) (независимая переменная) и \\(Y\\) (зависимая). Задается число \\(\\alpha\\), которое обозначает долю от общего количества точек, которую необходимо выбрать в окрестности каждой из N точек для построения регрессии. То есть для каждой точки \\(p(x)\\) из исходных данных выбираются \\(\\alpha N\\) ближайших к ней. Близость определяется как разность координат \\(X\\). Выбранные точки определяют окрестность \\(p(x)\\), в которой будет строиться локальная регрессия. Далее происходит определение параметров линейной или квадратической регрессии взвешенным методом наименьших квадратов. При использовании этого метода более близкие к \\(p(x)\\) точки оказывают большее влияние на коэффициенты регрессии. Построенная регрессия дает в точке \\(x\\) сглаженную оценку \\(p&#39;(x)\\) вместо исходной \\(p(x)\\). Процедура повторяется для каждой из \\(N\\) точек. Результирующая кривая соединяет точки \\(p&#39;(x)\\). При этом чем больше значение \\(\\alpha\\), тем более сглаженный вид будет иметь кривая регрессии. Метод получил название LOWESS (Locally weighted scatterplot smoothing). В дальнейшем эта аббревиатура была редуцирована до LOESS. В методе LOESS используются степени регрессии 0, 1, 2. Кубические и более высокие степени полиномов не применяются. При степени равной 0 метод носит название сглаживающего среднего. Для построения линии локальной регрессии используйте функцию geom_smooth() без параметра method или с явным указанием параметра method = 'loess': ggplot(tabreg, aes(gdp, lifexp)) + geom_point(alpha = 0.5) + geom_smooth() + theme_bw() При визуализации линии локальной регрессии ggplot автоматически добавляет доверительные интервалы, показывающие диапазон нахождения искомой регрессионной кривой с вероятностью 0,95. Вы можете регулировать поведение локальной регрессии, задавая параметры n, span и formula. По умолчанию используется регрессия первой степени (formula = y ~ x), значения n = 80 и span = 0.75. Вы можете их изменить, например задать более компактный охват для поиска коэффициентов. В этом случае кривая будет более чувствительна к локальному разбросу элементов выборки: ggplot(tabreg, aes(gdp, lifexp)) + geom_point(alpha = 0.5) + geom_smooth(span = 0.3) + theme_bw() Вместо координат исходных точек для построения регрессии можно использовать и произвольные координаты \\(X\\). В этом случае кривая будет соединять точки, полученные локальной регрессионной оценкой в заданных координатах \\(X\\). Именно этот принцип используется в двумерном (и многомерном) случае. Пусть даны измерения показателя в \\(N\\) исходных точках и задано число \\(\\alpha\\) — сглаживающий параметр. Тогда аппроксимация показателя в каждом узле интерполяции получается путем построения поверхности тренда (см. выше) по \\(\\alpha N\\) ближайшим исходным точкам. Как и в одномерном случае, близкие точки будут оказывать более сильное влияние на коэффициенты регрессии, чем удаленные. Метод LOESS предоставляет широкие возможности настройки благодаря вариативности параметра сглаживания и степени регрессионного полинома. 7.5 Контрольные вопросы и упражнения 7.5.1 Вопросы Перечислите названия геометрий ggplot2, отвечающих за построение гистограммы и функции плотности распределения. Как работает метод ядерного сглаживания, используемый для аппроксимации функции плотности распределения? Каким критериям должна отвечать ядерная функция? Как совместить на одном графике гистограмму распределения и функцию плотности вероятности? Какой показатель должна отображать гистограмма высотой столбиков? Можно ли при построении графиков статистического характера определить различные веса для измерений? В какой параметр они должны передаваться? Какому критерию должны отвечать веса? С помощью какой геометрии можно построить диаграмму размаха средствами ggplot2? Как следует интерпретировать этот график? Как оценить статистическую значимость отличий в средних значениях и дисперсиях двух выборок? Какие тесты можно использовать для этого? Что из себя представляет плотность совместного распределения двух случайных величин? Какая геометрия ggplot2 позволяет аппроксимировать ее и нанести на диаграмму рассеяния? С помощью каких геометрий ggplot2 можно сгруппировать элементы диаграммы рассеяния ячейками ортогональной и гексагональной сеток? В каких случаях это оказывается полезно? Что такое коэффициент корреляции Пирсона, и какими ограничениями обладает этот показатель? Какая функция позволяет осуществить тест на корреляцию между двумя переменными в R? Что позволяет получить регрессионный анализ? Какой вид имеет уравнение регрессии в общем случае? Какой вид регрессии используется чаще всего? С помощью какого метода находят выборочные коэффициенты регрессии? Что такое формула в R, и для чего она используется? Как называется символ ~, и что он означает в формулах? Каким образов в формуле можно указать алгебраическое преобразование переменной? С помощью какой функции осуществляется оценка параметров линейных регрессионных моделей в R? Какие функции позволяют извлечь из модели выборочные коэффициенты регрессии, а также смоделированные (fitted) значения? Как на основе полученной модели нанести линию регрессии на график ggplot2? Опишите последовательность действий. Можно ли нанести линию регрессии на график ggplot2, не используя явное построение модели? Какую геометрию и с какими параметрами следует использовать для этого? Что такое локальная регрессия (LOESS), и как работает этот метод? Какая геометрия, и с какими параметрами используется для построения линии локальной регрессии на графике ggplot2? Что показывает полупрозрачная серая полоса вокруг линии регрессии на графике ggplot2? 7.5.2 Упражнения Изучите по данным Gapminder такие показатели как использование энергии и выбросы \\(CO_2\\) на душу населения. Постройте для них гистограммы и кривые плотности распределения. Какое распределение имеют данные показатели? Как изменилось оно с 1990 к 2010 году? Вычислите коэффициент корреляции между этими показателями и постройте регрессионную зависимость (на 2010 год). Дайте оценку статистической значимости полученных результатов. Изучите по данным Gapminder соотношение доли сельскохозяйсвенных земель в общей площади и доле водозабора на сельскохозяйственные нужды за 2002 год. Есть ли какая-то зависимость между этими переменными? Что можно сказать о том, как распределены страны мира по этим двум показателям? Постройте по ним диаграммы размаха, сгруппировав по 4, 6 или 8 регионам Gapminder. Дайте оценку статистической значимости отличий в средних значениях и дисперсии между двумя выбранными вами регионами по доле водозабора на сельскохозяйственные нужды. Самсонов Т.Е. Визуализация и анализ географических данных на языке R. М.: Географический факультет МГУ, 2019. DOI: 10.5281/zenodo.901911 References "]
]
