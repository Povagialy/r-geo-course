[
["data-structures.html", "Глава 2 Структуры данных и циклы 2.1 Однородные структуры данных 2.2 Разнородные структуры данных 2.3 Факторы 2.4 Описание структуры данных 2.5 Циклы 2.6 Технические детали 2.7 Краткий обзор 2.8 Контрольные вопросы и упражнения", " Глава 2 Структуры данных и циклы Программный код главы Структура данных — это программная единица, позволяющая хранить и обрабатывать множество однотипных и/или логически связанных данных. Структуры данных также являются типами данных, но не простыми, а составными. Поэтому обычно, когда говорят “тип данных”, подразумевают именно простые типы данных, рассмотренные в предыдущей главе. В R общеупотребительны следующие структуры данных: векторы, матрицы, массивы, фреймы данных, списки и факторы. С использованием структур данных тесно связаны циклы — разновидность управляющей конструкции, предназначенная для многократного повторения определенного набора инструкций. 2.1 Однородные структуры данных 2.1.1 Векторы Вектор представляет собой упорядоченную последовательность объектов одного типа. Вектор может состоять только из чисел, только из строк, только из дат или только из логических значений и т.д. Числовой вектор легко представить себе в виде набора цифр, выстроенных в ряд и пронумерованных согласно порядку их расстановки. Вектор является простейшей и одновременно базовой структурой данных в R. Понимание принципов работы с векторами необходимо для дальнейшего знакомства с более сложными структурами данных, такими как матрицы, массивы, фреймы данных, тибблы, списки и факторы. 2.1.1.1 Создание Существует множество способов создания векторов. Среди них наиболее употребительны: Явное перечисление элементов Создание пустого вектора (“болванки”), состоящего из заданного числа элементов Генерация последовательности значений Генерация случайного множества значений Для создания вектора путем перечисления элементов используется функция c(): # вектор из строк — цвета некоторых веток Московского метро colors = c(&quot;Красная&quot;, &quot;Зеленая&quot;, &quot;Синяя&quot;, &quot;Коричневая&quot;, &quot;Оранжевая&quot;) colors ## [1] &quot;Красная&quot; &quot;Зеленая&quot; &quot;Синяя&quot; &quot;Коричневая&quot; &quot;Оранжевая&quot; # вектор из чисел — длина веток в километрах (в той же последовательности) lengths = c(28, 40, 45, 19, 38) lengths ## [1] 28 40 45 19 38 # вектор из булевых переменных — наличие открытых наземных участков (в той же последовательности) opens = c(FALSE, TRUE, TRUE, FALSE, FALSE) opens ## [1] FALSE TRUE TRUE FALSE FALSE Внимание: не используйте латинскую букву ‘c’ в качестве названия переменной! Это приведет к конфликту названия встроенной функции c() и определенной вами переменной Помимо этого, распространены сценарии, когда вам нужно создать вектор, но заполнять его значениями вы будете по ходу выполнения программы — скажем, при последовательной обработке строк таблицы. В этом случае вам известно только предполагаемое количество элементов вектора и их тип. Здесь лучше всего подойдет создание пустого вектора, которое выполняется функцией vector(). Функция принимает 2 параметра: mode отвечает за тип данных и может принимать значения равные \"logical\", \"integer\", \"numeric\" (или \"double\"), \"complex\", \"character\" и \"raw\" length отвечает за количество элементов Например: # Вектор из 5 элементов, который предполагается заполнить целыми числами intvalues = vector(mode = &quot;integer&quot;, length = 5) intvalues # по умолчанию заполнен нулями ## [1] 0 0 0 0 0 # Вектор из 10 элементов, который предполагается заполнить символьными данными (строками) charvalues = vector(&quot;character&quot;, 10) charvalues # по умолчанию заполнен пустыми строками ## [1] &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; Обратите внимание на то, что в первом случае подстановка параметров произведена в виде параметр = значение, а во втором указаны только значения. В данном примере оба способа эквивалентны. Однако первый способ безопаснее и понятнее. Если вы указываете только значения параметров, нужно помнить, что интерпретатор будет подставлять их именно в том порядке, в котором они перечислены в описании функции. Описание функции можно посмотреть, набрав ее название в консоли ее название со знаком вопроса в качестве префикса. Например, для вышеуказанной функции надо набрать ?vector Наконец, третий распространенный способ создания векторов — это генерация последовательности. Чтобы сформировать вектор из натуральных чисел от M до N, можно воспользоваться специальной конструкцией: M:N: index = 1:5 # эквивалентно c(1,2,3,4,5) index ## [1] 1 2 3 4 5 index = 2:4 # эквивалентно c(2,3,4) index ## [1] 2 3 4 Существует и более общий способ создания последовательности — функция seq(), которая позволяет генерировать вектора значений нужной длины и/или с нужным шагом: seq(from = 1, by = 2, length.out = 10) # 10 нечетных чисел, начиная с единицы ## [1] 1 3 5 7 9 11 13 15 17 19 seq(from = 2, to = 20, by = 3) # от 2 до 20 с шагом 3 (сколько поместится) ## [1] 2 5 8 11 14 17 20 seq(length.out = 10, to = 2, by = -2) # убывающая последовательность из 10 четных чисел с последним элементом, равным 2 ## [1] 20 18 16 14 12 10 8 6 4 2 Как видно, параметры функции seq() можно комбинировать различными способами и указывать в произвольном порядке (при условии, что вы используете полную форму (параметр = значение). Главное, чтобы их совокупность однозначно описывала последовательность. Хотя, скажем, последний пример убывающей последовательности нельзя признать удачным с точки зрения наглядности. Аналогичным образом можно создавать последовательности дат: seq(from = as.Date(&#39;2016/09/01&#39;), by = 1, length.out = 7) # Даты первой недели учебного 2016/2017 года ## [1] &quot;2016-09-01&quot; &quot;2016-09-02&quot; &quot;2016-09-03&quot; &quot;2016-09-04&quot; &quot;2016-09-05&quot; ## [6] &quot;2016-09-06&quot; &quot;2016-09-07&quot; seq(from = Sys.Date(), by = 7, length.out = 5) # Пять дат через неделю, начиная с сегодняшнего дня ## [1] &quot;2019-09-10&quot; &quot;2019-09-17&quot; &quot;2019-09-24&quot; &quot;2019-10-01&quot; &quot;2019-10-08&quot; Часто оказывается полезным такая функция как генерация множества случайных значений, подчиненных определенному закону распределения. Наиболее часто испольщуются функции runif() (равномерное распределение) и rnorm() (нормальное распределение): runif(5, 0, 100) # 5 чисел равномерного распределения в диапазоне от 0 до 100 ## [1] 19.95054 64.19616 89.30539 36.94487 26.93506 rnorm(5, 10, 5) # 5 чисел нормального распределения со средним = 10 и СКО = 5 ## [1] 11.484527 16.567774 7.119709 7.339046 10.719256 2.1.1.2 Индексирование К отдельным элементам вектора можно обращаться по их индексам: colors[1] # первый элемент вектора ## [1] &quot;Красная&quot; colors[3] # третий элемент ## [1] &quot;Синяя&quot; ВНИМАНИЕ: элементы векторов и других структур данных в языке R индексируются от 1 до N, где N — это длина вектора. Это отличает R от широко распространенных Си-подобных языков программирования (C, C++, C#, Java, Python), в которых индексы элементов начинаются с 0 и заканчиваются N-1. Например, первый элемент списка (аналог вектора в R) на языке Python извлекался бы как colors[0]. Будьте внимательны, особенно если программируете на нескольких языках. Количество элементов (длину) вектора можно узнать с помощью функции length(): length(colors) ## [1] 5 Последний элемент вектора можно извлечь, если мы знаем его длину: n = length(colors) colors[n] ## [1] &quot;Оранжевая&quot; Последовательности удобно использовать для извлечения подвекторов. Предположим, нужно извлечь первые 4 элемента. Для этого запишем: lengths[1:4] ## [1] 28 40 45 19 Индексирующий вектор можно создать заранее. Это удобно, если номера могут меняться в программе: m = 1 n = 4 index = m:n lengths[index] ## [1] 28 40 45 19 Обратите внимание на то что по сути один вектор используется для извлечения элементов из другого вектора. Это означает, что мы можем использовать не только простые последовательности натуральных чисел, но и векторы из прозвольных индексов. Например: index = c(1, 3, 4) # хотим извлечь 1, 3 и 4 элемент списка lengths[index] ## [1] 28 45 19 index = c(5, 1, 4, 2) # индексы могут располагаться в произвольном порядке lengths[index] ## [1] 38 28 19 40 2.1.1.3 Преобразование К числовым векторам можно применять множество функций. Прежде всего, нужно знать функции вычисления базовых параметров статистического ряда — минимум, максимум, среднее, медиана, дисперсия, размах вариации, среднеквадратическое отклонение, сумма: min(lengths) # минимум ## [1] 19 max(lengths) # максимум ## [1] 45 range(lengths) # размах вариации = максимум - минимум ## [1] 19 45 mean(lengths) # среднее арифметическое ## [1] 34 median(lengths) # медиана ## [1] 38 var(lengths) # дисперсия (по английски - вариация, variation) ## [1] 108.5 sd(lengths) # среднеквадратическое отклонение (standard deviation) ## [1] 10.41633 sum(lengths) # сумма ## [1] 170 Одной из мощнейших особенностей R является то что он не проводит различий между числами и векторами чисел. Поскольку R является матричным языком, каждое число представляется как вектор длиной 1 (или матрица \\(1х1\\)). Это означает, что любая математическая функция, применимая к числу, будет применима и к вектору: lengths * 1000 # преобразуем длины линий в метры ## [1] 28000 40000 45000 19000 38000 sqrt(lengths) # квадратный корень из длины каждого элемента ## [1] 5.291503 6.324555 6.708204 4.358899 6.164414 stations = c(20, 21, 22, 12, 24) # количество станций dens = stations / lengths # плотность станций по веткам метро = кол-во станций / длина dens ## [1] 0.7142857 0.5250000 0.4888889 0.6315789 0.6315789 2.1.1.4 Поиск и сортировка К важнейшим преобразованиям векторов относится их сортировка: lengths2 = sort(lengths) # сортировка по возрастанию значений lengths2 # отсортированный вектор ## [1] 19 28 38 40 45 lengths # сравним с исходным ## [1] 28 40 45 19 38 lengths2 = sort(lengths, decreasing = TRUE) # сортировка по убыванию значений. Нужно задать параметр decreasing lengths2 # отсортированный вектор ## [1] 45 40 38 28 19 lengths # сравним с исходным ## [1] 28 40 45 19 38 Другая распространенная задача — это поиск индекса элемента по его значению. Например, вы хотите узнать, какая ветка Московского метро (среди рассматриваемых) является самой длинной. Вы, конечно, легко найдете ее длину с помощью функции max(lengths). Однако это не поможет вам узнать ее название, поскольку оно находится в другом векторе, и его индекс в массиве неизвестен. Поскольку векторы упорядочены одинаково, нам достаточно узнать, под каким индексом в массиве lengths располагается максимальный элемент, и затем извлечь цвет линии метро под тем же самым индексом. Дл поиска индекса элемента используется функция match(): l = max(lengths) # находим максимальное значение idx = match(l, lengths) # находим индекс элемента, равного l, в списке lengths color = colors[idx] # извлекаем цвет ветки метро color ## [1] &quot;Синяя&quot; Здесь непохо бы лишний раз потренироваться в конкатенации строк, чтобы вывести результат красиво! s = paste(color, &quot;ветка Московского метро — самая длинная. Ее протяженность составляет&quot;, l, &quot;км&quot;) s ## [1] &quot;Синяя ветка Московского метро — самая длинная. Ее протяженность составляет 45 км&quot; Ну и напоследок пример “матрешки”\" из функций — как найти название самой плотной линии одним выражением: colors[match(max(dens),dens)] ## [1] &quot;Красная&quot; 2.1.1.5 Проверка условий Проверка условия для вектора приводит к получению вектора логических значений: lengths &gt; 20 ## [1] TRUE TRUE TRUE FALSE TRUE Такого рода условия используются для фильтрации фреймов данных (см. далее) Для векторов существует специальная форма векторизованного условного оператора – функция ifelse(). Она позволяет создать вектор, каждый элемент которого вычисляется по-разному в зависимости от значения элемента другого вектора в соответствующей позиции. Например, мы можем охарактеризовать каждую линию метро как длинную или короткую, установив порог в 20 км: (line_type = ifelse(lengths &gt; 20, &#39;Длинная&#39;, &#39;Короткая&#39;)) ## [1] &quot;Длинная&quot; &quot;Длинная&quot; &quot;Длинная&quot; &quot;Короткая&quot; &quot;Длинная&quot; 2.1.1.6 Описательные статистики Можно получить краткую статистическую сводку по вектору (и любой другой структуре данных) с использованием функции summary(). Для качественных переменных выдаются частоты вхождения каждого случая, для количественных — набор основных описательных статистик: summary(lengths) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 19 28 38 34 40 45 summary(opens) ## Mode FALSE TRUE ## logical 3 2 2.1.2 Матрицы Матрица — это обобщение понятия вектора на 2 измерения. С точки зрения анализа данных матрицы ближе к реальным данным, посколько каждая матрица по сути представляет собой таблицу со столбцами и строками. Однако матрица, как и вектор, может содержать только элементы одного типа (числовые, строковые, логические и т.д.). Позже мы познакомимся с фреймами данных, которые не обладают подобным ограничением. Матрица, как правило, создается с помощью функции matrix, которая принимает 3 обязательных аргумента: вектор исходных значений, количество строк и количество столбцов: v = 1:12 # создадим вектор из натуральных чисел от 1 до 12 m = matrix(v, nrow = 3, ncol = 4) m ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 ## [3,] 3 6 9 12 По умолчанию матрица заполняется данными вектора по столбцам, что можно видеть в выводе программы. Если вы хотите заполнить ее по строкам, необходимо указать параметр byrow = TRUE: m = matrix(v, nrow = 3, ncol = 4, byrow = TRUE) m ## [,1] [,2] [,3] [,4] ## [1,] 1 2 3 4 ## [2,] 5 6 7 8 ## [3,] 9 10 11 12 Доступ к элементам матрицы осуществляется аналогично вектору, за исключением того что нужно указать положение ячейки в строке и столбце: m[2,4] # 2 строка, 4 толбец ## [1] 8 m[3,1] # 3 строка, 1 столбец ## [1] 9 Помимо этого, из матрицы можно легко извлечь одну строку или один столбец. Для этого достаточно указать только номер строки или столбца, а номер второго измерения пропустить до или после запятой. Результат является вектором: m[2,] # 2 строка ## [1] 5 6 7 8 m[,3] # 3 cтолбец ## [1] 3 7 11 К матрицам можно применять операции, аналогичные операциям над векторами: log(m) # натуральный логарифм ото всех элементов ## [,1] [,2] [,3] [,4] ## [1,] 0.000000 0.6931472 1.098612 1.386294 ## [2,] 1.609438 1.7917595 1.945910 2.079442 ## [3,] 2.197225 2.3025851 2.397895 2.484907 sum(m) # сумма всех элементов матрицы ## [1] 78 median(m) # медиана ## [1] 6.5 B и получать по ним описательные статистики: summary(m) ## V1 V2 V3 V4 ## Min. :1 Min. : 2 Min. : 3 Min. : 4 ## 1st Qu.:3 1st Qu.: 4 1st Qu.: 5 1st Qu.: 6 ## Median :5 Median : 6 Median : 7 Median : 8 ## Mean :5 Mean : 6 Mean : 7 Mean : 8 ## 3rd Qu.:7 3rd Qu.: 8 3rd Qu.: 9 3rd Qu.:10 ## Max. :9 Max. :10 Max. :11 Max. :12 А вот сортировка матрицы приведет к тому что будет возвращен обычный вектор: sort(m) ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 К матрицам также применимы специальные функции, известные из линейной алгебры, такие как транспонирование и вычисление определителя: t(m) # транспонированная матрица ## [,1] [,2] [,3] ## [1,] 1 5 9 ## [2,] 2 6 10 ## [3,] 3 7 11 ## [4,] 4 8 12 m2=matrix(-3:3,nrow = 3, ncol = 3) m2 ## [,1] [,2] [,3] ## [1,] -3 0 3 ## [2,] -2 1 -3 ## [3,] -1 2 -2 det(m2) # определитель матрицы ## [1] -21 det(m) # ошибка! определитель вычисляется только для квадратных матриц ## Error in determinant.matrix(x, logarithm = TRUE, ...): &#39;x&#39; должен быть квадратной матрицей Матрицы также можно перемножать с помощью специального оператора %*%. При этом, как мы помним, число столбцов в первой матрице должно равняться числу строк во второй: m2 %*% m ## [,1] [,2] [,3] [,4] ## [1,] 24 24 24 24 ## [2,] -24 -28 -32 -36 ## [3,] -9 -10 -11 -12 m %*% m2 # ошибка! ## Error in m %*% m2: неподобные аргументы Функция match(), которую мы использовали для поиска элементов в векторе, не работает для матриц. Вместо этого необходимо использовать функцию which(). Если мы хотим найти в матрице m позицию числа \\(8\\), то вызов функции будет выглядеть так: which(m == 8, arr.ind = TRUE) ## row col ## [1,] 2 4 В данном случае видно, что результат возвращен в виде матрицы \\(1 \\times 2\\). Обратите внимание на то, что колонки матрицы имеют названия. Попробуем использовать найденные индексы, чтобы извлечь искомый элемент: indexes = which(m == 8, arr.ind = TRUE) row = indexes[1,1] col = indexes[1,2] m[row,col] ## [1] 8 Ура! Найденный элемент действительно равен \\(8\\). Еще один полезный способ создания матрицы — это собрать ее из нескольких векторов, объединив их по строкам. Для этого можно использовать функции cbind() и rbind(). На предыдущем занятии мы создали векторы с длиной и количеством станций на разных ветках метро. Можно объединить их в одну матрицу: lengths = c(28, 40, 45, 19, 38) stations = c(20, 21, 22, 12, 24) cbind(lengths, stations) # соединим вектора в качестве столбцов ## lengths stations ## [1,] 28 20 ## [2,] 40 21 ## [3,] 45 22 ## [4,] 19 12 ## [5,] 38 24 rbind(lengths, stations) # соединим вектора в качестве строк ## [,1] [,2] [,3] [,4] [,5] ## lengths 28 40 45 19 38 ## stations 20 21 22 12 24 Cтроки и столбцы матрицы можно использовать как векторы при выполнении арифметических операций: mm = cbind(lengths, stations) mm[,2]/mm[,1] # количество станций на 1 км пути ## [1] 0.7142857 0.5250000 0.4888889 0.6315789 0.6315789 Результат можно присоединить к уже созданной матрице: dens = mm[,2]/mm[,1] mm=cbind(mm, dens) mm ## lengths stations dens ## [1,] 28 20 0.7142857 ## [2,] 40 21 0.5250000 ## [3,] 45 22 0.4888889 ## [4,] 19 12 0.6315789 ## [5,] 38 24 0.6315789 Содержимое матрицы можно просмотреть в более привычном табличном виде для этого откройте вкладку Environment и щелкните на строку с матрицей в разделе Data Матрицы, однако, не дотягивают по функциональности до представления таблиц, и не предназначены для объединения разнородных данных в один набор (как мы это сделали). Если вы присоедините к матрице столбец с названиями веток метро, система не выдаст сообщение об ошибке, но преобразует матрицу в текстовую, так как текстовый тип данных способен представить любой другой тип данных: colors = c(&quot;Красная&quot;, &quot;Зеленая&quot;, &quot;Синяя&quot;, &quot;Коричневая&quot;, &quot;Оранжевая&quot;) mm2=cbind(mm,colors) mm2 # обратите внимание на то, что вокруг чисел добавились кавычки ## lengths stations dens colors ## [1,] &quot;28&quot; &quot;20&quot; &quot;0.714285714285714&quot; &quot;Красная&quot; ## [2,] &quot;40&quot; &quot;21&quot; &quot;0.525&quot; &quot;Зеленая&quot; ## [3,] &quot;45&quot; &quot;22&quot; &quot;0.488888888888889&quot; &quot;Синяя&quot; ## [4,] &quot;19&quot; &quot;12&quot; &quot;0.631578947368421&quot; &quot;Коричневая&quot; ## [5,] &quot;38&quot; &quot;24&quot; &quot;0.631578947368421&quot; &quot;Оранжевая&quot; При попытке выполнить арифметическое выражение над прежде числовыми полями, вы получите сообщение об ошибке: mm2[,2]/mm2[,1] ## Error in mm2[, 2]/mm2[, 1]: нечисловой аргумент для бинарного оператора 2.1.3 Массивы Массивы (arrays) — это многомерные структуры данных, с колчеством измерений 3 и более. Трехмерный массив представляет собой куб однородных данных. Для создания массива используется функция array(): z = array(1:36, c(3,4,2)) # вектор значений для заполнения массива, а также длина каждого измерения print(z) ## , , 1 ## ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 ## [3,] 3 6 9 12 ## ## , , 2 ## ## [,1] [,2] [,3] [,4] ## [1,] 13 16 19 22 ## [2,] 14 17 20 23 ## [3,] 15 18 21 24 Массивы возникают тогда, например, когда имеются многомерные данные, зафиксированные по регулярной сетке географичесих локаций (это типично для геофизических данных). При этом 2 измерения отвечают за местоположение, а третье измерение — за временной срез или показатель. 2.2 Разнородные структуры данных 2.2.1 Фреймы данных Фреймы данных — это обобщение понятия матрицы на данные смешанных типов. Фреймы данных - наиболее распространенный формат представления табличных данных. Для краткости мы иногда будем называть их просто фреймами. Мы специально не используем для перевода слова data.frame термин ‘таблица’, поскольку таблица — это достаточно общая категория, которая описывает концептуальный способ упорядочивания данных. В том же языке R для представления таблиц могут быть использованы как минимум две структуры данных: фрейм данных (data.frame) и тиббл (tibble), доступный в соответствующем пакете. Мы не будем использовать тибблы в настоящем курсе, но после его освоения вы вполне сможете ознакомиться с ними самостоятельною Для создания фреймов данных используется функция data.frame(): df = data.frame(colors,lengths,stations) df # как мы видим, уже никаких кавычек вокруг чисел ## colors lengths stations ## 1 Красная 28 20 ## 2 Зеленая 40 21 ## 3 Синяя 45 22 ## 4 Коричневая 19 12 ## 5 Оранжевая 38 24 К фреймам также можно пристыковывать новые столбцы: df = cbind(df, dens) df ## colors lengths stations dens ## 1 Красная 28 20 0.7142857 ## 2 Зеленая 40 21 0.5250000 ## 3 Синяя 45 22 0.4888889 ## 4 Коричневая 19 12 0.6315789 ## 5 Оранжевая 38 24 0.6315789 Когда фрейм данных формируется посредством функции data.frame() и cbind(), названия столбцов берутся из названий векторов. Обратите внимание на то, что листинге выше столбцы имеют заголовки, а строки — номера. Как и прежде, к столбцам и строкам можно обращаться по индексам: df[2,2] ## [1] 40 df[,3] ## [1] 20 21 22 12 24 df[4,] ## colors lengths stations dens ## 4 Коричневая 19 12 0.6315789 Вы можете обращаться к отдельным столбцам фрейма данных по их названию, используя оператор $ (доллар): df$lengths ## [1] 28 40 45 19 38 df$stations ## [1] 20 21 22 12 24 Так же как и ранее, можно выполнять различные операции над столбцами: max(df$stations) ## [1] 24 df$lengths / df$stations ## [1] 1.400000 1.904762 2.045455 1.583333 1.583333 Названия столбцов можно получить с помощью функции colnames() colnames(df) ## [1] &quot;colors&quot; &quot;lengths&quot; &quot;stations&quot; &quot;dens&quot; Чтобы присоединить строку, сначала можно создать фрейм данных из одной строки: row = data.frame(&quot;Фиолетовая&quot;, 40.5, 22, 22/45) Далее нужно убедиться, что столбцы в этом мини-фрейме называются также как и в том фрейме, куда мы хотим присоединить строку. Для этого нужно перезаписать результат, возвращаемый функцией colnames(): colnames(row) = colnames(df) Обратите внимание на синтаксис вышеприведенного выражения. Когда функция возвращает результат, она обнаруживает свойство самого объекта, и мы можем его перезаписать. После того как столбцы приведены в соответствие, можно присоединить новую строку: df = rbind(df,row) Чтобы отсортировать фрейм данных по значению определенного поля, необходимо узнать порядок элементов в этом поле с помощью функции order() и проиндексировать им первое измерение фрейма: df[order(df$lengths), ] ## colors lengths stations dens ## 4 Коричневая 19.0 12 0.6315789 ## 1 Красная 28.0 20 0.7142857 ## 5 Оранжевая 38.0 24 0.6315789 ## 2 Зеленая 40.0 21 0.5250000 ## 6 Фиолетовая 40.5 22 0.4888889 ## 3 Синяя 45.0 22 0.4888889 Чтобы отфильтровать фрейм данных по значению определенного поля, необходимо передать условие в первое измерение фрейма: df[df$lengths &gt; 40, ] ## colors lengths stations dens ## 3 Синяя 45.0 22 0.4888889 ## 6 Фиолетовая 40.5 22 0.4888889 Поскольку названия столбцов хранятся как вектор из строк, мы можем их переделать: colnames(df) = c(&quot;Цвет&quot;,&quot;Длина&quot;,&quot;Станции&quot;,&quot;Плотность&quot;) colnames(df) ## [1] &quot;Цвет&quot; &quot;Длина&quot; &quot;Станции&quot; &quot;Плотность&quot; Обратимся по новому названию столбца: df$Длина ## [1] 28.0 40.0 45.0 19.0 38.0 40.5 К фреймам данных, так же как и к однородным структурам, можно применять функцию summary() для получения описательных статистик. При этом отчет формируется по каждому столбцу: summary(df) ## Цвет Длина Станции Плотность ## Зеленая :1 Min. :19.00 Min. :12.00 Min. :0.4889 ## Коричневая:1 1st Qu.:30.50 1st Qu.:20.25 1st Qu.:0.4979 ## Красная :1 Median :39.00 Median :21.50 Median :0.5783 ## Оранжевая :1 Mean :35.08 Mean :20.17 Mean :0.5800 ## Синяя :1 3rd Qu.:40.38 3rd Qu.:22.00 3rd Qu.:0.6316 ## Фиолетовая:1 Max. :45.00 Max. :24.00 Max. :0.7143 2.2.2 Списки Список — это наиболее общий тип контейнера в R. Список отличается от вектора тем, что он может содержать набор объектов произвольного типа. В качестве элементов списка могут быть числа, строки, вектора, матрицы, фреймы данных — и все это в одном контейнере. Списки используются чтобы комбинировать разрозненную информацию. Результатом выполнения многих функций является список. Например, можно создать список из текстового описания фрейма данных, самого фрейма данных и обобщающей статистики по нему: d = &quot;Этот фрейм данных содержит данные по 6 линиям Московского метро&quot; s = summary(df) # summary() выдает обобщающую статистику вектору, матрице или фрейму данных Сооружаем список из трех элементов: metrolist = list(d, df, s) metrolist ## [[1]] ## [1] &quot;Этот фрейм данных содержит данные по 6 линиям Московского метро&quot; ## ## [[2]] ## Цвет Длина Станции Плотность ## 1 Красная 28.0 20 0.7142857 ## 2 Зеленая 40.0 21 0.5250000 ## 3 Синяя 45.0 22 0.4888889 ## 4 Коричневая 19.0 12 0.6315789 ## 5 Оранжевая 38.0 24 0.6315789 ## 6 Фиолетовая 40.5 22 0.4888889 ## ## [[3]] ## Цвет Длина Станции Плотность ## Зеленая :1 Min. :19.00 Min. :12.00 Min. :0.4889 ## Коричневая:1 1st Qu.:30.50 1st Qu.:20.25 1st Qu.:0.4979 ## Красная :1 Median :39.00 Median :21.50 Median :0.5783 ## Оранжевая :1 Mean :35.08 Mean :20.17 Mean :0.5800 ## Синяя :1 3rd Qu.:40.38 3rd Qu.:22.00 3rd Qu.:0.6316 ## Фиолетовая:1 Max. :45.00 Max. :24.00 Max. :0.7143 Можно дать элементам списка осмысленные названия при создании: metrolist = list(desc = d, table = df, summary = s) metrolist ## $desc ## [1] &quot;Этот фрейм данных содержит данные по 6 линиям Московского метро&quot; ## ## $table ## Цвет Длина Станции Плотность ## 1 Красная 28.0 20 0.7142857 ## 2 Зеленая 40.0 21 0.5250000 ## 3 Синяя 45.0 22 0.4888889 ## 4 Коричневая 19.0 12 0.6315789 ## 5 Оранжевая 38.0 24 0.6315789 ## 6 Фиолетовая 40.5 22 0.4888889 ## ## $summary ## Цвет Длина Станции Плотность ## Зеленая :1 Min. :19.00 Min. :12.00 Min. :0.4889 ## Коричневая:1 1st Qu.:30.50 1st Qu.:20.25 1st Qu.:0.4979 ## Красная :1 Median :39.00 Median :21.50 Median :0.5783 ## Оранжевая :1 Mean :35.08 Mean :20.17 Mean :0.5800 ## Синяя :1 3rd Qu.:40.38 3rd Qu.:22.00 3rd Qu.:0.6316 ## Фиолетовая:1 Max. :45.00 Max. :24.00 Max. :0.7143 Теперь можно обратиться к элементу списка по его названию: metrolist$summary ## Цвет Длина Станции Плотность ## Зеленая :1 Min. :19.00 Min. :12.00 Min. :0.4889 ## Коричневая:1 1st Qu.:30.50 1st Qu.:20.25 1st Qu.:0.4979 ## Красная :1 Median :39.00 Median :21.50 Median :0.5783 ## Оранжевая :1 Mean :35.08 Mean :20.17 Mean :0.5800 ## Синяя :1 3rd Qu.:40.38 3rd Qu.:22.00 3rd Qu.:0.6316 ## Фиолетовая:1 Max. :45.00 Max. :24.00 Max. :0.7143 Поскольку summary сама является фреймом данных, из нее можно извлечь столбец: metrolist$summary[,3] ## ## &quot;Min. :12.00 &quot; &quot;1st Qu.:20.25 &quot; &quot;Median :21.50 &quot; &quot;Mean :20.17 &quot; ## ## &quot;3rd Qu.:22.00 &quot; &quot;Max. :24.00 &quot; К элементу списка можно также обратиться по его порядковому номеру или названию, заключив их в двойные квадратные скобки: metrolist[[1]] ## [1] &quot;Этот фрейм данных содержит данные по 6 линиям Московского метро&quot; metrolist[[&quot;desc&quot;]] ## [1] &quot;Этот фрейм данных содержит данные по 6 линиям Московского метро&quot; Использование двойных скобок отличает списки от векторов. Вызов функции summary() в приложении к списку выведет статистику по типам и количеству элементов списка: summary(metrolist) ## Length Class Mode ## desc 1 -none- character ## table 4 data.frame list ## summary 24 table character 2.3 Факторы Понятие фактора в терминологии R используется для обозначения категориальной (качественной) переменной. Как известно, такие переменные могут быть номинальными (с неопределенным порядком) и порядковыми (с заданным отношением порядка). Проблема взаимодействия с категориальными переменными заключается в том, что они могут приобретать разнообразные формы: быть выражены в виде чисел и строк. Эта форма может быть обманчивой. Например, модели самолетов Boeing и Sukhoi SuperJet обознаются числами (747, 100 и т.д.). Однако очевидно, что складывать и вычитать такие числа смысла нет, они являются формой представления номинальной переменной. Другой пример: названия месяцев записываются в виде строк. Если попытаться отсортировать месяцы цветения различных видов деревьев, то получится бессмысленный алфавитный порядок, в котором апрель следует за августом. В данном случае проблема заключается в том, что мы имеем дело с категориальной переменной, в которой задан порядок следования допустимых значений. В географических данных категориальные переменные тоже достаточно распространены. К номинальной шкале измерений относятся всевозможные числовые коды: почтовые, ОКАТО и т.д. К порядковой шкале - административный статус населенного пункта, сила землетрясения по шкале Рихтера. Для того, чтобы соответствующие данные в среде R правильно обрабатывались статистическими функциями и отображались в виде подходящих графических способов, необходимо явным образом проинформировать об этом программу. Для этого и создаются факторы. Фактор построен по принципу ассоциативного массива и является надстройкой над вектором, в которой каждому значению вектора присваивается некий код. Вы можете управлять этими кодами, а можете оставить их на усмотрение программы. Например, каждая линия Московского метро имеет свой номер. Создадим небольшей фрейм данных с электродепо по интересующим нас веткам метро и рассчитаем по ним описательные статистики: depots = data.frame( depot = c(&#39;Северное&#39;, &#39;Черкизово&#39;, &#39;Сокол&#39;, &#39;Замоскворецкое&#39;, &#39;Братеево&#39;, &#39;Измайлово&#39;, &#39;Фили&#39;, &#39;Митино&#39;, &#39;Красная Пресня&#39;, &#39;Калужское&#39;, &#39;Свиблово&#39;), year_opened = c(1935, 1990, 1938, 1969, 2014, 1950, 1962, 2016, 1954, 1962, 1978), line_number = c(1, 1, 2, 2, 2, 3, 3, 3, 5, 6, 6) ) print(depots) ## depot year_opened line_number ## 1 Северное 1935 1 ## 2 Черкизово 1990 1 ## 3 Сокол 1938 2 ## 4 Замоскворецкое 1969 2 ## 5 Братеево 2014 2 ## 6 Измайлово 1950 3 ## 7 Фили 1962 3 ## 8 Митино 2016 3 ## 9 Красная Пресня 1954 5 ## 10 Калужское 1962 6 ## 11 Свиблово 1978 6 summary(depots) ## depot year_opened line_number ## Братеево :1 Min. :1935 Min. :1.000 ## Замоскворецкое:1 1st Qu.:1952 1st Qu.:2.000 ## Измайлово :1 Median :1962 Median :3.000 ## Калужское :1 Mean :1970 Mean :3.091 ## Красная Пресня:1 3rd Qu.:1984 3rd Qu.:4.000 ## Митино :1 Max. :2016 Max. :6.000 ## (Other) :5 Как видно, R посчитал нам средний номер линии метро - 3.091, что выглядит, мягко говоря, странновато. Чтобы этого не происходило, укажем в явном виде с помощью функции factor(), что номер линии метров является номинальной переменной: depots$line_number = as.factor(depots$line_number) print(depots$line_number) ## [1] 1 1 2 2 2 3 3 3 5 6 6 ## Levels: 1 2 3 5 6 Мы видим, что у переменной появился дополнительный атрибут Levels, который отвечает за список уникальных значений номинальной переменной. Отношение порядка мы здесь не вводим, поскольку номер является условным обозначением. Попробуем теперь посчитать описательные статистики по переменной и таблице в целом: mean(depots$line_number) ## [1] NA summary(depots) ## depot year_opened line_number ## Братеево :1 Min. :1935 1:2 ## Замоскворецкое:1 1st Qu.:1952 2:3 ## Измайлово :1 Median :1962 3:3 ## Калужское :1 Mean :1970 5:1 ## Красная Пресня:1 3rd Qu.:1984 6:2 ## Митино :1 Max. :2016 ## (Other) :5 Теперь мы видим, что вместо стандартных статистик R для переменной line_number выдает таблицу частот, из которой ясно, что на первой линии два депо, на второй линии три депо и так далее. 2.4 Описание структуры данных Для описания структуры данных можно использовать две широко используемые диагностические функции: class() выведет тип структуры, а str() выведет детальную выписку по компонентам этой структуры: class(depots) # тип объекта ## [1] &quot;data.frame&quot; str(depots) # структура объекта ## &#39;data.frame&#39;: 11 obs. of 3 variables: ## $ depot : Factor w/ 11 levels &quot;Братеево&quot;,&quot;Замоскворецкое&quot;,..: 8 11 9 2 1 3 10 6 5 4 ... ## $ year_opened: num 1935 1990 1938 1969 2014 ... ## $ line_number: Factor w/ 5 levels &quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;5&quot;,..: 1 1 2 2 2 3 3 3 4 5 ... 2.5 Циклы Цикл — это разновидность управляющей конструкции, предназначенная для организации многократного исполнения набора инструкций. В R циклы наиболее часто используются для пакетной обработки данных, ввода и вывода. Типичными примерами использования циклов являются чтение множества файлов входных данных, а также построение серий графиков и карт одного типа по различным данным. При этом обработка множества строк таблиц в R обычно организуется не средствами циклов, а средствами функций семейства lapply, о которых мы поговорим в главе, посвященной техникам программирования на R. Циклы обычно связаны с проходом по элементам списка/вектора либо с созданием такого списка/вектора. Поэтому они излагаются в настоящей главе. В R, как и во многих других языках программирования, существует несколько вариантов циклов. Первый вид циклов — это конструкция for с синтаксисом for (x in X) statement. Она означает, что: переменная x должна пробежать по всем элементам последовательности X. В качестве последовательности может выступать любой вектор или список. каждый раз, когда x будет присвоено значение очередного элемента из X, будет выполнено выражение statement, которое называют телом цикла. Соответственно, цикл выполнится столько раз, сколько элементов содержится в последовательности X. Выполнение тела цикла на каждом проходе называют итерацией. Например, с помощью цикла можно вывести на экран числа от 1 до 10, по одному с каждой строки: ## ЦИКЛЫ for (i in 1:10) print(i) ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 ## [1] 7 ## [1] 8 ## [1] 9 ## [1] 10 Если тело цикла содержит более одной инструкции R, оно должно быть заключено в фигурные скобки, иначе выполнится только первое выражение, а оставшиеся будут запущены один раз после выхода из цикла: for (i in 1:10) { a = factorial(i) # факториал i b = exp(i) # e в степени i print(a/b) # факториал растет быстрее экспоненты } ## [1] 0.3678794 ## [1] 0.2706706 ## [1] 0.2987224 ## [1] 0.4395753 ## [1] 0.8085536 ## [1] 1.784702 ## [1] 4.595885 ## [1] 13.52585 ## [1] 44.78295 ## [1] 164.7473 Другой вариант цикла организуется с помощью конструкции while, имеющей синтаксис while (condition) statement. Такая конструкция означает, что тело цикла будет выполняться, пока значение выражения condition (условия) равно TRUE. Как правило, в теле цикла обновляется некоторая переменная, которая участвует в проверке условия, и предполагается, что рано или поздно оно станет равным FALSE, что приведет к выходу из цикла. Например, вышеприведенный цикл, печатающий числа от 1 до 10, можно переписать на while следуюшим образом: i = 0 while(i &lt; 10) { i = i+1 print(i) } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 ## [1] 7 ## [1] 8 ## [1] 9 ## [1] 10 Обратите внимание на то, что мы внутри цикла обновляем значение переменной i. Увеличение значения переменной цикла называется инкрементом, а уменьшение — декрементом. Одной из самых распространенных ошибок программистов (особенно начинающих, но и професионалы ее не избегают) является забытая инструкция инкремента (или декремента) переменной цикла, в результате чего цикл становится бесконечным. В этом плане конструкция for более надежна. В качестве примера приведем проход по столбцам фрейма данных и вычисление медианного значения для каждого столбца таблицы линий метро: n = ncol(df) medians = vector(&#39;numeric&#39;, n) for (i in 1:n) { if(is.numeric(df[, i])){ medians[i] = median(df[, i]) } else { medians[i] = NA } } colnames(df) # Переменные ## [1] &quot;Цвет&quot; &quot;Длина&quot; &quot;Станции&quot; &quot;Плотность&quot; medians # Медианные значения ## [1] NA 39.0000000 21.5000000 0.5782895 Существуют специальные операторы, позволяющие принудительно прервать текущую итерацию цикла и перейти на следующую, а также выйти из цикла вообще. Они называются next и break. Они бывают полезны, когда в теле цикла может произойти событие, делающее невозможным (или бессмысленным) его дальнейшее выполнение. Например, мы можем выводить информацию об электродепо, имеющихся на линии метро с введенным пользователем номером, до тех пор, пока он не введет символ q. Чтобы цикл был бесконечным, используем специальную форму while (TRUE): while (TRUE) { cat(&#39;Введите номер ветки метро:&#39;) input = readline() if (input == &#39;q&#39;) break else { n = as.numeric(input) if (!is.na(n)) depots[depots$line_number == n, ] } } Оператор next используется реже, так как в принципе он взаимозаменяем с конструкцией if-else. Он бывет удобен, когда в длинном цикле имеется несколько мест, в которых возможен переход на следующую итерацию. При использовании next последующий код нет необходимости табулировать и забирать в скобки. Следующие паттерны идентичны, но вариант с next позволяет остаться на том же уровне вложенности: Паттерн 1: while (...) { if (condition1) next ... # сюда попадем, только если condition1 == FALSE if (condition2) next ... # сюда попадем, только если condition2 == FALSE } Паттерн 2: while (...) { if (!condition1) { ... # сюда попадем, только если condition1 == FALSE if (!condition2) { ... # сюда попадем, только если condition2 == FALSE } } } 2.6 Технические детали Внутреннюю структуру и размер объекта можно исследовать с помощью пакета lobstr. Например, посмотрим, как организован в пямяти объект metrolist: library(lobstr) ref(metrolist) ## █ [1:0x7f8d0e480358] &lt;named list&gt; ## ├─desc = [2:0x7f8ceeb849e0] &lt;chr&gt; ## ├─table = █ [3:0x7f8d1e4140b8] &lt;df[,4]&gt; ## │ ├─Цвет = [4:0x7f8d1e601468] &lt;fct&gt; ## │ ├─Длина = [5:0x7f8d0e4028c8] &lt;dbl&gt; ## │ ├─Станции = [6:0x7f8d0e402af8] &lt;dbl&gt; ## │ └─Плотность = [7:0x7f8d0e403038] &lt;dbl&gt; ## └─summary = [8:0x7f8d0dc41ca0] &lt;table&gt; obj_size(metrolist) ## 5,696 B 2.7 Краткий обзор Для просмотра презентации щелкните на ней один раз левой кнопкой мыши и листайте, используя кнопки на клавиатуре: Презентацию можно открыть в отдельном окне или вкладке браузере. Для этого щелкните по ней правой кнопкой мыши и выберите соответствующую команду. 2.8 Контрольные вопросы и упражнения 2.8.1 Вопросы На какие две большие группы можно разделить структуры данных в R? Чем он отличаются? Что такое вектор в языке R? Какие способы создания векторов существуют? Можно ли хранить в векторе данные разных типов? Как определить длину вектора? Как извлечь из вектора элемент по его индексу? Как извлечь из вектора множество элементов по их индексам? Как извлечь из вектора последний элемент? С помощью какой функции можно сгенерировать последовательность чисел или дат с заданным шагом? Как сгенерировать последовательность целых чисел с шагом 1, не прибегая к функциям? Можно ли применять к векторам арифметические операторы и математические функции? Что будет результатом их выполнения? С помощью какой функции можно отсортировать вектор? Как изменить порядок сортировки на противоположный? С помощью какой функции можно найти индекс элемента вектора по его значению? Что вернет функция, если этот элемент встречается в векторе несколько раз? Как работает функция ifelse() и для чего она используется? Как работает функция summary() и для чего она используется? Какая функция позволяет создать матрицу? По строкам или по столбцам заполняется матрица при использовании вектора как источника данных по умолчанию? Как извлечь элемент по его индексам из матрицы, массива, фрейма данных, списка? Как извлечь строку или столбец из матрицы или фрейма данных? С помощью какого специального символа можно обратиться к столбцу фрейма данных по его названию? Как получить или записать названия столбцов фрейма данных? Как получить или записать названия строк фрейма данных? Какая структура данных является результатом сортировки матрицы? Какая функция позволяет осуществить транспонирование матрицы? Какой оператор используется для умножения матриц? Каким критериям должны отвечать перемножаемые матрицы, чтобы эта операция была осуществима? Как добавить новый столбец в фрейм данных? Опишите несколько вариантов. Как добавить новую строку в фрейм данных? Что произойдет, если к целочисленной матрице прибавить столбец, заполненный строками? Какая функция позволяет находить индексы элементов матрицы или фрейма данных по их значениям? Что такое цикл и для каких сценариев обработки данных могут быть полезны циклы? Перечислите несколько способов организации циклов в R, необходимые ключевые слова и параметры. Что такое инкремент и декремент? Какое ключевое слово позволяет прервать цикл и выйти из него принудительно? Какое ключевое слово позволяет прекратить текущую итерацию цикла и перейти сразу к новой итерации? Являются ли необходимыми фигурные скобки в случае когда цикл или условный оператор содержит только одно выражение? Что говорит об этом стиль программирования на R? 2.8.2 Упражнения Создайте вектор temp, в котором хранятся значения среднемесячных температур воздуха в городе Санкт-Петербурге (данные можно взять здесь). Напишите программный код, который вычисляет следующие вектора: количественное изменение температуры от месяца к месяцу (в градусах) качественное изменение (потепление или похолодание); номера зимних месяцев (со среднемесячной температурой ниже нуля); описательные статистики среднемесячных температур (summary); Выведите исходные и вычисленные данные в консоль (с пояснением что они означают). Подсказка: для вычисления разностей между элементами вектора используйте функцию diff(). На местности задан прямоугольник с координатами левого нижнего (x1, y1) и правого верхнего (x2, y2) угла. Напишите программу, которая размещает внутри этого прямоугольника случайным образом N точек и представляет результат в виде матрицы координат coords с двумя столбцами и N строками. Вызовите в конце программы plot(coords), чтобы посмотреть на результат. Координаты можно не вводить, а задать прямо в программе в виде переменных. Подсказка: координаты случайно размещенных точек имеют равномерное распределение. Вам необходимо сначала сформировать случайные векторы координат X и Y, и после этого объединить их в матрицу. Высотная поясность на северном склоне Западного Кавказа, согласно Большой Российской энциклопедии устроена следующим образом: до 500 м — степь и лесостепь до 800 м — низкогорные широколиственные леса (дуб, граб) до 1300 м — среднегорные широколиственные леса (бук) до 1600 м — смешанные леса (ель, пихта, бук) до 2300 м — криволесия (береза, бук, клён) до 2500 м — субальпийские и альпийские луга до 3300 м — субнивальная зона (фрагментарная растительность) выше (условно до 5000 м) — гляциально-нивальная зона Создайте фрейм данных, включающий два столбца: максимальная высота распространения (Hmax) и высотный пояс (Zone). Напишите программу, которая просит пользователя ввести высоту и возвращает высотный пояс, соответствующую введенной высоте (достаточно вывести строчку фрейма данных). Подсказка: Организуйте обход строчек фрейма данных с помощью цикла от \\(1\\) до \\(N\\), где \\(N\\) — количество строк. Искомый пояс будет найден, как только введенное значение станет меньше чем Hmax. После этого можно вывести результат на экран. Если введенное значение больше максимума в столбце Hmax или меньше \\(0\\), программа должна выдавать ошибку. [advanced] Решите задачу №3, используя только операции над векторами и поиск элементов, и не используя циклы. [advanced] Модифицируйте программу, написанную для решения задачи №2 таким образом, чтобы запретить точкам сближаться более чем на заданное расстояние k (это называется регулярным распределением с расстоянием ингибиции k). Сохраните результат в виде фрейма данных points со столбцами X, Y и D, где D – это расстояние до ближайшей точки. Выведите верхние строчки полученной таблицы в консоль, а также полученные точки с помощью команды plot(coords$X, coords$Y). Подсказка: вам придется генерировать в цикле по одной точке и проверять условие на каждой итерации до тех пор, пока вы не наберете требуемое количество точек. Задавайте значение k малым по отношению к размерам прямоугольника, чтобы избежать излишне долгого выполнения программы. Самсонов Т.Е. Визуализация и анализ географических данных на языке R. М.: Географический факультет МГУ, lubridate::year(Sys.Date()). DOI: 10.5281/zenodo.901911 "]
]
