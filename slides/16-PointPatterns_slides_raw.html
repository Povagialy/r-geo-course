<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Точечные процессы</title>
    <meta charset="utf-8" />
    <meta name="author" content="Тимофей Самсонов" />
    <meta name="date" content="2020-05-25" />
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link rel="stylesheet" href="style.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Точечные процессы
## Пространственная статистика
### Тимофей Самсонов
### 2020-05-25

---




## Условные обозначения

`$$||u-v|| = \big[(u_1 - v_1)^2 + (u_2 - v_2)^2\big]^{1/2}$$`
`$$b(u,r) = \{v: ||u-v|| \leq r\}$$`
`$$b(u,r) = \{v: ||u-v|| = r\}$$`
---

## Точечный паттерн

`$$\mathbf{x} = \{x_1, x_2,...x_n\}$$`

---

## Подмножество точек

.pull-left[
  ![:scale 85%](images/pregion.png)
]

.pull-right[
  ..., равняется  `\(n = n(\mathbf{x} \cap B)\)`
]

---

## Точечный процесс

&gt; __ Точечным процессом__ называется случайный процесс, реализациями которого являются точечные паттерны

__Конечный точечный процесс__ _(finite point process)_ — это точечный процесс, каждая реализация которого представляет собой ....

__Локально конечный точечный процесс__ имеет ....

---

## Равномерно случайные точки

`\(U = (U_1, U_2)\)`, `\(u = (u_1, u_2)\)`. 

`$$f(u_1, u_2) = \begin{cases}
  1/|W|,~\text{если}~(u_1, u_2) \in W\\
  0, ~\text{в противном случае}
\end{cases}$$`

---

## Равномерно случайные точки

`$$\mathbb{P}\{U \in B \} = \int_B f(u_1, u_2) du_1 du_2 = \\ = \frac{1}{|W|} \int_B 1 du_1 du_2 = \frac{|B|}{|W|}$$`
---

## Биномиальный точечный процесс

__Биномиальным__ называется точечный процесс `\(\mathbf{X} = \{X_1,..., X_n\}\)`, реализации которого содержат ... точек.

![:scale 50%](images/pbinomial.png)

Чтобы точки были распределены равномерно по пространству, необходимо выполнение двух условий:

- `\(X_1,...,X_n\)` представляют собой ... случайные величины
- Каждая из этих величин ... распределена в пределах `\(W\)`.

---

## Биномиальный точечный процесс

`$$\mathbb{P}\{n(\mathbf{X} \cap B) = k\} = 
  \left(
    \begin{array}{c}
      n \\
      k
    \end{array}
  \right) p^k (1-p)^{n-k}\color{grey}{, k = 0, 1, ..., n}$$`

`$$\left(
    \begin{array}{c}
      n \\
      k
    \end{array}
  \right) = \frac{n!}{(n-k)!~k!}$$`
  
---

## Пуассоновский процесс

__Однородный пуассоновский точечный процесс__ (homogeneous Poisson point process), или ... (... — CSR) характеризуется следующими свойствами:

- ...
- ...

![:scale 75%](images/ppoisson.png)

---

## Пуассоновский процесс

__Однородность__ _(гомогенность)_ означает, что ....:

`$$\operatorname E[n(\mathbf{X} \cap B)] = \lambda |B|$$`
Параметр `\(\lambda\)` представляет собой среднее количество точек на единицу площади ... — __... точечного процесса__.

&gt; В отличие от биномиального процесса, полностью случайный (Пуассоновский) процесс характеризуется _... количеством точек_.

---

## Пуассоновский процесс

__Пространственная независимость__ означает, что ...:

`$$n(\mathbf{X} \cap A) \not\sim n(\mathbf{X} \cap B),~A \cap B = \emptyset$$`

---

## Пуассоновский процесс

Одним из следствий независимости является тот факт, что количество точек, подсчитанное по _регулярной сетке квадратов_, также даст совокупность ...:

![:scale 75%](images/qcounts.png)

---

## Пуассоновский процесс

__Упорядоченность__ _(orderliness)_: ...

![:scale 40%](images/smalltrials.png)

---

## Пуассоновский процесс

`$$\mathbb{P}\{N = k\} = e^{-\mu} \frac{\mu^k}{k!}\color{grey}{,~k = 0, 1, 2, ...}$$`

---

## Пуассоновский процесс

`$$\mathbb{P}\{N = k\} = e^{-\mu} \frac{\mu^k}{k!} \color{grey}{,~k = 0, 1, 2, ...}$$`

Величина `\(\mu\)` представляет собой .... 

&gt; Дисперсия распределения Пуассона равна ...

`$$\mu = \lambda |B|$$`
---

## Пуассоновский процесс

Пуассоновский процесс определеяется следующими параметрами:

- __...__: количество `\(n(\mathbf{B} \cap B)\)` случайных точек, попадающих в выборочную область `\(B\)` характеризуется мат. ожиданием `\(\mathbb{E}n(\mathbf{X} \cap B) = \lambda |B|\)`; 

- __...__: для неперекрывающихся выборочных областей `\(B_1, B_2, ..., B_k\)`, количества `\(n(\mathbf{X} \cap B_1), ..., n(\mathbf{X} \cap B_k)\)` предствляют собой ...;

- __...__: число `\(n(\mathbf{B} \cap B)\)` случайных точек, попадающих в выборочную область `\(B\)` распределено по ....

---

## Свойства пуассоновского процесса

- __условность__ _(conditional)_: в любой области `\(B\)` точки процесса ... распределены;

- __прореживаемость__ _(thinning)_: при случайном прореживании (отборе точек) пуассоновского точечного паттерна с интенсивностью `\(\lambda\)` результирующий паттерн будет соответствовать Пуассоновскому процессу с интенсивностью ..., где `\(p\)` — вероятность ...;

- __суперпозиция__ _(superposition)_: сумма двух независимых гомогенных случайных точечных процессов `\(Z = X \cup Y\)` с интенсивностями `\(\lambda_X\)` и `\(\lambda_Y\)` является гомогенным ... процессом с интенсивностью ...

---

## Пуассоновский процесс

__Прореживаемость__

![:scale 70%](images/pthinning.png)

__Суперпозиция__

![:scale 70%](images/psuperposition.png)

---

## Симуляция Пуассоновского процесса

Пусть дана область `\(B = [x_{min}, x_{max}] \times [y_{min}, y_{max}]\)` и интенсивность точечного процесса `\(\lambda\)`.

1. ...

2. ...

3. ...

&gt; Вероятность получить 0 точек также существует и равна `\(\mathbb{P}\{N = 0\} = e^{-\mu} \frac{\mu^0}{0!} = ...\)`

---

## Неоднородный пуассоновский процесс

Определяется следующими параметрами:

- __функция ...__: количество `\(n(\mathbf{X} \cap B)\)` случайных точек, попадающих в выборочную область `\(B\)` характеризуется мат. ожиданием `\(\mathbb{E}n(\mathbf{X} \cap B) = \int_B \lambda(u) du = \mu\)`, где `\(\lambda(u)\)` есть ...; 

- __...__: для неперекрывающихся выборочных областей `\(B_1, B_2, ..., B_k\)`, количества `\(n(\mathbf{X} \cap B_1), ..., n(\mathbf{X} \cap B_k)\)` предствляют собой ...;

- __распределение ...__: число `\(n(\mathbf{B} \cap B)\)` случайных точек, попадающих в выборочную область `\(B\)` распределено по ...

---

## Неоднородный пуассоновский процесс

---

## Симуляция неоднородного пуассоновского процесса

Метод _Льюиса-Шедлера_ (Lewis-Shedler thinning):

1. ...

2. ...

Чтобы понять, будет ли точка исключена, генерируется случайное число 0 или 1, имющее распределени ... с вероятностью положительного исхода `\(p = p(u)\)`. Это можно сделать с помощью функции `rbinom(1, 1, p)`


---

## Симуляция неоднородного пуассоновского процесса

`$$\lambda(x,y) = x + y^2$$`

![](16-PointPatterns_slides_files/figure-html/unnamed-chunk-1-1.png)&lt;!-- --&gt;

---

## Процесс Кокса (Cox process)

Процесс Кокса определяется как ... процесс со случайной функцией интенсивности `\(\Lambda(u)\)`, которая называется _..._

![](images/cox.png)

---

## Процессы Кокса (Cox process)

- __Cмешанный Пуассоновский процесс__: ...

- __Логнормальный процесс Кокса__: ...

Для _гауссовского случайного поля_ в каждой точке `\(u_i\)` случайная величина `\(G(u_i)\)` имеет ... распределение, для пары точек `\(u\)` и `\(v\)` пара величин `\(\big(G(u), G(v)\big)\)` имеет ... распределение. Аналогично и для произвольного числа точек.

---

## Процессы Кокса (Cox process)

Независимые реализации логнормального процесса Кокса:

![](images/coxnormal.png)

---

## Кластерные процессы

![](images/clustered.png)

---

## Кластерные процессы

![](images/clustered.png)

---

### Кластерные процессы

- (CLP1) __пуассоновские родители__: ...

- (CLP2) __независимые кластеры__: ...

- (CLP3) __идентично распределенные кластеры__: ...

- (CLP4) __независимые потомки__: ...

Процессы, отвечающие требованиям (CLP1)—(CLP4) носят название процессов _..._.

---

### Кластерные процессы

- (CLP5) __пуассоновское количество потомков__: ...

- (CLP6) __изотропные кластеры__: ...

— Процесс Матерна `\((\kappa, \mu, r)\)`: ...

— Процесс Томаса `\((\kappa, \mu, \sigma)\)`: ...

---

## Кластерные процессы

...

![](images/matern.png)

---

## Регулярные процессы

Точки не могут располагаться на расстоянии ближе чем `\(r\)` — __расстояния ...__ (...).

- __Последовательные модели__: ...

- __Зависимое прореживание__: ...

---

## Регулярные процессы

__Последовательная модель__

![:scale 50%](images/rssi.png)

---

## Регулярные процессы

__Процесс ... I__

![](images/matern1.png)
---

## Регулярные процессы

__Процесс ... II__

![](images/matern2.png)
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="macros.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
